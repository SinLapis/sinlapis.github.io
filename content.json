{"meta":{"title":"SinLapis的博客","subtitle":null,"description":null,"author":"SinLapis","url":"http://sinlapis.github.io"},"pages":[{"title":"categories","date":"2019-07-10T09:18:20.000Z","updated":"2021-03-03T02:50:12.463Z","comments":true,"path":"categories/index.html","permalink":"http://sinlapis.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-10T09:16:27.000Z","updated":"2021-03-03T02:50:12.471Z","comments":true,"path":"tags/index.html","permalink":"http://sinlapis.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2021-03-03T02:50:12.467Z","updated":"2021-03-03T02:50:12.467Z","comments":true,"path":"plugins/prettify/lang-apollo.js","permalink":"http://sinlapis.github.io/plugins/prettify/lang-apollo.js","excerpt":"","text":"/** * @license * Copyright (C) 2009 Onno Hommes. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ /** * @fileoverview * Registers a language handler for the AGC/AEA Assembly Language as described * at http://virtualagc.googlecode.com * * This file could be used by goodle code to allow syntax highlight for * Virtual AGC SVN repository or if you don't want to commonize * the header for the agc/aea html assembly listing. * * @author ohommes@alumni.cmu.edu */ PR['registerLangHandler']( PR['createSimpleLexer']( [ // A line comment that starts with ; [PR['PR_COMMENT'], /^#[^\\r\\n]*/, null, '#'], // Whitespace [PR['PR_PLAIN'], /^[\\t\\n\\r \\xA0]+/, null, '\\t\\n\\r \\xA0'], // A double quoted, possibly multi-line, string. [PR['PR_STRING'], /^\\\"(?:[^\\\"\\\\]|\\\\[\\s\\S])*(?:\\\"|$)/, null, '\"'] ], [ [PR['PR_KEYWORD'], /^(?:ADS|AD|AUG|BZF|BZMF|CAE|CAF|CA|CCS|COM|CS|DAS|DCA|DCOM|DCS|DDOUBL|DIM|DOUBLE|DTCB|DTCF|DV|DXCH|EDRUPT|EXTEND|INCR|INDEX|NDX|INHINT|LXCH|MASK|MSK|MP|MSU|NOOP|OVSK|QXCH|RAND|READ|RELINT|RESUME|RETURN|ROR|RXOR|SQUARE|SU|TCR|TCAA|OVSK|TCF|TC|TS|WAND|WOR|WRITE|XCH|XLQ|XXALQ|ZL|ZQ|ADD|ADZ|SUB|SUZ|MPY|MPR|MPZ|DVP|COM|ABS|CLA|CLZ|LDQ|STO|STQ|ALS|LLS|LRS|TRA|TSQ|TMI|TOV|AXT|TIX|DLY|INP|OUT)\\s/,null], [PR['PR_TYPE'], /^(?:-?GENADR|=MINUS|2BCADR|VN|BOF|MM|-?2CADR|-?[1-6]DNADR|ADRES|BBCON|[SE]?BANK\\=?|BLOCK|BNKSUM|E?CADR|COUNT\\*?|2?DEC\\*?|-?DNCHAN|-?DNPTR|EQUALS|ERASE|MEMORY|2?OCT|REMADR|SETLOC|SUBRO|ORG|BSS|BES|SYN|EQU|DEFINE|END)\\s/,null], // A single quote possibly followed by a word that optionally ends with // = ! or ?. [PR['PR_LITERAL'], /^\\'(?:-*(?:\\w|\\\\[\\x21-\\x7e])(?:[\\w-]*|\\\\[\\x21-\\x7e])[=!?]?)?/], // Any word including labels that optionally ends with = ! or ?. [PR['PR_PLAIN'], /^-*(?:[!-z_]|\\\\[\\x21-\\x7e])(?:[\\w-]*|\\\\[\\x21-\\x7e])[=!?]?/i], // A printable non-space non-special character [PR['PR_PUNCTUATION'], /^[^\\w\\t\\n\\r \\xA0()\\\"\\\\\\';]+/] ]), ['apollo', 'agc', 'aea']);"},{"title":"","date":"2021-03-03T02:50:12.467Z","updated":"2021-03-03T02:50:12.467Z","comments":true,"path":"plugins/prettify/lang-basic.js","permalink":"http://sinlapis.github.io/plugins/prettify/lang-basic.js","excerpt":"","text":"/** * @license * Copyright (C) 2013 Peter Kofler * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ // Contributed by peter dot kofler at code minus cop dot org /** * @fileoverview * Registers a language handler for Basic. * * To use, include prettify.js and this file in your HTML page. * Then put your code in an HTML tag like * (my BASIC code) * * @author peter dot kofler at code minus cop dot org */ PR.registerLangHandler( PR.createSimpleLexer( [ // shortcutStylePatterns // \"single-line-string\" [PR.PR_STRING, /^(?:\"(?:[^\\\\\"\\r\\n]|\\\\.)*(?:\"|$))/, null, '\"'], // Whitespace [PR.PR_PLAIN, /^\\s+/, null, ' \\r\\n\\t\\xA0'] ], [ // fallthroughStylePatterns // A line comment that starts with REM [PR.PR_COMMENT, /^REM[^\\r\\n]*/, null], [PR.PR_KEYWORD, /^\\b(?:AND|CLOSE|CLR|CMD|CONT|DATA|DEF ?FN|DIM|END|FOR|GET|GOSUB|GOTO|IF|INPUT|LET|LIST|LOAD|NEW|NEXT|NOT|ON|OPEN|OR|POKE|PRINT|READ|RESTORE|RETURN|RUN|SAVE|STEP|STOP|SYS|THEN|TO|VERIFY|WAIT)\\b/, null], [PR.PR_PLAIN, /^[A-Z][A-Z0-9]?(?:\\$|%)?/i, null], // Literals .0, 0, 0.0 0E13 [PR.PR_LITERAL, /^(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+\\-]?\\d+)?/i, null, '0123456789'], [PR.PR_PUNCTUATION, /^.[^\\s\\w\\.$%\"]*/, null] // [PR.PR_PUNCTUATION, /^[-,:;!=\\+^\\/\\*]+/] ]), ['basic','cbm']);"},{"title":"","date":"2021-03-03T02:50:12.467Z","updated":"2021-03-03T02:50:12.467Z","comments":true,"path":"plugins/prettify/lang-clj.js","permalink":"http://sinlapis.github.io/plugins/prettify/lang-clj.js","excerpt":"","text":"/** * @license Copyright (C) 2011 Google Inc. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ /** * @fileoverview * Registers a language handler for Clojure. * * * To use, include prettify.js and this file in your HTML page. * Then put your code in an HTML tag like * (my lisp code) * The lang-cl class identifies the language as common lisp. * This file supports the following language extensions: * lang-clj - Clojure * * * I used lang-lisp.js as the basis for this adding the clojure specific * keywords and syntax. * * \"Name\" = 'Clojure' * \"Author\" = 'Rich Hickey' * \"Version\" = '1.2' * \"About\" = 'Clojure is a lisp for the jvm with concurrency primitives and a richer set of types.' * * * I used Clojure.org Reference as * the basis for the reserved word list. * * * @author jwall@google.com */ PR['registerLangHandler']( PR['createSimpleLexer']( [ // clojure has more paren types than minimal lisp. ['opn', /^[\\(\\{\\[]+/, null, '([{'], ['clo', /^[\\)\\}\\]]+/, null, ')]}'], // A line comment that starts with ; [PR['PR_COMMENT'], /^;[^\\r\\n]*/, null, ';'], // Whitespace [PR['PR_PLAIN'], /^[\\t\\n\\r \\xA0]+/, null, '\\t\\n\\r \\xA0'], // A double quoted, possibly multi-line, string. [PR['PR_STRING'], /^\\\"(?:[^\\\"\\\\]|\\\\[\\s\\S])*(?:\\\"|$)/, null, '\"'] ], [ // clojure has a much larger set of keywords [PR['PR_KEYWORD'], /^(?:def|if|do|let|quote|var|fn|loop|recur|throw|try|monitor-enter|monitor-exit|defmacro|defn|defn-|macroexpand|macroexpand-1|for|doseq|dosync|dotimes|and|or|when|not|assert|doto|proxy|defstruct|first|rest|cons|defprotocol|deftype|defrecord|reify|defmulti|defmethod|meta|with-meta|ns|in-ns|create-ns|import|intern|refer|alias|namespace|resolve|ref|deref|refset|new|set!|memfn|to-array|into-array|aset|gen-class|reduce|map|filter|find|nil?|empty?|hash-map|hash-set|vec|vector|seq|flatten|reverse|assoc|dissoc|list|list?|disj|get|union|difference|intersection|extend|extend-type|extend-protocol|prn)\\b/, null], [PR['PR_TYPE'], /^:[0-9a-zA-Z\\-]+/] ]), ['clj']);"},{"title":"","date":"2021-03-03T02:50:12.467Z","updated":"2021-03-03T02:50:12.467Z","comments":true,"path":"plugins/prettify/lang-css.js","permalink":"http://sinlapis.github.io/plugins/prettify/lang-css.js","excerpt":"","text":"/** * @license * Copyright (C) 2009 Google Inc. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ /** * @fileoverview * Registers a language handler for CSS. * * * To use, include prettify.js and this file in your HTML page. * Then put your code in an HTML tag like * * * * http://www.w3.org/TR/CSS21/grammar.html Section G2 defines the lexical * grammar. This scheme does not recognize keywords containing escapes. * * @author mikesamuel@gmail.com */ // This file is a call to a function defined in prettify.js which defines a // lexical scanner for CSS and maps tokens to styles. // The call to PR['registerLangHandler'] is quoted so that Closure Compiler // will not rename the call so that this language extensions can be // compiled/minified separately from one another. Other symbols defined in // prettify.js are similarly quoted. // The call is structured thus: // PR['registerLangHandler']( // PR['createSimpleLexer']( // shortcutPatterns, // fallThroughPatterns), // [languageId0, ..., languageIdN]) // Langugage IDs // ============= // The language IDs are typically the file extensions of source files for // that language so that users can syntax highlight arbitrary files based // on just the extension. This is heuristic, but works pretty well in // practice. // Patterns // ======== // Lexers are typically implemented as a set of regular expressions. // The SimpleLexer function takes regular expressions, styles, and some // pragma-info and produces a lexer. A token description looks like // [STYLE_NAME, /regular-expression/, pragmas] // Initially, simple lexer's inner loop looked like: // while sourceCode is not empty: // try each regular expression in order until one matches // remove the matched portion from sourceCode // This was really slow for large files because some JS interpreters // do a buffer copy on the matched portion which is O(n*n) // The current loop now looks like // 1. use js-modules/combinePrefixPatterns.js to // combine all regular expressions into one // 2. use a single global regular expresion match to extract all tokens // 3. for each token try regular expressions in order until one matches it // and classify it using the associated style // This is a lot more efficient but it does mean that lookahead and lookbehind // can't be used across boundaries to classify tokens. // Sometimes we need lookahead and lookbehind and sometimes we want to handle // embedded language -- JavaScript or CSS embedded in HTML, or inline assembly // in C. // If a particular pattern has a numbered group, and its style pattern starts // with \"lang-\" as in // ['lang-js', /(.*?)/] // then the token classification step breaks the token into pieces. // Group 1 is re-parsed using the language handler for \"lang-js\", and the // surrounding portions are reclassified using the current language handler. // This mechanism gives us both lookahead, lookbehind, and language embedding. // Shortcut Patterns // ================= // A shortcut pattern is one that is tried before other patterns if the first // character in the token is in the string of characters. // This very effectively lets us make quick correct decisions for common token // types. // All other patterns are fall-through patterns. // The comments inline below refer to productions in the CSS specification's // lexical grammar. See link above. PR['registerLangHandler']( PR['createSimpleLexer']( // Shortcut patterns. [ // The space production [PR['PR_PLAIN'], /^[ \\t\\r\\n\\f]+/, null, ' \\t\\r\\n\\f'] ], // Fall-through patterns. [ // Quoted strings. and [PR['PR_STRING'], /^\\\"(?:[^\\n\\r\\f\\\\\\\"]|\\\\(?:\\r\\n?|\\n|\\f)|\\\\[\\s\\S])*\\\"/, null], [PR['PR_STRING'], /^\\'(?:[^\\n\\r\\f\\\\\\']|\\\\(?:\\r\\n?|\\n|\\f)|\\\\[\\s\\S])*\\'/, null], ['lang-css-str', /^url\\(([^\\)\\\"\\']+)\\)/i], [PR['PR_KEYWORD'], /^(?:url|rgb|\\!important|@import|@page|@media|@charset|inherit)(?=[^\\-\\w]|$)/i, null], // A property name -- an identifier followed by a colon. ['lang-css-kw', /^(-?(?:[_a-z]|(?:\\\\[0-9a-f]+ ?))(?:[_a-z0-9\\-]|\\\\(?:\\\\[0-9a-f]+ ?))*)\\s*:/i], // A C style block comment. The production. [PR['PR_COMMENT'], /^\\/\\*[^*]*\\*+(?:[^\\/*][^*]*\\*+)*\\//], // Escaping text spans [PR['PR_COMMENT'], /^(?:)/], // A number possibly containing a suffix. [PR['PR_LITERAL'], /^(?:\\d+|\\d*\\.\\d+)(?:%|[a-z]+)?/i], // A hex color [PR['PR_LITERAL'], /^#(?:[0-9a-f]{3}){1,2}\\b/i], // An identifier [PR['PR_PLAIN'], /^-?(?:[_a-z]|(?:\\\\[\\da-f]+ ?))(?:[_a-z\\d\\-]|\\\\(?:\\\\[\\da-f]+ ?))*/i], // A run of punctuation [PR['PR_PUNCTUATION'], /^[^\\s\\w\\'\\\"]+/] ]), ['css']); // Above we use embedded languages to highlight property names (identifiers // followed by a colon) differently from identifiers in values. PR['registerLangHandler']( PR['createSimpleLexer']([], [ [PR['PR_KEYWORD'], /^-?(?:[_a-z]|(?:\\\\[\\da-f]+ ?))(?:[_a-z\\d\\-]|\\\\(?:\\\\[\\da-f]+ ?))*/i] ]), ['css-kw']); // The content of an unquoted URL literal like url(http://foo/img.png) should // be colored as string content. This language handler is used above in the // URL production to do so. PR['registerLangHandler']( PR['createSimpleLexer']([], [ [PR['PR_STRING'], /^[^\\)\\\"\\']+/] ]), ['css-str']);"},{"title":"","date":"2021-03-03T02:50:12.467Z","updated":"2021-03-03T02:50:12.467Z","comments":true,"path":"plugins/prettify/lang-dart.js","permalink":"http://sinlapis.github.io/plugins/prettify/lang-dart.js","excerpt":"","text":"/** * @license * Copyright (C) 2013 Google Inc. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ /** * @fileoverview * Registers a language handler Dart. * Loosely structured based on the DartLexer in Pygments: http://pygments.org/. * * To use, include prettify.js and this file in your HTML page. * Then put your code in an HTML tag like * (Dart code) * * @author armstrong.timothy@gmail.com */ PR['registerLangHandler']( PR['createSimpleLexer']( [ // Whitespace. [PR['PR_PLAIN'], /^[\\t\\n\\r \\xA0]+/, null, '\\t\\n\\r \\xA0'] ], [ // Script tag. [PR['PR_COMMENT'], /^#!(?:.*)/], // `import`, `library`, `part of`, `part`, `as`, `show`, and `hide` // keywords. [PR['PR_KEYWORD'], /^\\b(?:import|library|part of|part|as|show|hide)\\b/i], // Single-line comments. [PR['PR_COMMENT'], /^\\/\\/(?:.*)/], // Multiline comments. [PR['PR_COMMENT'], /^\\/\\*[^*]*\\*+(?:[^\\/*][^*]*\\*+)*\\//], // */ // `class` and `interface` keywords. [PR['PR_KEYWORD'], /^\\b(?:class|interface)\\b/i], // General keywords. [PR['PR_KEYWORD'], /^\\b(?:assert|async|await|break|case|catch|continue|default|do|else|finally|for|if|in|is|new|return|super|switch|sync|this|throw|try|while)\\b/i], // Declaration keywords. [PR['PR_KEYWORD'], /^\\b(?:abstract|const|extends|factory|final|get|implements|native|operator|set|static|typedef|var)\\b/i], // Keywords for types. [PR['PR_TYPE'], /^\\b(?:bool|double|Dynamic|int|num|Object|String|void)\\b/i], // Keywords for constants. [PR['PR_KEYWORD'], /^\\b(?:false|null|true)\\b/i], // Multiline strings, single- and double-quoted. [PR['PR_STRING'], /^r?[\\']{3}[\\s|\\S]*?[^\\\\][\\']{3}/], [PR['PR_STRING'], /^r?[\\\"]{3}[\\s|\\S]*?[^\\\\][\\\"]{3}/], // Normal and raw strings, single- and double-quoted. [PR['PR_STRING'], /^r?\\'(\\'|(?:[^\\n\\r\\f])*?[^\\\\]\\')/], [PR['PR_STRING'], /^r?\\\"(\\\"|(?:[^\\n\\r\\f])*?[^\\\\]\\\")/], // Types are capitalized by convention. [PR['PR_TYPE'], /^[A-Z]\\w*/], // Identifiers. [PR['PR_PLAIN'], /^[a-z_$][a-z0-9_]*/i], // Operators. [PR['PR_PUNCTUATION'], /^[~!%^&*+=|?:/-]/], // Hex numbers. [PR['PR_LITERAL'], /^\\b0x[0-9a-f]+/i], // Decimal numbers. [PR['PR_LITERAL'], /^\\b\\d+(?:\\.\\d*)?(?:e[+-]?\\d+)?/i], [PR['PR_LITERAL'], /^\\b\\.\\d+(?:e[+-]?\\d+)?/i], // Punctuation. [PR['PR_PUNCTUATION'], /^[(){}\\[\\],.;]/] ]), ['dart']);"},{"title":"","date":"2021-03-03T02:50:12.467Z","updated":"2021-03-03T02:50:12.467Z","comments":true,"path":"plugins/prettify/lang-erlang.js","permalink":"http://sinlapis.github.io/plugins/prettify/lang-erlang.js","excerpt":"","text":"/** * @license * Copyright (C) 2013 Andrew Allen * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ /** * @fileoverview * Registers a language handler for Erlang. * * Derived from https://raw.github.com/erlang/otp/dev/lib/compiler/src/core_parse.yrl * Modified from Mike Samuel's Haskell plugin for google-code-prettify * * @author achew22@gmail.com */ PR['registerLangHandler']( PR['createSimpleLexer']( [ // Whitespace // whitechar -> newline | vertab | space | tab | uniWhite // newline -> return linefeed | return | linefeed | formfeed [PR['PR_PLAIN'], /^[\\t\\n\\x0B\\x0C\\r ]+/, null, '\\t\\n\\x0B\\x0C\\r '], // Single line double-quoted strings. [PR['PR_STRING'], /^\\\"(?:[^\\\"\\\\\\n\\x0C\\r]|\\\\[\\s\\S])*(?:\\\"|$)/, null, '\"'], // Handle atoms [PR['PR_LITERAL'], /^[a-z][a-zA-Z0-9_]*/], // Handle single quoted atoms [PR['PR_LITERAL'], /^\\'(?:[^\\'\\\\\\n\\x0C\\r]|\\\\[^&])+\\'?/, null, \"'\"], // Handle macros. Just to be extra clear on this one, it detects the ? // then uses the regexp to end it so be very careful about matching // all the terminal elements [PR['PR_LITERAL'], /^\\?[^ \\t\\n({]+/, null, \"?\"], // decimal -> digit{digit} // octal -> octit{octit} // hexadecimal -> hexit{hexit} // integer -> decimal // | 0o octal | 0O octal // | 0x hexadecimal | 0X hexadecimal // float -> decimal . decimal [exponent] // | decimal exponent // exponent -> (e | E) [+ | -] decimal [PR['PR_LITERAL'], /^(?:0o[0-7]+|0x[\\da-f]+|\\d+(?:\\.\\d+)?(?:e[+\\-]?\\d+)?)/i, null, '0123456789'] ], [ // TODO: catch @declarations inside comments // Comments in erlang are started with % and go till a newline [PR['PR_COMMENT'], /^%[^\\n]*/], // Catch macros //[PR['PR_TAG'], /?[^( \\n)]+/], /** * %% Keywords (atoms are assumed to always be single-quoted). * 'module' 'attributes' 'do' 'let' 'in' 'letrec' * 'apply' 'call' 'primop' * 'case' 'of' 'end' 'when' 'fun' 'try' 'catch' 'receive' 'after' */ [PR['PR_KEYWORD'], /^(?:module|attributes|do|let|in|letrec|apply|call|primop|case|of|end|when|fun|try|catch|receive|after|char|integer|float,atom,string,var)\\b/], /** * Catch definitions (usually defined at the top of the file) * Anything that starts -something */ [PR['PR_KEYWORD'], /^-[a-z_]+/], // Catch variables [PR['PR_TYPE'], /^[A-Z_][a-zA-Z0-9_]*/], // matches the symbol production [PR['PR_PUNCTUATION'], /^[.,;]/] ]), ['erlang', 'erl']);"},{"title":"","date":"2021-03-03T02:50:12.467Z","updated":"2021-03-03T02:50:12.467Z","comments":true,"path":"plugins/prettify/lang-ex.js","permalink":"http://sinlapis.github.io/plugins/prettify/lang-ex.js","excerpt":"","text":"/** * @license * Copyright (C) 2017 Jacek Królikowski * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ /** * @fileoverview * Registers a language handler for Elixir. * * @author nietaki@gmail.com */ PR['registerLangHandler']( PR['createSimpleLexer']( [ [PR['PR_PLAIN'], /^[\\t\\n\\r \\xA0]+/, null, '\\t\\n\\r \\xA0'], // # comments [PR['PR_COMMENT'], /^#.*/, null, '#'], // a (possibly multiline) charlist [PR['PR_LITERAL'], /^'(?:[^'\\\\]|\\\\(?:.|\\n|\\r))*'?/, null, '\\''], // @attributes [PR['PR_ATTRIB_NAME'], /^@\\w+/, null, '@'], [PR['PR_PUNCTUATION'], /^[!%&()*+,\\-;?\\[\\\\\\]^{|}]+/, null, '!%&()*+,-;?[\\\\]^{|}'], // Borrowed from lang-erlang.js: [PR['PR_LITERAL'], /^(?:0o[0-7](?:[0-7]|_[0-7])*|0x[\\da-fA-F](?:[\\da-fA-F]|_[\\da-fA-F])*|\\d(?:\\d|_\\d)*(?:\\.\\d(?:\\d|_\\d)*)?(?:[eE][+\\-]?\\d(?:\\d|_\\d)*)?)/, null, '0123456789'] ], [ // the iex> prompt for interactive examples [PR['PR_ATTRIB_NAME'], /^iex(?:\\(\\d+\\))?> /], // special case for binaries, so that they don't get presented like atoms [PR['PR_PUNCTUATION'], /^::/], // atoms - :__a_word or :\"colon followed by a string\" [PR['PR_LITERAL'], /^:(?:\\w+[\\!\\?\\@]?|\"(?:[^\"\\\\]|\\\\.)*\"?)/], // compile-time information [PR['PR_ATTRIB_NAME'], /^(?:__(?:CALLER|ENV|MODULE|DIR)__)/], // keywords [PR['PR_KEYWORD'], /^(?:alias|case|catch|def(?:delegate|exception|impl|macrop?|module|overridable|p?|protocol|struct)|do|else|end|fn|for|if|in|import|quote|raise|require|rescue|super|throw|try|unless|unquote(?:_splicing)?|use|when|with|yield)\\b/], [PR['PR_LITERAL'], /^(?:true|false|nil)\\b/], // atoms as keyword list keys // NOTE: this does also handle the %{\"I'm an atom\": :foo} case // // Contains negative lookahead to handle [PR['PR_LITERAL'], /^(?:\\w+[\\!\\?\\@]?|\"(?:[^\"\\\\]|\\\\.)*\"):(?!:)/], // heredoc: triple double-quoted multi-line string. // // NOTE: the opening \"\"\" needs to be followed by a newline [PR['PR_STRING'], /^\"\"\"\\s*(\\r|\\n)+(?:\"\"?(?!\")|[^\\\\\"]|\\\\(?:.|\\n|\\r))*\"{0,3}/], // A double-quoted multi-line string [PR['PR_STRING'], /^\"(?:[^\"\\\\]|\\\\(?:.|\\n|\\r))*\"?(?!\")/], // types [PR['PR_TYPE'], /^[A-Z]\\w*/], // variables not meant to be used or private functions [PR['PR_COMMENT'], /^_\\w*/], // plain: variables, functions, ... [PR['PR_PLAIN'], /^[$a-z]\\w*[\\!\\?]?/], // sigils with the same starting and ending character. // Key part: X(?:[^X\\r\\n\\\\]|\\\\.)+X where X is the sigil character [PR['PR_ATTRIB_VALUE'], /^~[A-Z](?:\\/(?:[^\\/\\r\\n\\\\]|\\\\.)+\\/|\\|(?:[^\\|\\r\\n\\\\]|\\\\.)+\\||\"(?:[^\"\\r\\n\\\\]|\\\\.)+\"|'(?:[^'\\r\\n\\\\]|\\\\.)+')[A-Z]*/i], // sigils with a different starting and ending character. // Key part: X(?:[^Y\\r\\n\\\\]|\\\\.)+Y where X and Y are the starting and ending characters [PR['PR_ATTRIB_VALUE'], /^~[A-Z](?:\\((?:[^\\)\\r\\n\\\\]|\\\\.)+\\)|\\[(?:[^\\]\\r\\n\\\\]|\\\\.)+\\]|\\{(?:[^\\}\\r\\n\\\\]|\\\\.)+\\}|\\\\r\\n\\\\]|\\\\.)+\\>)[A-Z]*/i], [PR['PR_PUNCTUATION'], /^(?:\\.+|\\/|[:~])/] ]), ['ex','exs']);"},{"title":"","date":"2021-03-03T02:50:12.467Z","updated":"2021-03-03T02:50:12.467Z","comments":true,"path":"plugins/prettify/lang-go.js","permalink":"http://sinlapis.github.io/plugins/prettify/lang-go.js","excerpt":"","text":"/** * @license * Copyright (C) 2010 Google Inc. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ /** * @fileoverview * Registers a language handler for the Go language.. * * Based on the lexical grammar at * http://golang.org/doc/go_spec.html#Lexical_elements * * Go uses a minimal style for highlighting so the below does not distinguish * strings, keywords, literals, etc. by design. * From a discussion with the Go designers: * * On Thursday, July 22, 2010, Mike Samuel wrote: * > On Thu, Jul 22, 2010, Rob 'Commander' Pike wrote: * >> Personally, I would vote for the subdued style godoc presents at http://golang.org * >> * >> Not as fancy as some like, but a case can be made it's the official style. * >> If people want more colors, I wouldn't fight too hard, in the interest of * >> encouragement through familiarity, but even then I would ask to shy away * >> from technicolor starbursts. * > * > Like http://golang.org/pkg/go/scanner/ where comments are blue and all * > other content is black? I can do that. * * * @author mikesamuel@gmail.com */ PR['registerLangHandler']( PR['createSimpleLexer']( [ // Whitespace is made up of spaces, tabs and newline characters. [PR['PR_PLAIN'], /^[\\t\\n\\r \\xA0]+/, null, '\\t\\n\\r \\xA0'], // Not escaped as a string. See note on minimalism above. [PR['PR_PLAIN'], /^(?:\\\"(?:[^\\\"\\\\]|\\\\[\\s\\S])*(?:\\\"|$)|\\'(?:[^\\'\\\\]|\\\\[\\s\\S])+(?:\\'|$)|`[^`]*(?:`|$))/, null, '\"\\''] ], [ // Block comments are delimited by /* and */. // Single-line comments begin with // and extend to the end of a line. [PR['PR_COMMENT'], /^(?:\\/\\/[^\\r\\n]*|\\/\\*[\\s\\S]*?\\*\\/)/], [PR['PR_PLAIN'], /^(?:[^\\/\\\"\\'`]|\\/(?![\\/\\*]))+/i] ]), ['go']);"},{"title":"","date":"2021-03-03T02:50:12.467Z","updated":"2021-03-03T02:50:12.467Z","comments":true,"path":"plugins/prettify/lang-hs.js","permalink":"http://sinlapis.github.io/plugins/prettify/lang-hs.js","excerpt":"","text":"/** * @license * Copyright (C) 2009 Google Inc. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ /** * @fileoverview * Registers a language handler for Haskell. * * * To use, include prettify.js and this file in your HTML page. * Then put your code in an HTML tag like * (my lisp code) * The lang-cl class identifies the language as common lisp. * This file supports the following language extensions: * lang-cl - Common Lisp * lang-el - Emacs Lisp * lang-lisp - Lisp * lang-scm - Scheme * * * I used http://www.informatik.uni-freiburg.de/~thiemann/haskell/haskell98-report-html/syntax-iso.html * as the basis, but ignore the way the ncomment production nests since this * makes the lexical grammar irregular. It might be possible to support * ncomments using the lookbehind filter. * * * @author mikesamuel@gmail.com */ PR['registerLangHandler']( PR['createSimpleLexer']( [ // Whitespace // whitechar -> newline | vertab | space | tab | uniWhite // newline -> return linefeed | return | linefeed | formfeed [PR['PR_PLAIN'], /^[\\t\\n\\x0B\\x0C\\r ]+/, null, '\\t\\n\\x0B\\x0C\\r '], // Single line double and single-quoted strings. // char -> ' (graphic \" {graphic \\ ( charesc | ascii | decimal | o octal // | x hexadecimal ) // charesc -> a | b | f | n | r | t | v | \\ | \" | ' | & [PR['PR_STRING'], /^\\\"(?:[^\\\"\\\\\\n\\x0C\\r]|\\\\[\\s\\S])*(?:\\\"|$)/, null, '\"'], [PR['PR_STRING'], /^\\'(?:[^\\'\\\\\\n\\x0C\\r]|\\\\[^&])\\'?/, null, \"'\"], // decimal -> digit{digit} // octal -> octit{octit} // hexadecimal -> hexit{hexit} // integer -> decimal // | 0o octal | 0O octal // | 0x hexadecimal | 0X hexadecimal // float -> decimal . decimal [exponent] // | decimal exponent // exponent -> (e | E) [+ | -] decimal [PR['PR_LITERAL'], /^(?:0o[0-7]+|0x[\\da-f]+|\\d+(?:\\.\\d+)?(?:e[+\\-]?\\d+)?)/i, null, '0123456789'] ], [ // Haskell does not have a regular lexical grammar due to the nested // ncomment. // comment -> dashes [ any {any}] newline // ncomment -> opencom ANYseq {ncomment ANYseq}closecom // dashes -> '--' {'-'} // opencom -> '{-' // closecom -> '-}' [PR['PR_COMMENT'], /^(?:(?:--+(?:[^\\r\\n\\x0C]*)?)|(?:\\{-(?:[^-]|-+[^-\\}])*-\\}))/], // reservedid -> case | class | data | default | deriving | do // | else | if | import | in | infix | infixl | infixr // | instance | let | module | newtype | of | then // | type | where | _ [PR['PR_KEYWORD'], /^(?:case|class|data|default|deriving|do|else|if|import|in|infix|infixl|infixr|instance|let|module|newtype|of|then|type|where|_)(?=[^a-zA-Z0-9\\']|$)/, null], // qvarid -> [ modid . ] varid // qconid -> [ modid . ] conid // varid -> (small {small | large | digit | ' }) // conid -> large {small | large | digit | ' } // modid -> conid // small -> ascSmall | uniSmall | _ // ascSmall -> a | b | ... | z // uniSmall -> any Unicode lowercase letter // large -> ascLarge | uniLarge // ascLarge -> A | B | ... | Z // uniLarge -> any uppercase or titlecase Unicode letter [PR['PR_PLAIN'], /^(?:[A-Z][\\w\\']*\\.)*[a-zA-Z][\\w\\']*/], // matches the symbol production [PR['PR_PUNCTUATION'], /^[^\\t\\n\\x0B\\x0C\\r a-zA-Z0-9\\'\\\"]+/] ]), ['hs']);"},{"title":"","date":"2021-03-03T02:50:12.467Z","updated":"2021-03-03T02:50:12.467Z","comments":true,"path":"plugins/prettify/lang-lasso.js","permalink":"http://sinlapis.github.io/plugins/prettify/lang-lasso.js","excerpt":"","text":"/** * @license * Copyright (C) 2013 Eric Knibbe * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ /** * @fileoverview * Registers a language handler for Lasso. * * To use, include prettify.js and this file in your HTML page. * Then enclose your code in an HTML tag like so: * [your Lasso code] * * @author Eric Knibbe */ PR['registerLangHandler']( PR['createSimpleLexer']( [ // whitespace [PR['PR_PLAIN'], /^[\\t\\n\\r \\xA0]+/, null, '\\t\\n\\r \\xA0'], // single quote strings [PR['PR_STRING'], /^\\'(?:[^\\'\\\\]|\\\\[\\s\\S])*(?:\\'|$)/, null, \"'\"], // double quote strings [PR['PR_STRING'], /^\\\"(?:[^\\\"\\\\]|\\\\[\\s\\S])*(?:\\\"|$)/, null, '\"'], // ticked strings [PR['PR_STRING'], /^\\`[^\\`]*(?:\\`|$)/, null, '`'], // numeral as integer or hexidecimal [PR['PR_LITERAL'], /^0x[\\da-f]+|\\d+/i, null, '0123456789'], // local or thread variables, or hashbang [PR['PR_ATTRIB_NAME'], /^#\\d+|[#$][a-z_][\\w.]*|#![ \\S]+lasso9\\b/i, null, '#$'] ], [ // square or angle bracket delimiters [PR['PR_TAG'], /^[[\\]]||noprocess\\b|no_square_brackets\\b/i], // single-line or block comments [PR['PR_COMMENT'], /^\\/\\/[^\\r\\n]*|\\/\\*[\\s\\S]*?\\*\\//], // member variables or keyword parameters [PR['PR_ATTRIB_NAME'], /^-(?!infinity)[a-z_][\\w.]*|\\.\\s*'[a-z_][\\w.]*'/i], // numeral as decimal or scientific notation [PR['PR_LITERAL'], /^\\d*\\.\\d+(?:e[-+]?\\d+)?|infinity\\b|NaN\\b/i], // tag literals [PR['PR_ATTRIB_VALUE'], /^::\\s*[a-z_][\\w.]*/i], // constants [PR['PR_LITERAL'], /^(?:true|false|none|minimal|full|all|void|and|or|not|bw|nbw|ew|new|cn|ncn|lt|lte|gt|gte|eq|neq|rx|nrx|ft)\\b/i], // container or control keywords [PR['PR_KEYWORD'], /^(?:error_code|error_msg|error_pop|error_push|error_reset|cache|database_names|database_schemanames|database_tablenames|define_tag|define_type|email_batch|encode_set|html_comment|handle|handle_error|header|if|inline|iterate|ljax_target|link|link_currentaction|link_currentgroup|link_currentrecord|link_detail|link_firstgroup|link_firstrecord|link_lastgroup|link_lastrecord|link_nextgroup|link_nextrecord|link_prevgroup|link_prevrecord|log|loop|namespace_using|output_none|portal|private|protect|records|referer|referrer|repeating|resultset|rows|search_args|search_arguments|select|sort_args|sort_arguments|thread_atomic|value_list|while|abort|case|else|if_empty|if_false|if_null|if_true|loop_abort|loop_continue|loop_count|params|params_up|return|return_value|run_children|soap_definetag|soap_lastrequest|soap_lastresponse|tag_name|ascending|average|by|define|descending|do|equals|frozen|group|handle_failure|import|in|into|join|let|match|max|min|on|order|parent|protected|provide|public|require|returnhome|skip|split_thread|sum|take|thread|to|trait|type|where|with|yield|yieldhome)\\b/i], // standard type or variable declarations [PR['PR_TYPE'], /^(?:array|date|decimal|duration|integer|map|pair|string|tag|xml|null|boolean|bytes|keyword|list|locale|queue|set|stack|staticarray|local|var|variable|global|data|self|inherited|currentcapture|givenblock)\\b|^\\.\\.?/i], // type, method, or parameter names [PR['PR_PLAIN'], /^[a-z_][\\w.]*(?:=\\s*(?=\\())?/i], // operators [PR['PR_PUNCTUATION'], /^:=|[-+*\\/%=&|!?\\\\]/] ]), ['lasso', 'ls', 'lassoscript']);"},{"title":"","date":"2021-03-03T02:50:12.467Z","updated":"2021-03-03T02:50:12.467Z","comments":true,"path":"plugins/prettify/lang-lisp.js","permalink":"http://sinlapis.github.io/plugins/prettify/lang-lisp.js","excerpt":"","text":"/** * @license * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ /** * @fileoverview * Registers a language handler for Common Lisp and related languages. * * * To use, include prettify.js and this file in your HTML page. * Then put your code in an HTML tag like * (my lisp code) * The lang-cl class identifies the language as common lisp. * This file supports the following language extensions: * lang-cl - Common Lisp * lang-el - Emacs Lisp * lang-lisp - Lisp * lang-scm - Scheme * lang-lsp - FAT 8.3 filename version of lang-lisp. * * * I used http://www.devincook.com/goldparser/doc/meta-language/grammar-LISP.htm * as the basis, but added line comments that start with ; and changed the atom * production to disallow unquoted semicolons. * * \"Name\" = 'LISP' * \"Author\" = 'John McCarthy' * \"Version\" = 'Minimal' * \"About\" = 'LISP is an abstract language that organizes ALL' * | 'data around \"lists\".' * * \"Start Symbol\" = [s-Expression] * * {Atom Char} = {Printable} - {Whitespace} - [()\"\\''] * * Atom = ( {Atom Char} | '\\'{Printable} )+ * * [s-Expression] ::= [Quote] Atom * | [Quote] '(' [Series] ')' * | [Quote] '(' [s-Expression] '.' [s-Expression] ')' * * [Series] ::= [s-Expression] [Series] * | * * [Quote] ::= '' !Quote = do not evaluate * | * * * I used Practical Common Lisp as * the basis for the reserved word list. * * * @author mikesamuel@gmail.com */ PR['registerLangHandler']( PR['createSimpleLexer']( [ ['opn', /^\\(+/, null, '('], ['clo', /^\\)+/, null, ')'], // A line comment that starts with ; [PR['PR_COMMENT'], /^;[^\\r\\n]*/, null, ';'], // Whitespace [PR['PR_PLAIN'], /^[\\t\\n\\r \\xA0]+/, null, '\\t\\n\\r \\xA0'], // A double quoted, possibly multi-line, string. [PR['PR_STRING'], /^\\\"(?:[^\\\"\\\\]|\\\\[\\s\\S])*(?:\\\"|$)/, null, '\"'] ], [ [PR['PR_KEYWORD'], /^(?:block|c[ad]+r|catch|con[ds]|def(?:ine|un)|do|eq|eql|equal|equalp|eval-when|flet|format|go|if|labels|lambda|let|load-time-value|locally|macrolet|multiple-value-call|nil|progn|progv|quote|require|return-from|setq|symbol-macrolet|t|tagbody|the|throw|unwind)\\b/, null], [PR['PR_LITERAL'], /^[+\\-]?(?:[0#]x[0-9a-f]+|\\d+\\/\\d+|(?:\\.\\d+|\\d+(?:\\.\\d*)?)(?:[ed][+\\-]?\\d+)?)/i], // A single quote possibly followed by a word that optionally ends with // = ! or ?. [PR['PR_LITERAL'], /^\\'(?:-*(?:\\w|\\\\[\\x21-\\x7e])(?:[\\w-]*|\\\\[\\x21-\\x7e])[=!?]?)?/], // A word that optionally ends with = ! or ?. [PR['PR_PLAIN'], /^-*(?:[a-z_]|\\\\[\\x21-\\x7e])(?:[\\w-]*|\\\\[\\x21-\\x7e])[=!?]?/i], // A printable non-space non-special character [PR['PR_PUNCTUATION'], /^[^\\w\\t\\n\\r \\xA0()\\\"\\\\\\';]+/] ]), ['cl', 'el', 'lisp', 'lsp', 'scm', 'ss', 'rkt']);"},{"title":"","date":"2021-03-03T02:50:12.467Z","updated":"2021-03-03T02:50:12.467Z","comments":true,"path":"plugins/prettify/lang-llvm.js","permalink":"http://sinlapis.github.io/plugins/prettify/lang-llvm.js","excerpt":"","text":"/** * @license * Copyright (C) 2013 Nikhil Dabas * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ /** * @fileoverview * Registers a language handler for LLVM. * From https://gist.github.com/ndabas/2850418 * * * To use, include prettify.js and this file in your HTML page. * Then put your code in an HTML tag like * (my LLVM code) * * * The regular expressions were adapted from: * https://github.com/hansstimer/llvm.tmbundle/blob/76fedd8f50fd6108b1780c51d79fbe3223de5f34/Syntaxes/LLVM.tmLanguage * * http://llvm.org/docs/LangRef.html#constants describes the language grammar. * * @author Nikhil Dabas */ PR['registerLangHandler']( PR['createSimpleLexer']( [ // Whitespace [PR['PR_PLAIN'], /^[\\t\\n\\r \\xA0]+/, null, '\\t\\n\\r \\xA0'], // A double quoted, possibly multi-line, string. [PR['PR_STRING'], /^!?\\\"(?:[^\\\"\\\\]|\\\\[\\s\\S])*(?:\\\"|$)/, null, '\"'], // comment.llvm [PR['PR_COMMENT'], /^;[^\\r\\n]*/, null, ';'] ], [ // variable.llvm [PR['PR_PLAIN'], /^[%@!](?:[-a-zA-Z$._][-a-zA-Z$._0-9]*|\\d+)/], // According to http://llvm.org/docs/LangRef.html#well-formedness // These reserved words cannot conflict with variable names, because none of them start with a prefix character ('%' or '@'). [PR['PR_KEYWORD'], /^[A-Za-z_][0-9A-Za-z_]*/, null], // constant.numeric.float.llvm [PR['PR_LITERAL'], /^\\d+\\.\\d+/], // constant.numeric.integer.llvm [PR['PR_LITERAL'], /^(?:\\d+|0[xX][a-fA-F0-9]+)/], // punctuation [PR['PR_PUNCTUATION'], /^[()\\[\\]{},=*:]|\\.\\.\\.$/] ]), ['llvm', 'll']);"},{"title":"","date":"2021-03-03T02:50:12.467Z","updated":"2021-03-03T02:50:12.467Z","comments":true,"path":"plugins/prettify/lang-logtalk.js","permalink":"http://sinlapis.github.io/plugins/prettify/lang-logtalk.js","excerpt":"","text":"/** * @license * Copyright (C) 2014 Paulo Moura * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ /** * @fileoverview * Registers a language handler for Logtalk. * http://logtalk.org/ * @author Paulo Moura */ PR['registerLangHandler']( PR['createSimpleLexer']( [ // double-quoted strings. [PR['PR_STRING'], /^\\\"(?:[^\\\"\\\\\\n\\x0C\\r]|\\\\[\\s\\S])*(?:\\\"|$)/, null, '\"'], // atoms (don't break on underscores!) [PR['PR_LITERAL'], /^[a-z][a-zA-Z0-9_]*/], // quoted atoms [PR['PR_LITERAL'], /^\\'(?:[^\\'\\\\\\n\\x0C\\r]|\\\\[^&])+\\'?/, null, \"'\"], // numbers [PR['PR_LITERAL'], /^(?:0'.|0b[0-1]+|0o[0-7]+|0x[\\da-f]+|\\d+(?:\\.\\d+)?(?:e[+\\-]?\\d+)?)/i, null, '0123456789'] ], [ // single-line comments begin with % [PR['PR_COMMENT'], /^%[^\\r\\n]*/, null, '%'], // block comments are delimited by /* and */ [PR['PR_COMMENT'], /^\\/\\*[\\s\\S]*?\\*\\//], // directives [PR['PR_KEYWORD'], /^\\s*:-\\s(c(a(lls|tegory)|oinductive)|p(ublic|r(ot(ocol|ected)|ivate))|e(l(if|se)|n(coding|sure_loaded)|xport)|i(f|n(clude|itialization|fo))|alias|d(ynamic|iscontiguous)|m(eta_(non_terminal|predicate)|od(e|ule)|ultifile)|reexport|s(et_(logtalk|prolog)_flag|ynchronized)|o(bject|p)|use(s|_module))/], [PR['PR_KEYWORD'], /^\\s*:-\\s(e(lse|nd(if|_(category|object|protocol)))|built_in|dynamic|synchronized|threaded)/], // variables [PR['PR_TYPE'], /^[A-Z_][a-zA-Z0-9_]*/], // operators [PR['PR_PUNCTUATION'], /^[.,;{}:^=\\\\/+*?#!-]/] ]), ['logtalk', 'lgt']);"},{"title":"","date":"2021-03-03T02:50:12.471Z","updated":"2021-03-03T02:50:12.471Z","comments":true,"path":"plugins/prettify/lang-lua.js","permalink":"http://sinlapis.github.io/plugins/prettify/lang-lua.js","excerpt":"","text":"/** * @license * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ /** * @fileoverview * Registers a language handler for Lua. * * * To use, include prettify.js and this file in your HTML page. * Then put your code in an HTML tag like * (my Lua code) * * * I used http://www.lua.org/manual/5.1/manual.html#2.1 * Because of the long-bracket concept used in strings and comments, Lua does * not have a regular lexical grammar, but luckily it fits within the space * of irregular grammars supported by javascript regular expressions. * * @author mikesamuel@gmail.com */ PR['registerLangHandler']( PR['createSimpleLexer']( [ // Whitespace [PR['PR_PLAIN'], /^[\\t\\n\\r \\xA0]+/, null, '\\t\\n\\r \\xA0'], // A double or single quoted, possibly multi-line, string. [PR['PR_STRING'], /^(?:\\\"(?:[^\\\"\\\\]|\\\\[\\s\\S])*(?:\\\"|$)|\\'(?:[^\\'\\\\]|\\\\[\\s\\S])*(?:\\'|$))/, null, '\"\\''] ], [ // A comment is either a line comment that starts with two dashes, or // two dashes preceding a long bracketed block. [PR['PR_COMMENT'], /^--(?:\\[(=*)\\[[\\s\\S]*?(?:\\]\\1\\]|$)|[^\\r\\n]*)/], // A long bracketed block not preceded by -- is a string. [PR['PR_STRING'], /^\\[(=*)\\[[\\s\\S]*?(?:\\]\\1\\]|$)/], [PR['PR_KEYWORD'], /^(?:and|break|do|else|elseif|end|false|for|function|if|in|local|nil|not|or|repeat|return|then|true|until|while)\\b/, null], // A number is a hex integer literal, a decimal real literal, or in // scientific notation. [PR['PR_LITERAL'], /^[+-]?(?:0x[\\da-f]+|(?:(?:\\.\\d+|\\d+(?:\\.\\d*)?)(?:e[+\\-]?\\d+)?))/i], // An identifier [PR['PR_PLAIN'], /^[a-z_]\\w*/i], // A run of punctuation [PR['PR_PUNCTUATION'], /^[^\\w\\t\\n\\r \\xA0][^\\w\\t\\n\\r \\xA0\\\"\\'\\-\\+=]*/] ]), ['lua']);"},{"title":"","date":"2021-03-03T02:50:12.471Z","updated":"2021-03-03T02:50:12.471Z","comments":true,"path":"plugins/prettify/lang-ml.js","permalink":"http://sinlapis.github.io/plugins/prettify/lang-ml.js","excerpt":"","text":"/** * @license * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ /** * @fileoverview * Registers a language handler for OCaml, SML, F# and similar languages. * * Based on the lexical grammar at * http://research.microsoft.com/en-us/um/cambridge/projects/fsharp/manual/spec.html#_Toc270597388 * * @author mikesamuel@gmail.com */ PR['registerLangHandler']( PR['createSimpleLexer']( [ // Whitespace is made up of spaces, tabs and newline characters. [PR['PR_PLAIN'], /^[\\t\\n\\r \\xA0]+/, null, '\\t\\n\\r \\xA0'], // #if ident/#else/#endif directives delimit conditional compilation // sections [PR['PR_COMMENT'], /^#(?:if[\\t\\n\\r \\xA0]+(?:[a-z_$][\\w\\']*|``[^\\r\\n\\t`]*(?:``|$))|else|endif|light)/i, null, '#'], // A double or single quoted, possibly multi-line, string. // F# allows escaped newlines in strings. [PR['PR_STRING'], /^(?:\\\"(?:[^\\\"\\\\]|\\\\[\\s\\S])*(?:\\\"|$)|\\'(?:[^\\'\\\\]|\\\\[\\s\\S])(?:\\'|$))/, null, '\"\\''] ], [ // Block comments are delimited by (* and *) and may be // nested. Single-line comments begin with // and extend to // the end of a line. // TODO: (*...*) comments can be nested. This does not handle that. [PR['PR_COMMENT'], /^(?:\\/\\/[^\\r\\n]*|\\(\\*[\\s\\S]*?\\*\\))/], [PR['PR_KEYWORD'], /^(?:abstract|and|as|assert|begin|class|default|delegate|do|done|downcast|downto|elif|else|end|exception|extern|false|finally|for|fun|function|if|in|inherit|inline|interface|internal|lazy|let|match|member|module|mutable|namespace|new|null|of|open|or|override|private|public|rec|return|static|struct|then|to|true|try|type|upcast|use|val|void|when|while|with|yield|asr|land|lor|lsl|lsr|lxor|mod|sig|atomic|break|checked|component|const|constraint|constructor|continue|eager|event|external|fixed|functor|global|include|method|mixin|object|parallel|process|protected|pure|sealed|trait|virtual|volatile)\\b/], // A number is a hex integer literal, a decimal real literal, or in // scientific notation. [PR['PR_LITERAL'], /^[+\\-]?(?:0x[\\da-f]+|(?:(?:\\.\\d+|\\d+(?:\\.\\d*)?)(?:e[+\\-]?\\d+)?))/i], [PR['PR_PLAIN'], /^(?:[a-z_][\\w']*[!?#]?|``[^\\r\\n\\t`]*(?:``|$))/i], // A printable non-space non-special character [PR['PR_PUNCTUATION'], /^[^\\t\\n\\r \\xA0\\\"\\'\\w]+/] ]), ['fs', 'ml']);"},{"title":"","date":"2021-03-03T02:50:12.471Z","updated":"2021-03-03T02:50:12.471Z","comments":true,"path":"plugins/prettify/lang-mumps.js","permalink":"http://sinlapis.github.io/plugins/prettify/lang-mumps.js","excerpt":"","text":"/** * @license * Copyright (C) 2011 Kitware Inc. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ /** * @fileoverview * Registers a language handler for MUMPS. * * * To use, include prettify.js and this file in your HTML page. * Then put your code in an HTML tag like * (my SQL code) * * Commands, intrinsic functions and variables taken from ISO/IEC 11756:1999(E) * * @author chris.harris@kitware.com * * Known issues: * * - Currently can't distinguish between keywords and local or global variables having the same name * for exampe SET IF=\"IF?\" * - m file are already used for MatLab hence using mumps. */ (function () { var commands = 'B|BREAK|' + 'C|CLOSE|' + 'D|DO|' + 'E|ELSE|' + 'F|FOR|' + 'G|GOTO|' + 'H|HALT|' + 'H|HANG|' + 'I|IF|' + 'J|JOB|' + 'K|KILL|' + 'L|LOCK|' + 'M|MERGE|' + 'N|NEW|' + 'O|OPEN|' + 'Q|QUIT|' + 'R|READ|' + 'S|SET|' + 'TC|TCOMMIT|' + 'TRE|TRESTART|' + 'TRO|TROLLBACK|' + 'TS|TSTART|' + 'U|USE|' + 'V|VIEW|' + 'W|WRITE|' + 'X|XECUTE'; var intrinsicVariables = 'D|DEVICE|' + 'EC|ECODE|' + 'ES|ESTACK|' + 'ET|ETRAP|' + 'H|HOROLOG|' + 'I|IO|' + 'J|JOB|' + 'K|KEY|' + 'P|PRINCIPAL|' + 'Q|QUIT|' + 'ST|STACK|' + 'S|STORAGE|' + 'SY|SYSTEM|' + 'T|TEST|' + 'TL|TLEVEL|' + 'TR|TRESTART|' + 'X|' + 'Y|' + 'Z[A-Z]*|'; var intrinsicFunctions = 'A|ASCII|' + 'C|CHAR|' + 'D|DATA|' + 'E|EXTRACT|' + 'F|FIND|' + 'FN|FNUMBER|' + 'G|GET|' + 'J|JUSTIFY|' + 'L|LENGTH|' + 'NA|NAME|' + 'O|ORDER|' + 'P|PIECE|' + 'QL|QLENGTH|' + 'QS|QSUBSCRIPT|' + 'Q|QUERY|' + 'R|RANDOM|' + 'RE|REVERSE|' + 'S|SELECT|' + 'ST|STACK|' + 'T|TEXT|' + 'TR|TRANSLATE|' + 'V|VIEW|' * 'Z[A-Z]*|'; var intrinsic = intrinsicVariables + intrinsicFunctions; var shortcutStylePatterns = [ // Whitespace [PR['PR_PLAIN'], /^[\\t\\n\\r \\xA0]+/, null, '\\t\\n\\r \\xA0'], // A double or single quoted, possibly multi-line, string. [PR['PR_STRING'], /^(?:\"(?:[^\"]|\\\\.)*\")/, null, '\"'] ]; var fallthroughStylePatterns = [ // A line comment that starts with ; [PR['PR_COMMENT'], /^;[^\\r\\n]*/, null, ';'], // Add intrinsic variables and functions as declarations, there not really but it mean // they will hilighted differently from commands. [PR['PR_DECLARATION'], new RegExp('^(?:\\\\$(?:' + intrinsic + '))\\\\b', 'i'), null], // Add commands as keywords [PR['PR_KEYWORD'], new RegExp('^(?:[^\\\\$]' + commands + ')\\\\b', 'i'), null], // A number is a decimal real literal or in scientific notation. [PR['PR_LITERAL'], /^[+-]?(?:(?:\\.\\d+|\\d+(?:\\.\\d*)?)(?:E[+\\-]?\\d+)?)/i], // An identifier [PR['PR_PLAIN'], /^[a-z][a-zA-Z0-9]*/i], // Exclude $ % and ^ [PR['PR_PUNCTUATION'], /^[^\\w\\t\\n\\r\\xA0\\\"\\$;%\\^]|_/] ]; // Can't use m as its already used for MatLab PR.registerLangHandler(PR.createSimpleLexer(shortcutStylePatterns, fallthroughStylePatterns), ['mumps']); })();"},{"title":"","date":"2021-03-03T02:50:12.471Z","updated":"2021-03-03T02:50:12.471Z","comments":true,"path":"plugins/prettify/lang-n.js","permalink":"http://sinlapis.github.io/plugins/prettify/lang-n.js","excerpt":"","text":"/** * @license * Copyright (C) 2011 Zimin A.V. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ /** * @fileoverview * Registers a language handler for the Nemerle language. * http://nemerle.org * @author Zimin A.V. */ (function () { // http://nemerle.org/wiki/index.php?title=Base_keywords var keywords = 'abstract|and|as|base|catch|class|def|delegate|enum|event|extern|false|finally|' + 'fun|implements|interface|internal|is|macro|match|matches|module|mutable|namespace|new|' + 'null|out|override|params|partial|private|protected|public|ref|sealed|static|struct|' + 'syntax|this|throw|true|try|type|typeof|using|variant|virtual|volatile|when|where|with|' + 'assert|assert2|async|break|checked|continue|do|else|ensures|for|foreach|if|late|lock|new|nolate|' + 'otherwise|regexp|repeat|requires|return|surroundwith|unchecked|unless|using|while|yield'; PR['registerLangHandler'](PR['createSimpleLexer']( // shortcutStylePatterns [ [PR['PR_STRING'], /^(?:\\'(?:[^\\\\\\'\\r\\n]|\\\\.)*\\'|\\\"(?:[^\\\\\\\"\\r\\n]|\\\\.)*(?:\\\"|$))/, null, '\"'], [PR['PR_COMMENT'], /^#(?:(?:define|elif|else|endif|error|ifdef|include|ifndef|line|pragma|undef|warning)\\b|[^\\r\\n]*)/, null, '#'], [PR['PR_PLAIN'], /^\\s+/, null, ' \\r\\n\\t\\xA0'] ], // fallthroughStylePatterns [ [PR['PR_STRING'], /^@\\\"(?:[^\\\"]|\\\"\\\")*(?:\\\"|$)/, null], [PR['PR_STRING'], /^])*(?:#>|$)/, null], [PR['PR_STRING'], /^/, null], [PR['PR_COMMENT'], /^\\/\\/[^\\r\\n]*/, null], [PR['PR_COMMENT'], /^\\/\\*[\\s\\S]*?(?:\\*\\/|$)/, null], [PR['PR_KEYWORD'], new RegExp('^(?:' + keywords + ')\\\\b'), null], [PR['PR_TYPE'], /^(?:array|bool|byte|char|decimal|double|float|int|list|long|object|sbyte|short|string|ulong|uint|ufloat|ulong|ushort|void)\\b/, null], [PR['PR_LITERAL'], /^@[a-z_$][a-z_$@0-9]*/i, null], [PR['PR_TYPE'], /^@[A-Z]+[a-z][A-Za-z_$@0-9]*/, null], [PR['PR_PLAIN'], /^'?[A-Za-z_$][a-z_$@0-9]*/i, null], [PR['PR_LITERAL'], new RegExp( '^(?:' // A hex number + '0x[a-f0-9]+' // or an octal or decimal number, + '|(?:\\\\d(?:_\\\\d+)*\\\\d*(?:\\\\.\\\\d*)?|\\\\.\\\\d\\\\+)' // possibly in scientific notation + '(?:e[+\\\\-]?\\\\d+)?' + ')' // with an optional modifier like UL for unsigned long + '[a-z]*', 'i'), null, '0123456789'], [PR['PR_PUNCTUATION'], /^.[^\\s\\w\\.$@\\'\\\"\\`\\/\\#]*/, null] ]), ['n', 'nemerle']); })();"},{"title":"","date":"2021-03-03T02:50:12.471Z","updated":"2021-03-03T02:50:12.471Z","comments":true,"path":"plugins/prettify/lang-pascal.js","permalink":"http://sinlapis.github.io/plugins/prettify/lang-pascal.js","excerpt":"","text":"/** * @license * Copyright (C) 2013 Peter Kofler * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ // Contributed by peter dot kofler at code minus cop dot org /** * @fileoverview * Registers a language handler for (Turbo) Pascal. * * To use, include prettify.js and this file in your HTML page. * Then put your code in an HTML tag like * (my Pascal code) * * @author peter dot kofler at code minus cop dot org */ PR.registerLangHandler( PR.createSimpleLexer( [ // shortcutStylePatterns // 'single-line-string' [PR.PR_STRING, /^(?:\\'(?:[^\\\\\\'\\r\\n]|\\\\.)*(?:\\'|$))/, null, '\\''], // Whitespace [PR.PR_PLAIN, /^\\s+/, null, ' \\r\\n\\t\\xA0'] ], [ // fallthroughStylePatterns // A cStyleComments comment (* *) or {} [PR.PR_COMMENT, /^\\(\\*[\\s\\S]*?(?:\\*\\)|$)|^\\{[\\s\\S]*?(?:\\}|$)/, null], [PR.PR_KEYWORD, /^(?:ABSOLUTE|AND|ARRAY|ASM|ASSEMBLER|BEGIN|CASE|CONST|CONSTRUCTOR|DESTRUCTOR|DIV|DO|DOWNTO|ELSE|END|EXTERNAL|FOR|FORWARD|FUNCTION|GOTO|IF|IMPLEMENTATION|IN|INLINE|INTERFACE|INTERRUPT|LABEL|MOD|NOT|OBJECT|OF|OR|PACKED|PROCEDURE|PROGRAM|RECORD|REPEAT|SET|SHL|SHR|THEN|TO|TYPE|UNIT|UNTIL|USES|VAR|VIRTUAL|WHILE|WITH|XOR)\\b/i, null], [PR.PR_LITERAL, /^(?:true|false|self|nil)/i, null], [PR.PR_PLAIN, /^[a-z][a-z0-9]*/i, null], // Literals .0, 0, 0.0 0E13 [PR.PR_LITERAL, /^(?:\\$[a-f0-9]+|(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+\\-]?\\d+)?)/i, null, '0123456789'], [PR.PR_PUNCTUATION, /^.[^\\s\\w\\.$@\\'\\/]*/, null] ]), ['pascal']);"},{"title":"","date":"2021-03-03T02:50:12.471Z","updated":"2021-03-03T02:50:12.471Z","comments":true,"path":"plugins/prettify/lang-proto.js","permalink":"http://sinlapis.github.io/plugins/prettify/lang-proto.js","excerpt":"","text":"/** * @license * Copyright (C) 2006 Google Inc. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ /** * @fileoverview * Registers a language handler for Protocol Buffers as described at * http://code.google.com/p/protobuf/. * * Based on the lexical grammar at * http://research.microsoft.com/fsharp/manual/spec2.aspx#_Toc202383715 * * @author mikesamuel@gmail.com */ PR['registerLangHandler'](PR['sourceDecorator']({ 'keywords': ( 'bytes,default,double,enum,extend,extensions,false,' + 'group,import,max,message,option,' + 'optional,package,repeated,required,returns,rpc,service,' + 'syntax,to,true'), 'types': /^(bool|(double|s?fixed|[su]?int)(32|64)|float|string)\\b/, 'cStyleComments': true }), ['proto']);"},{"title":"","date":"2021-03-03T02:50:12.471Z","updated":"2021-03-03T02:50:12.471Z","comments":true,"path":"plugins/prettify/lang-r.js","permalink":"http://sinlapis.github.io/plugins/prettify/lang-r.js","excerpt":"","text":"/** * @license * Copyright (C) 2012 Jeffrey B. Arnold * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ /** * @fileoverview * Registers a language handler for S, S-plus, and R source code. * * * To use, include prettify.js and this file in your HTML page. * Then put your code in an HTML tag like * code * * Language definition from * http://cran.r-project.org/doc/manuals/R-lang.html. * Many of the regexes are shared with the pygments SLexer, * http://pygments.org/. * * Original: https://raw.github.com/jrnold/prettify-lang-r-bugs/master/lang-r.js * * @author jeffrey.arnold@gmail.com */ PR['registerLangHandler']( PR['createSimpleLexer']( [ [PR['PR_PLAIN'], /^[\\t\\n\\r \\xA0]+/, null, '\\t\\n\\r \\xA0'], [PR['PR_STRING'], /^\\\"(?:[^\\\"\\\\]|\\\\[\\s\\S])*(?:\\\"|$)/, null, '\"'], [PR['PR_STRING'], /^\\'(?:[^\\'\\\\]|\\\\[\\s\\S])*(?:\\'|$)/, null, \"'\"] ], [ [PR['PR_COMMENT'], /^#.*/], [PR['PR_KEYWORD'], /^(?:if|else|for|while|repeat|in|next|break|return|switch|function)(?![A-Za-z0-9_.])/], // hex numbes [PR['PR_LITERAL'], /^0[xX][a-fA-F0-9]+([pP][0-9]+)?[Li]?/], // Decimal numbers [PR['PR_LITERAL'], /^[+-]?([0-9]+(\\.[0-9]+)?|\\.[0-9]+)([eE][+-]?[0-9]+)?[Li]?/], // builtin symbols [PR['PR_LITERAL'], /^(?:NULL|NA(?:_(?:integer|real|complex|character)_)?|Inf|TRUE|FALSE|NaN|\\.\\.(?:\\.|[0-9]+))(?![A-Za-z0-9_.])/], // assignment, operators, and parens, etc. [PR['PR_PUNCTUATION'], /^(?:?|-|==|=||&&?|!=|\\|\\|?|\\*|\\+|\\^|\\/|!|%.*?%|=|~|\\$|@|:{1,3}|[\\[\\](){};,?])/], // valid variable names [PR['PR_PLAIN'], /^(?:[A-Za-z]+[A-Za-z0-9_.]*|\\.[a-zA-Z_][0-9a-zA-Z\\._]*)(?![A-Za-z0-9_.])/], // string backtick [PR['PR_STRING'], /^`.+`/] ]), ['r', 's', 'R', 'S', 'Splus']);"},{"title":"","date":"2021-03-03T02:50:12.471Z","updated":"2021-03-03T02:50:12.471Z","comments":true,"path":"plugins/prettify/lang-rd.js","permalink":"http://sinlapis.github.io/plugins/prettify/lang-rd.js","excerpt":"","text":"/** * @license * Copyright (C) 2012 Jeffrey Arnold * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ /** * @fileoverview * Support for R documentation (Rd) files * * Minimal highlighting or Rd files, basically just highlighting * macros. It does not try to identify verbatim or R-like regions of * macros as that is too complicated for a lexer. Descriptions of the * Rd format can be found * http://cran.r-project.org/doc/manuals/R-exts.html and * http://developer.r-project.org/parseRd.pdf. * * @author Jeffrey Arnold */ PR['registerLangHandler']( PR['createSimpleLexer']( [ // whitespace [PR['PR_PLAIN'], /^[\\t\\n\\r \\xA0]+/, null, '\\t\\n\\r \\xA0'], // all comments begin with '%' [PR['PR_COMMENT'], /^%[^\\r\\n]*/, null, '%'] ], [// special macros with no args [PR['PR_LITERAL'], /^\\\\(?:cr|l?dots|R|tab)\\b/], // macros [PR['PR_KEYWORD'], /^\\\\[a-zA-Z@]+/], // highlighted as macros, since technically they are [PR['PR_KEYWORD'], /^#(?:ifn?def|endif)/ ], // catch escaped brackets [PR['PR_PLAIN'], /^\\\\[{}]/], // punctuation [PR['PR_PUNCTUATION'], /^[{}()\\[\\]]+/] ]), ['Rd', 'rd']);"},{"title":"","date":"2021-03-03T02:50:12.471Z","updated":"2021-03-03T02:50:12.471Z","comments":true,"path":"plugins/prettify/lang-rust.js","permalink":"http://sinlapis.github.io/plugins/prettify/lang-rust.js","excerpt":"","text":"/** * @license * Copyright (C) 2015 Chris Morgan * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ /** * @fileoverview * Registers a language handler for Rust. * * Derived from prior experience implementing similar things in a few environments, * most especially rust.vim. * * @author me@chrismorgan.info */ PR['registerLangHandler']( PR['createSimpleLexer']([], [ // Whitespace [PR['PR_PLAIN'], /^[\\t\\n\\r \\xA0]+/], // Single line comments [PR['PR_COMMENT'], /^\\/\\/.*/], // Block comments (sadly I do not see how to make this cope with comment nesting as it should) [PR['PR_COMMENT'], /^\\/\\*[\\s\\S]*?(?:\\*\\/|$)/],//, null], // String and character literals [PR['PR_STRING'], /^b\"(?:[^\\\\]|\\\\(?:.|x[\\da-fA-F]{2}))*?\"/], // Bytes literal [PR['PR_STRING'], /^\"(?:[^\\\\]|\\\\(?:.|x[\\da-fA-F]{2}|u\\{\\[\\da-fA-F]{1,6}\\}))*?\"/], // String literal [PR['PR_STRING'], /^b?r(#*)\\\"[\\s\\S]*?\\\"\\1/], // Raw string/bytes literal [PR['PR_STRING'], /^b'([^\\\\]|\\\\(.|x[\\da-fA-F]{2}))'/], // Byte literal [PR['PR_STRING'], /^'([^\\\\]|\\\\(.|x[\\da-fA-F]{2}|u\\{[\\da-fA-F]{1,6}\\}))'/], // Character literal // Lifetime [PR['PR_TAG'], /^'\\w+?\\b/], // Keywords, reserved keywords and primitive types [PR['PR_KEYWORD'], /^(?:match|if|else|as|break|box|continue|extern|fn|for|in|if|impl|let|loop|pub|return|super|unsafe|where|while|use|mod|trait|struct|enum|type|move|mut|ref|static|const|crate)\\b/], [PR['PR_KEYWORD'], /^(?:alignof|become|do|offsetof|priv|pure|sizeof|typeof|unsized|yield|abstract|virtual|final|override|macro)\\b/], [PR['PR_TYPE'], /^(?:[iu](8|16|32|64|size)|char|bool|f32|f64|str|Self)\\b/], // Rust 1.0 prelude items [PR['PR_TYPE'], /^(?:Copy|Send|Sized|Sync|Drop|Fn|FnMut|FnOnce|Box|ToOwned|Clone|PartialEq|PartialOrd|Eq|Ord|AsRef|AsMut|Into|From|Default|Iterator|Extend|IntoIterator|DoubleEndedIterator|ExactSizeIterator|Option|Some|None|Result|Ok|Err|SliceConcatExt|String|ToString|Vec)\\b/], // Literals: [PR['PR_LITERAL'], /^(self|true|false|null)\\b/], // A number is a hex integer literal, a decimal real literal, or in // scientific notation. // Integer literals: decimal, hexadecimal, octal, binary. [PR['PR_LITERAL'], /^\\d[0-9_]*(?:[iu](?:size|8|16|32|64))?/], [PR['PR_LITERAL'], /^0x[a-fA-F0-9_]+(?:[iu](?:size|8|16|32|64))?/], [PR['PR_LITERAL'], /^0o[0-7_]+(?:[iu](?:size|8|16|32|64))?/], [PR['PR_LITERAL'], /^0b[01_]+(?:[iu](?:size|8|16|32|64))?/], // Float literals [PR['PR_LITERAL'], /^\\d[0-9_]*\\.(?![^\\s\\d.])/], [PR['PR_LITERAL'], /^\\d[0-9_]*(?:\\.\\d[0-9_]*)(?:[eE][+-]?[0-9_]+)?(?:f32|f64)?/], [PR['PR_LITERAL'], /^\\d[0-9_]*(?:\\.\\d[0-9_]*)?(?:[eE][+-]?[0-9_]+)(?:f32|f64)?/], [PR['PR_LITERAL'], /^\\d[0-9_]*(?:\\.\\d[0-9_]*)?(?:[eE][+-]?[0-9_]+)?(?:f32|f64)/], // Macro invocations (an identifier plus a !) [PR['PR_ATTRIB_NAME'], /^[a-z_]\\w*!/i], // An identifier (sorry, this should be unicode) [PR['PR_PLAIN'], /^[a-z_]\\w*/i], // Attributes [PR['PR_ATTRIB_VALUE'], /^#!?\\[[\\s\\S]*?\\]/], // All the punctuation [PR['PR_PUNCTUATION'], /^[+\\-/*=^&|!%[\\](){}?:.,;]/], // Anything else (which is probably illegal, as all the legal stuff should have been covered) can be plain [PR['PR_PLAIN'], /./] ]), ['rust']);"},{"title":"","date":"2021-03-03T02:50:12.471Z","updated":"2021-03-03T02:50:12.471Z","comments":true,"path":"plugins/prettify/lang-scala.js","permalink":"http://sinlapis.github.io/plugins/prettify/lang-scala.js","excerpt":"","text":"/** * @license * Copyright (C) 2010 Google Inc. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ /** * @fileoverview * Registers a language handler for Scala. * * Derived from http://lampsvn.epfl.ch/svn-repos/scala/scala-documentation/trunk/src/reference/SyntaxSummary.tex * * @author mikesamuel@gmail.com */ PR['registerLangHandler']( PR['createSimpleLexer']( [ // Whitespace [PR['PR_PLAIN'], /^[\\t\\n\\r \\xA0]+/, null, '\\t\\n\\r \\xA0'], // A double or single quoted string // or a triple double-quoted multi-line string. [PR['PR_STRING'], /^(?:\"(?:(?:\"\"(?:\"\"?(?!\")|[^\\\\\"]|\\\\.)*\"{0,3})|(?:[^\"\\r\\n\\\\]|\\\\.)*\"?))/, null, '\"'], [PR['PR_LITERAL'], /^`(?:[^\\r\\n\\\\`]|\\\\.)*`?/, null, '`'], [PR['PR_PUNCTUATION'], /^[!#%&()*+,\\-:;?@\\[\\\\\\]^{|}~]+/, null, '!#%&()*+,-:;?@[\\\\]^{|}~'] ], [ // A symbol literal is a single quote followed by an identifier with no // single quote following // A character literal has single quotes on either side [PR['PR_STRING'], /^'(?:[^\\r\\n\\\\']|\\\\(?:'|[^\\r\\n']+))'/], [PR['PR_LITERAL'], /^'[a-zA-Z_$][\\w$]*(?!['$\\w])/], [PR['PR_KEYWORD'], /^(?:abstract|case|catch|class|def|do|else|extends|final|finally|for|forSome|if|implicit|import|lazy|match|new|object|override|package|private|protected|requires|return|sealed|super|throw|trait|try|type|val|var|while|with|yield)\\b/], [PR['PR_LITERAL'], /^(?:true|false|null|this)\\b/], [PR['PR_LITERAL'], /^(?:(?:0(?:[0-7]+|X[0-9A-F]+))L?|(?:(?:0|[1-9][0-9]*)(?:(?:\\.[0-9]+)?(?:E[+\\-]?[0-9]+)?F?|L?))|\\\\.[0-9]+(?:E[+\\-]?[0-9]+)?F?)/i], // Treat upper camel case identifiers as types. [PR['PR_TYPE'], /^[$_]*[A-Z][_$A-Z0-9]*[a-z][\\w$]*/], [PR['PR_PLAIN'], /^[$a-zA-Z_][\\w$]*/], [PR['PR_COMMENT'], /^\\/(?:\\/.*|\\*(?:\\/|\\**[^*/])*(?:\\*+\\/?)?)/], [PR['PR_PUNCTUATION'], /^(?:\\.+|\\/)/] ]), ['scala']);"},{"title":"","date":"2021-03-03T02:50:12.471Z","updated":"2021-03-03T02:50:12.471Z","comments":true,"path":"plugins/prettify/lang-sql.js","permalink":"http://sinlapis.github.io/plugins/prettify/lang-sql.js","excerpt":"","text":"/** * @license * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ /** * @fileoverview * Registers a language handler for SQL. * * * To use, include prettify.js and this file in your HTML page. * Then put your code in an HTML tag like * (my SQL code) * * * http://savage.net.au/SQL/sql-99.bnf.html is the basis for the grammar, and * http://msdn.microsoft.com/en-us/library/aa238507(SQL.80).aspx and * http://meta.stackoverflow.com/q/92352/137403 as the bases for the keyword * list. * * @author mikesamuel@gmail.com */ PR['registerLangHandler']( PR['createSimpleLexer']( [ // Whitespace [PR['PR_PLAIN'], /^[\\t\\n\\r \\xA0]+/, null, '\\t\\n\\r \\xA0'], // A double or single quoted, possibly multi-line, string. [PR['PR_STRING'], /^(?:\"(?:[^\\\"\\\\]|\\\\.)*\"|'(?:[^\\'\\\\]|\\\\.)*')/, null, '\"\\''] ], [ // A comment is either a line comment that starts with two dashes, or // two dashes preceding a long bracketed block. [PR['PR_COMMENT'], /^(?:--[^\\r\\n]*|\\/\\*[\\s\\S]*?(?:\\*\\/|$))/], [PR['PR_KEYWORD'], /^(?:ADD|ALL|ALTER|AND|ANY|APPLY|AS|ASC|AUTHORIZATION|BACKUP|BEGIN|BETWEEN|BREAK|BROWSE|BULK|BY|CASCADE|CASE|CHECK|CHECKPOINT|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMN|COMMIT|COMPUTE|CONNECT|CONSTRAINT|CONTAINS|CONTAINSTABLE|CONTINUE|CONVERT|CREATE|CROSS|CURRENT|CURRENT_DATE|CURRENT_TIME|CURRENT_TIMESTAMP|CURRENT_USER|CURSOR|DATABASE|DBCC|DEALLOCATE|DECLARE|DEFAULT|DELETE|DENY|DESC|DISK|DISTINCT|DISTRIBUTED|DOUBLE|DROP|DUMMY|DUMP|ELSE|END|ERRLVL|ESCAPE|EXCEPT|EXEC|EXECUTE|EXISTS|EXIT|FETCH|FILE|FILLFACTOR|FOLLOWING|FOR|FOREIGN|FREETEXT|FREETEXTTABLE|FROM|FULL|FUNCTION|GOTO|GRANT|GROUP|HAVING|HOLDLOCK|IDENTITY|IDENTITYCOL|IDENTITY_INSERT|IF|IN|INDEX|INNER|INSERT|INTERSECT|INTO|IS|JOIN|KEY|KILL|LEFT|LIKE|LINENO|LOAD|MATCH|MATCHED|MERGE|NATURAL|NATIONAL|NOCHECK|NONCLUSTERED|NOCYCLE|NOT|NULL|NULLIF|OF|OFF|OFFSETS|ON|OPEN|OPENDATASOURCE|OPENQUERY|OPENROWSET|OPENXML|OPTION|OR|ORDER|OUTER|OVER|PARTITION|PERCENT|PIVOT|PLAN|PRECEDING|PRECISION|PRIMARY|PRINT|PROC|PROCEDURE|PUBLIC|RAISERROR|READ|READTEXT|RECONFIGURE|REFERENCES|REPLICATION|RESTORE|RESTRICT|RETURN|REVOKE|RIGHT|ROLLBACK|ROWCOUNT|ROWGUIDCOL|ROWS?|RULE|SAVE|SCHEMA|SELECT|SESSION_USER|SET|SETUSER|SHUTDOWN|SOME|START|STATISTICS|SYSTEM_USER|TABLE|TEXTSIZE|THEN|TO|TOP|TRAN|TRANSACTION|TRIGGER|TRUNCATE|TSEQUAL|UNBOUNDED|UNION|UNIQUE|UNPIVOT|UPDATE|UPDATETEXT|USE|USER|USING|VALUES|VARYING|VIEW|WAITFOR|WHEN|WHERE|WHILE|WITH|WITHIN|WRITETEXT|XML)(?=[^\\w-]|$)/i, null], // A number is a hex integer literal, a decimal real literal, or in // scientific notation. [PR['PR_LITERAL'], /^[+-]?(?:0x[\\da-f]+|(?:(?:\\.\\d+|\\d+(?:\\.\\d*)?)(?:e[+\\-]?\\d+)?))/i], // An identifier [PR['PR_PLAIN'], /^[a-z_][\\w-]*/i], // A run of punctuation [PR['PR_PUNCTUATION'], /^[^\\w\\t\\n\\r \\xA0\\\"\\'][^\\w\\t\\n\\r \\xA0+\\-\\\"\\']*/] ]), ['sql']);"},{"title":"","date":"2021-03-03T02:50:12.471Z","updated":"2021-03-03T02:50:12.471Z","comments":true,"path":"plugins/prettify/lang-swift.js","permalink":"http://sinlapis.github.io/plugins/prettify/lang-swift.js","excerpt":"","text":"/** * @license * Copyright (C) 2015 Google Inc. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ /** * @fileoverview * Registers a language handler for Swift * * * To use, include prettify.js and this file in your HTML page. * Then put your code in an HTML tag like * (my swift code) * This file supports the following language extensions: * lang-swift - Swift * * I used https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AboutTheLanguageReference.html * as the source of truth for this. The revision from 2015-10-21 (Swift 2.1) was used in most recent update. * * @author cerech@google.com */ PR['registerLangHandler']( PR['createSimpleLexer']( [ //whitespace [PR['PR_PLAIN'], /^[ \\n\\r\\t\\v\\f\\0]+/, null, ' \\n\\r\\t\\v\\f\\0'], //string literals [PR['PR_STRING'], /^\"(?:[^\"\\\\]|(?:\\\\.)|(?:\\\\\\((?:[^\"\\\\)]|\\\\.)*\\)))*\"/, null, '\"'] ], [ //floating point literals [PR['PR_LITERAL'], /^(?:(?:0x[\\da-fA-F][\\da-fA-F_]*\\.[\\da-fA-F][\\da-fA-F_]*[pP]?)|(?:\\d[\\d_]*\\.\\d[\\d_]*[eE]?))[+-]?\\d[\\d_]*/, null], //integer literals [PR['PR_LITERAL'], /^-?(?:(?:0(?:(?:b[01][01_]*)|(?:o[0-7][0-7_]*)|(?:x[\\da-fA-F][\\da-fA-F_]*)))|(?:\\d[\\d_]*))/, null], //some other literals [PR['PR_LITERAL'], /^(?:true|false|nil)\\b/, null], //keywords [PR['PR_KEYWORD'], /^\\b(?:__COLUMN__|__FILE__|__FUNCTION__|__LINE__|#available|#else|#elseif|#endif|#if|#line|arch|arm|arm64|associativity|as|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|dynamicType|else|enum|extension|fallthrough|final|for|func|get|guard|import|indirect|infix|init|inout|internal|i386|if|in|iOS|iOSApplicationExtension|is|lazy|left|let|mutating|none|nonmutating|operator|optional|OSX|OSXApplicationExtension|override|postfix|precedence|prefix|private|protocol|Protocol|public|required|rethrows|return|right|safe|self|set|static|struct|subscript|super|switch|throw|try|Type|typealias|unowned|unsafe|var|weak|watchOS|while|willSet|x86_64)\\b/, null], //double slash comments [PR['PR_COMMENT'], /^\\/\\/.*?[\\n\\r]/, null], //slash star comments [PR['PR_COMMENT'], /^\\/\\*[\\s\\S]*?(?:\\*\\/|$)/, null], //punctuation [PR['PR_PUNCTUATION'], /^|===|==|\\.\\.\\.|&&=|\\.\\.|`|==|\\+\\+|--|\\/|\\+|!|\\*|%||&|\\||\\^|\\?|=|-|_/, null], [PR['PR_TYPE'], /^\\b(?:[@_]?[A-Z]+[a-z][A-Za-z_$@0-9]*|\\w+_t\\b)/, null] //borrowing the type regex given by the main program for C-family languages ]), ['swift']);"},{"title":"","date":"2021-03-03T02:50:12.471Z","updated":"2021-03-03T02:50:12.471Z","comments":true,"path":"plugins/prettify/lang-tcl.js","permalink":"http://sinlapis.github.io/plugins/prettify/lang-tcl.js","excerpt":"","text":"/** * @license * Copyright (C) 2012 Pyrios * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ /** * @fileoverview * Registers a language handler for TCL * * * To use, include prettify.js and this file in your HTML page. * Then put your code in an HTML tag like * proc foo {} {puts bar} * * I copy-pasted lang-lisp.js, so this is probably not 100% accurate. * I used http://wiki.tcl.tk/1019 for the keywords, but tried to only * include as keywords that had more impact on the program flow * rather than providing convenience. For example, I included 'if' * since that provides branching, but left off 'open' since that is more * like a proc. Add more if it makes sense. * * @author pyrios@gmail.com */ PR['registerLangHandler']( PR['createSimpleLexer']( [ ['opn', /^\\{+/, null, '{'], ['clo', /^\\}+/, null, '}'], // A line comment that starts with ; [PR['PR_COMMENT'], /^#[^\\r\\n]*/, null, '#'], // Whitespace [PR['PR_PLAIN'], /^[\\t\\n\\r \\xA0]+/, null, '\\t\\n\\r \\xA0'], // A double quoted, possibly multi-line, string. [PR['PR_STRING'], /^\\\"(?:[^\\\"\\\\]|\\\\[\\s\\S])*(?:\\\"|$)/, null, '\"'] ], [ [PR['PR_KEYWORD'], /^(?:after|append|apply|array|break|case|catch|continue|error|eval|exec|exit|expr|for|foreach|if|incr|info|proc|return|set|switch|trace|uplevel|upvar|while)\\b/, null], [PR['PR_LITERAL'], /^[+\\-]?(?:[0#]x[0-9a-f]+|\\d+\\/\\d+|(?:\\.\\d+|\\d+(?:\\.\\d*)?)(?:[ed][+\\-]?\\d+)?)/i], // A single quote possibly followed by a word that optionally ends with // = ! or ?. [PR['PR_LITERAL'], /^\\'(?:-*(?:\\w|\\\\[\\x21-\\x7e])(?:[\\w-]*|\\\\[\\x21-\\x7e])[=!?]?)?/], // A word that optionally ends with = ! or ?. [PR['PR_PLAIN'], /^-*(?:[a-z_]|\\\\[\\x21-\\x7e])(?:[\\w-]*|\\\\[\\x21-\\x7e])[=!?]?/i], // A printable non-space non-special character [PR['PR_PUNCTUATION'], /^[^\\w\\t\\n\\r \\xA0()\\\"\\\\\\';]+/] ]), ['tcl']);"},{"title":"","date":"2021-03-03T02:50:12.471Z","updated":"2021-03-03T02:50:12.471Z","comments":true,"path":"plugins/prettify/lang-tex.js","permalink":"http://sinlapis.github.io/plugins/prettify/lang-tex.js","excerpt":"","text":"/** * @license * Copyright (C) 2011 Martin S. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ /** * @fileoverview * Support for tex highlighting as discussed on * meta.tex.stackexchange.com. * * @author Martin S. */ PR['registerLangHandler']( PR['createSimpleLexer']( [ // whitespace [PR['PR_PLAIN'], /^[\\t\\n\\r \\xA0]+/, null, '\\t\\n\\r \\xA0'], // all comments begin with '%' [PR['PR_COMMENT'], /^%[^\\r\\n]*/, null, '%'] ], [ //[PR['PR_DECLARATION'], /^\\\\([egx]?def|(new|renew|provide)(command|environment))\\b/], // any command starting with a \\ and contains // either only letters (a-z,A-Z), '@' (internal macros) [PR['PR_KEYWORD'], /^\\\\[a-zA-Z@]+/], // or contains only one character [PR['PR_KEYWORD'], /^\\\\./], // Highlight dollar for math mode and ampersam for tabular [PR['PR_TYPE'], /^[$&]/], // numeric measurement values with attached units [PR['PR_LITERAL'], /[+-]?(?:\\.\\d+|\\d+(?:\\.\\d*)?)(cm|em|ex|in|pc|pt|bp|mm)/i], // punctuation usually occurring within commands [PR['PR_PUNCTUATION'], /^[{}()\\[\\]=]+/] ]), ['latex', 'tex']);"},{"title":"","date":"2021-03-03T02:50:12.471Z","updated":"2021-03-03T02:50:12.471Z","comments":true,"path":"plugins/prettify/lang-vb.js","permalink":"http://sinlapis.github.io/plugins/prettify/lang-vb.js","excerpt":"","text":"/** * @license * Copyright (C) 2009 Google Inc. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ /** * @fileoverview * Registers a language handler for various flavors of basic. * * * To use, include prettify.js and this file in your HTML page. * Then put your code in an HTML tag like * * * * http://msdn.microsoft.com/en-us/library/aa711638(VS.71).aspx defines the * visual basic grammar lexical grammar. * * @author mikesamuel@gmail.com */ PR['registerLangHandler']( PR['createSimpleLexer']( [ // Whitespace [PR['PR_PLAIN'], /^[\\t\\n\\r \\xA0\\u2028\\u2029]+/, null, '\\t\\n\\r \\xA0\\u2028\\u2029'], // A double quoted string with quotes escaped by doubling them. // A single character can be suffixed with C. [PR['PR_STRING'], /^(?:[\\\"\\u201C\\u201D](?:[^\\\"\\u201C\\u201D]|[\\\"\\u201C\\u201D]{2})(?:[\\\"\\u201C\\u201D]c|$)|[\\\"\\u201C\\u201D](?:[^\\\"\\u201C\\u201D]|[\\\"\\u201C\\u201D]{2})*(?:[\\\"\\u201C\\u201D]|$))/i, null, '\"\\u201C\\u201D'], // A comment starts with a single quote and runs until the end of the // line. // VB6 apparently allows _ as an escape sequence for newlines though // this is not a documented feature of VB.net. // http://meta.stackoverflow.com/q/121497/137403 [PR['PR_COMMENT'], /^[\\'\\u2018\\u2019](?:_(?:\\r\\n?|[^\\r]?)|[^\\r\\n_\\u2028\\u2029])*/, null, '\\'\\u2018\\u2019'] ], [ [PR['PR_KEYWORD'], /^(?:AddHandler|AddressOf|Alias|And|AndAlso|Ansi|As|Assembly|Auto|Boolean|ByRef|Byte|ByVal|Call|Case|Catch|CBool|CByte|CChar|CDate|CDbl|CDec|Char|CInt|Class|CLng|CObj|Const|CShort|CSng|CStr|CType|Date|Decimal|Declare|Default|Delegate|Dim|DirectCast|Do|Double|Each|Else|ElseIf|End|EndIf|Enum|Erase|Error|Event|Exit|Finally|For|Friend|Function|Get|GetType|GoSub|GoTo|Handles|If|Implements|Imports|In|Inherits|Integer|Interface|Is|Let|Lib|Like|Long|Loop|Me|Mod|Module|MustInherit|MustOverride|MyBase|MyClass|Namespace|New|Next|Not|NotInheritable|NotOverridable|Object|On|Option|Optional|Or|OrElse|Overloads|Overridable|Overrides|ParamArray|Preserve|Private|Property|Protected|Public|RaiseEvent|ReadOnly|ReDim|RemoveHandler|Resume|Return|Select|Set|Shadows|Shared|Short|Single|Static|Step|Stop|String|Structure|Sub|SyncLock|Then|Throw|To|Try|TypeOf|Unicode|Until|Variant|Wend|When|While|With|WithEvents|WriteOnly|Xor|EndIf|GoSub|Let|Variant|Wend)\\b/i, null], // A second comment form [PR['PR_COMMENT'], /^REM\\b[^\\r\\n\\u2028\\u2029]*/i], // A boolean, numeric, or date literal. [PR['PR_LITERAL'], /^(?:True\\b|False\\b|Nothing\\b|\\d+(?:E[+\\-]?\\d+[FRD]?|[FRDSIL])?|(?:&H[0-9A-F]+|&O[0-7]+)[SIL]?|\\d*\\.\\d+(?:E[+\\-]?\\d+)?[FRD]?|#\\s+(?:\\d+[\\-\\/]\\d+[\\-\\/]\\d+(?:\\s+\\d+:\\d+(?::\\d+)?(\\s*(?:AM|PM))?)?|\\d+:\\d+(?::\\d+)?(\\s*(?:AM|PM))?)\\s+#)/i], // An identifier. Keywords can be turned into identifers // with square brackets, and there may be optional type // characters after a normal identifier in square brackets. [PR['PR_PLAIN'], /^(?:(?:[a-z]|_\\w)\\w*(?:\\[[%&@!#]+\\])?|\\[(?:[a-z]|_\\w)\\w*\\])/i], // A run of punctuation [PR['PR_PUNCTUATION'], /^[^\\w\\t\\n\\r \\\"\\'\\[\\]\\xA0\\u2018\\u2019\\u201C\\u201D\\u2028\\u2029]+/], // Square brackets [PR['PR_PUNCTUATION'], /^(?:\\[|\\])/] ]), ['vb', 'vbs']);"},{"title":"","date":"2021-03-03T02:50:12.471Z","updated":"2021-03-03T02:50:12.471Z","comments":true,"path":"plugins/prettify/lang-vhdl.js","permalink":"http://sinlapis.github.io/plugins/prettify/lang-vhdl.js","excerpt":"","text":"/** * @license * Copyright (C) 2010 benoit@ryder.fr * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ /** * @fileoverview * Registers a language handler for VHDL '93. * * Based on the lexical grammar and keywords at * http://www.iis.ee.ethz.ch/~zimmi/download/vhdl93_syntax.html * * @author benoit@ryder.fr */ PR['registerLangHandler']( PR['createSimpleLexer']( [ // Whitespace [PR['PR_PLAIN'], /^[\\t\\n\\r \\xA0]+/, null, '\\t\\n\\r \\xA0'] ], [ // String, character or bit string [PR['PR_STRING'], /^(?:[BOX]?\"(?:[^\\\"]|\"\")*\"|'.')/i], // Comment, from two dashes until end of line. [PR['PR_COMMENT'], /^--[^\\r\\n]*/], [PR['PR_KEYWORD'], /^(?:abs|access|after|alias|all|and|architecture|array|assert|attribute|begin|block|body|buffer|bus|case|component|configuration|constant|disconnect|downto|else|elsif|end|entity|exit|file|for|function|generate|generic|group|guarded|if|impure|in|inertial|inout|is|label|library|linkage|literal|loop|map|mod|nand|new|next|nor|not|null|of|on|open|or|others|out|package|port|postponed|procedure|process|pure|range|record|register|reject|rem|report|return|rol|ror|select|severity|shared|signal|sla|sll|sra|srl|subtype|then|to|transport|type|unaffected|units|until|use|variable|wait|when|while|with|xnor|xor)(?=[^\\w-]|$)/i, null], // Type, predefined or standard [PR['PR_TYPE'], /^(?:bit|bit_vector|character|boolean|integer|real|time|string|severity_level|positive|natural|signed|unsigned|line|text|std_u?logic(?:_vector)?)(?=[^\\w-]|$)/i, null], // Predefined attributes [PR['PR_TYPE'], /^\\'(?:ACTIVE|ASCENDING|BASE|DELAYED|DRIVING|DRIVING_VALUE|EVENT|HIGH|IMAGE|INSTANCE_NAME|LAST_ACTIVE|LAST_EVENT|LAST_VALUE|LEFT|LEFTOF|LENGTH|LOW|PATH_NAME|POS|PRED|QUIET|RANGE|REVERSE_RANGE|RIGHT|RIGHTOF|SIMPLE_NAME|STABLE|SUCC|TRANSACTION|VAL|VALUE)(?=[^\\w-]|$)/i, null], // Number, decimal or based literal [PR['PR_LITERAL'], /^\\d+(?:_\\d+)*(?:#[\\w\\\\.]+#(?:[+\\-]?\\d+(?:_\\d+)*)?|(?:\\.\\d+(?:_\\d+)*)?(?:E[+\\-]?\\d+(?:_\\d+)*)?)/i], // Identifier, basic or extended [PR['PR_PLAIN'], /^(?:[a-z]\\w*|\\\\[^\\\\]*\\\\)/i], // Punctuation [PR['PR_PUNCTUATION'], /^[^\\w\\t\\n\\r \\xA0\\\"\\'][^\\w\\t\\n\\r \\xA0\\-\\\"\\']*/] ]), ['vhdl', 'vhd']);"},{"title":"","date":"2021-03-03T02:50:12.471Z","updated":"2021-03-03T02:50:12.471Z","comments":true,"path":"plugins/prettify/lang-wiki.js","permalink":"http://sinlapis.github.io/plugins/prettify/lang-wiki.js","excerpt":"","text":"/** * @license * Copyright (C) 2009 Google Inc. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ /** * @fileoverview * Registers a language handler for Wiki pages. * * Based on WikiSyntax at http://code.google.com/p/support/wiki/WikiSyntax * * @author mikesamuel@gmail.com */ PR['registerLangHandler']( PR['createSimpleLexer']( [ // Whitespace [PR['PR_PLAIN'], /^[\\t \\xA0a-gi-z0-9]+/, null, '\\t \\xA0abcdefgijklmnopqrstuvwxyz0123456789'], // Wiki formatting [PR['PR_PUNCTUATION'], /^[=*~\\^\\[\\]]+/, null, '=*~^[]'] ], [ // Meta-info like #summary, #labels, etc. ['lang-wiki.meta', /(?:^^|\\r\\n?|\\n)(#[a-z]+)\\b/], // A WikiWord [PR['PR_LITERAL'], /^(?:[A-Z][a-z][a-z0-9]+[A-Z][a-z][a-zA-Z0-9]+)\\b/ ], // A preformatted block in an unknown language ['lang-', /^\\{\\{\\{([\\s\\S]+?)\\}\\}\\}/], // A block of source code in an unknown language ['lang-', /^`([^\\r\\n`]+)`/], // An inline URL. [PR['PR_STRING'], /^https?:\\/\\/[^\\/?#\\s]*(?:\\/[^?#\\s]*)?(?:\\?[^#\\s]*)?(?:#\\S*)?/i], [PR['PR_PLAIN'], /^(?:\\r\\n|[\\s\\S])[^#=*~^A-Zh\\{`\\[\\r\\n]*/] ]), ['wiki']); PR['registerLangHandler']( PR['createSimpleLexer']([[PR['PR_KEYWORD'], /^#[a-z]+/i, null, '#']], []), ['wiki.meta']);"},{"title":"","date":"2021-03-03T02:50:12.471Z","updated":"2021-03-03T02:50:12.471Z","comments":true,"path":"plugins/prettify/lang-yaml.js","permalink":"http://sinlapis.github.io/plugins/prettify/lang-yaml.js","excerpt":"","text":"/** * @license * Copyright (C) 2015 ribrdb @ code.google.com * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ // Contributed by ribrdb @ code.google.com /** * @fileoverview * Registers a language handler for YAML. * * @author ribrdb */ PR['registerLangHandler']( PR['createSimpleLexer']( [ [PR['PR_PUNCTUATION'], /^[:|>?]+/, null, ':|>?'], [PR['PR_DECLARATION'], /^%(?:YAML|TAG)[^#\\r\\n]+/, null, '%'], [PR['PR_TYPE'], /^[&]\\S+/, null, '&'], [PR['PR_TYPE'], /^!\\S*/, null, '!'], [PR['PR_STRING'], /^\"(?:[^\\\\\"]|\\\\.)*(?:\"|$)/, null, '\"'], [PR['PR_STRING'], /^'(?:[^']|'')*(?:'|$)/, null, \"'\"], [PR['PR_COMMENT'], /^#[^\\r\\n]*/, null, '#'], [PR['PR_PLAIN'], /^\\s+/, null, ' \\t\\r\\n'] ], [ [PR['PR_DECLARATION'], /^(?:---|\\.\\.\\.)(?:[\\r\\n]|$)/], [PR['PR_PUNCTUATION'], /^-/], [PR['PR_KEYWORD'], /^[\\w-]+:[ \\r\\n]/], [PR['PR_PLAIN'], /^\\w+/] ]), ['yaml', 'yml']);"},{"title":"","date":"2021-03-03T02:50:12.471Z","updated":"2021-03-03T02:50:12.471Z","comments":true,"path":"plugins/prettify/prettify.css","permalink":"http://sinlapis.github.io/plugins/prettify/prettify.css","excerpt":"","text":"/** * @license * Copyright (C) 2015 Google Inc. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ /* Pretty printing styles. Used with prettify.js. */ /* SPAN elements with the classes below are added by prettyprint. */ .pln { color: #000 } /* plain text */ @media screen { .str { color: #080 } /* string content */ .kwd { color: #008 } /* a keyword */ .com { color: #800 } /* a comment */ .typ { color: #606 } /* a type name */ .lit { color: #066 } /* a literal value */ /* punctuation, lisp open bracket, lisp close bracket */ .pun, .opn, .clo { color: #660 } .tag { color: #008 } /* a markup tag name */ .atn { color: #606 } /* a markup attribute name */ .atv { color: #080 } /* a markup attribute value */ .dec, .var { color: #606 } /* a declaration; a variable name */ .fun { color: red } /* a function name */ } /* Use higher contrast and text-weight for printable form. */ @media print, projection { .str { color: #060 } .kwd { color: #006; font-weight: bold } .com { color: #600; font-style: italic } .typ { color: #404; font-weight: bold } .lit { color: #044 } .pun, .opn, .clo { color: #440 } .tag { color: #006; font-weight: bold } .atn { color: #404 } .atv { color: #060 } } /* Put a border around prettyprinted code snippets. */ pre.prettyprint { padding: 2px; border: 1px solid #888 } /* Specify class=linenums on a pre to get line numbering */ ol.linenums { margin-top: 0; margin-bottom: 0 } /* IE indents via margin-left */ li.L0, li.L1, li.L2, li.L3, li.L5, li.L6, li.L7, li.L8 { list-style-type: none } /* Alternate shading for lines */ li.L1, li.L3, li.L5, li.L7, li.L9 { background: #eee }"},{"title":"","date":"2021-03-03T02:50:12.471Z","updated":"2021-03-03T02:50:12.471Z","comments":true,"path":"plugins/prettify/lang-matlab.js","permalink":"http://sinlapis.github.io/plugins/prettify/lang-matlab.js","excerpt":"","text":"/** * @license * Copyright (c) 2013 by Amro * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. */ /** * @fileoverview * Registers a language handler for MATLAB. * * To use, include prettify.js and this file in your HTML page. * Then put your code inside an HTML tag like * * * * @see https://github.com/amroamroamro/prettify-matlab */ (function (PR) { /* PR_PLAIN: plain text PR_STRING: string literals PR_KEYWORD: keywords PR_COMMENT: comments PR_TYPE: types PR_LITERAL: literal values (1, null, true, ..) PR_PUNCTUATION: punctuation string PR_SOURCE: embedded source PR_DECLARATION: markup declaration such as a DOCTYPE PR_TAG: sgml tag PR_ATTRIB_NAME: sgml attribute name PR_ATTRIB_VALUE: sgml attribute value */ var PR_IDENTIFIER = \"ident\", PR_CONSTANT = \"const\", PR_FUNCTION = \"fun\", PR_FUNCTION_TOOLBOX = \"fun_tbx\", PR_SYSCMD = \"syscmd\", PR_CODE_OUTPUT = \"codeoutput\", PR_ERROR = \"err\", PR_WARNING = \"wrn\", PR_TRANSPOSE = \"transpose\", PR_LINE_CONTINUATION = \"linecont\"; // Refer to: http://www.mathworks.com/help/matlab/functionlist-alpha.html var coreFunctions = [ 'abs|accumarray|acos(?:d|h)?|acot(?:d|h)?|acsc(?:d|h)?|actxcontrol(?:list|select)?|actxGetRunningServer|actxserver|addlistener|addpath|addpref|addtodate|airy|align|alim|all|allchild|alpha|alphamap|amd|ancestor|and|angle|annotation|any|area|arrayfun|asec(?:d|h)?|asin(?:d|h)?|assert|assignin|atan(?:2|d|h)?|audiodevinfo|audioplayer|audiorecorder|aufinfo|auread|autumn|auwrite|avifile|aviinfo|aviread|axes|axis|balance|bar(?:3|3h|h)?|base2dec|beep|BeginInvoke|bench|bessel(?:h|i|j|k|y)|beta|betainc|betaincinv|betaln|bicg|bicgstab|bicgstabl|bin2dec|bitand|bitcmp|bitget|bitmax|bitnot|bitor|bitset|bitshift|bitxor|blanks|blkdiag|bone|box|brighten|brush|bsxfun|builddocsearchdb|builtin|bvp4c|bvp5c|bvpget|bvpinit|bvpset|bvpxtend|calendar|calllib|callSoapService|camdolly|cameratoolbar|camlight|camlookat|camorbit|campan|campos|camproj|camroll|camtarget|camup|camva|camzoom|cart2pol|cart2sph|cast|cat|caxis|cd|cdf2rdf|cdfepoch|cdfinfo|cdflib(?:\\.(?:close|closeVar|computeEpoch|computeEpoch16|create|createAttr|createVar|delete|deleteAttr|deleteAttrEntry|deleteAttrgEntry|deleteVar|deleteVarRecords|epoch16Breakdown|epochBreakdown|getAttrEntry|getAttrgEntry|getAttrMaxEntry|getAttrMaxgEntry|getAttrName|getAttrNum|getAttrScope|getCacheSize|getChecksum|getCompression|getCompressionCacheSize|getConstantNames|getConstantValue|getCopyright|getFileBackward|getFormat|getLibraryCopyright|getLibraryVersion|getMajority|getName|getNumAttrEntries|getNumAttrgEntries|getNumAttributes|getNumgAttributes|getReadOnlyMode|getStageCacheSize|getValidate|getVarAllocRecords|getVarBlockingFactor|getVarCacheSize|getVarCompression|getVarData|getVarMaxAllocRecNum|getVarMaxWrittenRecNum|getVarName|getVarNum|getVarNumRecsWritten|getVarPadValue|getVarRecordData|getVarReservePercent|getVarsMaxWrittenRecNum|getVarSparseRecords|getVersion|hyperGetVarData|hyperPutVarData|inquire|inquireAttr|inquireAttrEntry|inquireAttrgEntry|inquireVar|open|putAttrEntry|putAttrgEntry|putVarData|putVarRecordData|renameAttr|renameVar|setCacheSize|setChecksum|setCompression|setCompressionCacheSize|setFileBackward|setFormat|setMajority|setReadOnlyMode|setStageCacheSize|setValidate|setVarAllocBlockRecords|setVarBlockingFactor|setVarCacheSize|setVarCompression|setVarInitialRecs|setVarPadValue|SetVarReservePercent|setVarsCacheSize|setVarSparseRecords))?|cdfread|cdfwrite|ceil|cell2mat|cell2struct|celldisp|cellfun|cellplot|cellstr|cgs|checkcode|checkin|checkout|chol|cholinc|cholupdate|circshift|cla|clabel|class|clc|clear|clearvars|clf|clipboard|clock|close|closereq|cmopts|cmpermute|cmunique|colamd|colon|colorbar|colordef|colormap|colormapeditor|colperm|Combine|comet|comet3|commandhistory|commandwindow|compan|compass|complex|computer|cond|condeig|condest|coneplot|conj|containers\\.Map|contour(?:3|c|f|slice)?|contrast|conv|conv2|convhull|convhulln|convn|cool|copper|copyfile|copyobj|corrcoef|cos(?:d|h)?|cot(?:d|h)?|cov|cplxpair|cputime|createClassFromWsdl|createSoapMessage|cross|csc(?:d|h)?|csvread|csvwrite|ctranspose|cumprod|cumsum|cumtrapz|curl|customverctrl|cylinder|daqread|daspect|datacursormode|datatipinfo|date|datenum|datestr|datetick|datevec|dbclear|dbcont|dbdown|dblquad|dbmex|dbquit|dbstack|dbstatus|dbstep|dbstop|dbtype|dbup|dde23|ddeget|ddesd|ddeset|deal|deblank|dec2base|dec2bin|dec2hex|decic|deconv|del2|delaunay|delaunay3|delaunayn|DelaunayTri|delete|demo|depdir|depfun|det|detrend|deval|diag|dialog|diary|diff|diffuse|dir|disp|display|dither|divergence|dlmread|dlmwrite|dmperm|doc|docsearch|dos|dot|dragrect|drawnow|dsearch|dsearchn|dynamicprops|echo|echodemo|edit|eig|eigs|ellipj|ellipke|ellipsoid|empty|enableNETfromNetworkDrive|enableservice|EndInvoke|enumeration|eomday|eq|erf|erfc|erfcinv|erfcx|erfinv|error|errorbar|errordlg|etime|etree|etreeplot|eval|evalc|evalin|event\\.(?:EventData|listener|PropertyEvent|proplistener)|exifread|exist|exit|exp|expint|expm|expm1|export2wsdlg|eye|ezcontour|ezcontourf|ezmesh|ezmeshc|ezplot|ezplot3|ezpolar|ezsurf|ezsurfc|factor|factorial|fclose|feather|feature|feof|ferror|feval|fft|fft2|fftn|fftshift|fftw|fgetl|fgets|fieldnames|figure|figurepalette|fileattrib|filebrowser|filemarker|fileparts|fileread|filesep|fill|fill3|filter|filter2|find|findall|findfigs|findobj|findstr|finish|fitsdisp|fitsinfo|fitsread|fitswrite|fix|flag|flipdim|fliplr|flipud|floor|flow|fminbnd|fminsearch|fopen|format|fplot|fprintf|frame2im|fread|freqspace|frewind|fscanf|fseek|ftell|FTP|full|fullfile|func2str|functions|funm|fwrite|fzero|gallery|gamma|gammainc|gammaincinv|gammaln|gca|gcbf|gcbo|gcd|gcf|gco|ge|genpath|genvarname|get|getappdata|getenv|getfield|getframe|getpixelposition|getpref|ginput|gmres|gplot|grabcode|gradient|gray|graymon|grid|griddata(?:3|n)?|griddedInterpolant|gsvd|gt|gtext|guidata|guide|guihandles|gunzip|gzip|h5create|h5disp|h5info|h5read|h5readatt|h5write|h5writeatt|hadamard|handle|hankel|hdf|hdf5|hdf5info|hdf5read|hdf5write|hdfinfo|hdfread|hdftool|help|helpbrowser|helpdesk|helpdlg|helpwin|hess|hex2dec|hex2num|hgexport|hggroup|hgload|hgsave|hgsetget|hgtransform|hidden|hilb|hist|histc|hold|home|horzcat|hostid|hot|hsv|hsv2rgb|hypot|ichol|idivide|ifft|ifft2|ifftn|ifftshift|ilu|im2frame|im2java|imag|image|imagesc|imapprox|imfinfo|imformats|import|importdata|imread|imwrite|ind2rgb|ind2sub|inferiorto|info|inline|inmem|inpolygon|input|inputdlg|inputname|inputParser|inspect|instrcallback|instrfind|instrfindall|int2str|integral(?:2|3)?|interp(?:1|1q|2|3|ft|n)|interpstreamspeed|intersect|intmax|intmin|inv|invhilb|ipermute|isa|isappdata|iscell|iscellstr|ischar|iscolumn|isdir|isempty|isequal|isequaln|isequalwithequalnans|isfield|isfinite|isfloat|isglobal|ishandle|ishghandle|ishold|isinf|isinteger|isjava|iskeyword|isletter|islogical|ismac|ismatrix|ismember|ismethod|isnan|isnumeric|isobject|isocaps|isocolors|isonormals|isosurface|ispc|ispref|isprime|isprop|isreal|isrow|isscalar|issorted|isspace|issparse|isstr|isstrprop|isstruct|isstudent|isunix|isvarname|isvector|javaaddpath|javaArray|javachk|javaclasspath|javacomponent|javaMethod|javaMethodEDT|javaObject|javaObjectEDT|javarmpath|jet|keyboard|kron|lasterr|lasterror|lastwarn|lcm|ldivide|ldl|le|legend|legendre|length|libfunctions|libfunctionsview|libisloaded|libpointer|libstruct|license|light|lightangle|lighting|lin2mu|line|lines|linkaxes|linkdata|linkprop|linsolve|linspace|listdlg|listfonts|load|loadlibrary|loadobj|log|log10|log1p|log2|loglog|logm|logspace|lookfor|lower|ls|lscov|lsqnonneg|lsqr|lt|lu|luinc|magic|makehgtform|mat2cell|mat2str|material|matfile|matlab\\.io\\.MatFile|matlab\\.mixin\\.(?:Copyable|Heterogeneous(?:\\.getDefaultScalarElement)?)|matlabrc|matlabroot|max|maxNumCompThreads|mean|median|membrane|memmapfile|memory|menu|mesh|meshc|meshgrid|meshz|meta\\.(?:class(?:\\.fromName)?|DynamicProperty|EnumeratedValue|event|MetaData|method|package(?:\\.(?:fromName|getAllPackages))?|property)|metaclass|methods|methodsview|mex(?:\\.getCompilerConfigurations)?|MException|mexext|mfilename|min|minres|minus|mislocked|mkdir|mkpp|mldivide|mlint|mlintrpt|mlock|mmfileinfo|mmreader|mod|mode|more|move|movefile|movegui|movie|movie2avi|mpower|mrdivide|msgbox|mtimes|mu2lin|multibandread|multibandwrite|munlock|namelengthmax|nargchk|narginchk|nargoutchk|native2unicode|nccreate|ncdisp|nchoosek|ncinfo|ncread|ncreadatt|ncwrite|ncwriteatt|ncwriteschema|ndgrid|ndims|ne|NET(?:\\.(?:addAssembly|Assembly|convertArray|createArray|createGeneric|disableAutoRelease|enableAutoRelease|GenericClass|invokeGenericMethod|NetException|setStaticProperty))?|netcdf\\.(?:abort|close|copyAtt|create|defDim|defGrp|defVar|defVarChunking|defVarDeflate|defVarFill|defVarFletcher32|delAtt|endDef|getAtt|getChunkCache|getConstant|getConstantNames|getVar|inq|inqAtt|inqAttID|inqAttName|inqDim|inqDimID|inqDimIDs|inqFormat|inqGrpName|inqGrpNameFull|inqGrpParent|inqGrps|inqLibVers|inqNcid|inqUnlimDims|inqVar|inqVarChunking|inqVarDeflate|inqVarFill|inqVarFletcher32|inqVarID|inqVarIDs|open|putAtt|putVar|reDef|renameAtt|renameDim|renameVar|setChunkCache|setDefaultFormat|setFill|sync)|newplot|nextpow2|nnz|noanimate|nonzeros|norm|normest|not|notebook|now|nthroot|null|num2cell|num2hex|num2str|numel|nzmax|ode(?:113|15i|15s|23|23s|23t|23tb|45)|odeget|odeset|odextend|onCleanup|ones|open|openfig|opengl|openvar|optimget|optimset|or|ordeig|orderfields|ordqz|ordschur|orient|orth|pack|padecoef|pagesetupdlg|pan|pareto|parseSoapResponse|pascal|patch|path|path2rc|pathsep|pathtool|pause|pbaspect|pcg|pchip|pcode|pcolor|pdepe|pdeval|peaks|perl|perms|permute|pie|pink|pinv|planerot|playshow|plot|plot3|plotbrowser|plotedit|plotmatrix|plottools|plotyy|plus|pol2cart|polar|poly|polyarea|polyder|polyeig|polyfit|polyint|polyval|polyvalm|pow2|power|ppval|prefdir|preferences|primes|print|printdlg|printopt|printpreview|prod|profile|profsave|propedit|propertyeditor|psi|publish|PutCharArray|PutFullMatrix|PutWorkspaceData|pwd|qhull|qmr|qr|qrdelete|qrinsert|qrupdate|quad|quad2d|quadgk|quadl|quadv|questdlg|quit|quiver|quiver3|qz|rand|randi|randn|randperm|RandStream(?:\\.(?:create|getDefaultStream|getGlobalStream|list|setDefaultStream|setGlobalStream))?|rank|rat|rats|rbbox|rcond|rdivide|readasync|real|reallog|realmax|realmin|realpow|realsqrt|record|rectangle|rectint|recycle|reducepatch|reducevolume|refresh|refreshdata|regexp|regexpi|regexprep|regexptranslate|rehash|rem|Remove|RemoveAll|repmat|reset|reshape|residue|restoredefaultpath|rethrow|rgb2hsv|rgb2ind|rgbplot|ribbon|rmappdata|rmdir|rmfield|rmpath|rmpref|rng|roots|rose|rosser|rot90|rotate|rotate3d|round|rref|rsf2csf|run|save|saveas|saveobj|savepath|scatter|scatter3|schur|sec|secd|sech|selectmoveresize|semilogx|semilogy|sendmail|serial|set|setappdata|setdiff|setenv|setfield|setpixelposition|setpref|setstr|setxor|shading|shg|shiftdim|showplottool|shrinkfaces|sign|sin(?:d|h)?|size|slice|smooth3|snapnow|sort|sortrows|sound|soundsc|spalloc|spaugment|spconvert|spdiags|specular|speye|spfun|sph2cart|sphere|spinmap|spline|spones|spparms|sprand|sprandn|sprandsym|sprank|spring|sprintf|spy|sqrt|sqrtm|squeeze|ss2tf|sscanf|stairs|startup|std|stem|stem3|stopasync|str2double|str2func|str2mat|str2num|strcat|strcmp|strcmpi|stream2|stream3|streamline|streamparticles|streamribbon|streamslice|streamtube|strfind|strjust|strmatch|strncmp|strncmpi|strread|strrep|strtok|strtrim|struct2cell|structfun|strvcat|sub2ind|subplot|subsasgn|subsindex|subspace|subsref|substruct|subvolume|sum|summer|superclasses|superiorto|support|surf|surf2patch|surface|surfc|surfl|surfnorm|svd|svds|swapbytes|symamd|symbfact|symmlq|symrcm|symvar|system|tan(?:d|h)?|tar|tempdir|tempname|tetramesh|texlabel|text|textread|textscan|textwrap|tfqmr|throw|tic|Tiff(?:\\.(?:getTagNames|getVersion))?|timer|timerfind|timerfindall|times|timeseries|title|toc|todatenum|toeplitz|toolboxdir|trace|transpose|trapz|treelayout|treeplot|tril|trimesh|triplequad|triplot|TriRep|TriScatteredInterp|trisurf|triu|tscollection|tsearch|tsearchn|tstool|type|typecast|uibuttongroup|uicontextmenu|uicontrol|uigetdir|uigetfile|uigetpref|uiimport|uimenu|uiopen|uipanel|uipushtool|uiputfile|uiresume|uisave|uisetcolor|uisetfont|uisetpref|uistack|uitable|uitoggletool|uitoolbar|uiwait|uminus|undocheckout|unicode2native|union|unique|unix|unloadlibrary|unmesh|unmkpp|untar|unwrap|unzip|uplus|upper|urlread|urlwrite|usejava|userpath|validateattributes|validatestring|vander|var|vectorize|ver|verctrl|verLessThan|version|vertcat|VideoReader(?:\\.isPlatformSupported)?|VideoWriter(?:\\.getProfiles)?|view|viewmtx|visdiff|volumebounds|voronoi|voronoin|wait|waitbar|waitfor|waitforbuttonpress|warndlg|warning|waterfall|wavfinfo|wavplay|wavread|wavrecord|wavwrite|web|weekday|what|whatsnew|which|whitebg|who|whos|wilkinson|winopen|winqueryreg|winter|wk1finfo|wk1read|wk1write|workspace|xlabel|xlim|xlsfinfo|xlsread|xlswrite|xmlread|xmlwrite|xor|xslt|ylabel|ylim|zeros|zip|zlabel|zlim|zoom' ].join(\"|\"); var statsFunctions = [ 'addedvarplot|andrewsplot|anova(?:1|2|n)|ansaribradley|aoctool|barttest|bbdesign|beta(?:cdf|fit|inv|like|pdf|rnd|stat)|bino(?:cdf|fit|inv|pdf|rnd|stat)|biplot|bootci|bootstrp|boxplot|candexch|candgen|canoncorr|capability|capaplot|caseread|casewrite|categorical|ccdesign|cdfplot|chi2(?:cdf|gof|inv|pdf|rnd|stat)|cholcov|Classification(?:BaggedEnsemble|Discriminant(?:\\.(?:fit|make|template))?|Ensemble|KNN(?:\\.(?:fit|template))?|PartitionedEnsemble|PartitionedModel|Tree(?:\\.(?:fit|template))?)|classify|classregtree|cluster|clusterdata|cmdscale|combnk|Compact(?:Classification(?:Discriminant|Ensemble|Tree)|Regression(?:Ensemble|Tree)|TreeBagger)|confusionmat|controlchart|controlrules|cophenet|copula(?:cdf|fit|param|pdf|rnd|stat)|cordexch|corr|corrcov|coxphfit|createns|crosstab|crossval|cvpartition|datasample|dataset|daugment|dcovary|dendrogram|dfittool|disttool|dummyvar|dwtest|ecdf|ecdfhist|ev(?:cdf|fit|inv|like|pdf|rnd|stat)|ExhaustiveSearcher|exp(?:cdf|fit|inv|like|pdf|rnd|stat)|factoran|fcdf|ff2n|finv|fitdist|fitensemble|fpdf|fracfact|fracfactgen|friedman|frnd|fstat|fsurfht|fullfact|gagerr|gam(?:cdf|fit|inv|like|pdf|rnd|stat)|GeneralizedLinearModel(?:\\.fit)?|geo(?:cdf|inv|mean|pdf|rnd|stat)|gev(?:cdf|fit|inv|like|pdf|rnd|stat)|gline|glmfit|glmval|glyphplot|gmdistribution(?:\\.fit)?|gname|gp(?:cdf|fit|inv|like|pdf|rnd|stat)|gplotmatrix|grp2idx|grpstats|gscatter|haltonset|harmmean|hist3|histfit|hmm(?:decode|estimate|generate|train|viterbi)|hougen|hyge(?:cdf|inv|pdf|rnd|stat)|icdf|inconsistent|interactionplot|invpred|iqr|iwishrnd|jackknife|jbtest|johnsrnd|KDTreeSearcher|kmeans|knnsearch|kruskalwallis|ksdensity|kstest|kstest2|kurtosis|lasso|lassoglm|lassoPlot|leverage|lhsdesign|lhsnorm|lillietest|LinearModel(?:\\.fit)?|linhyptest|linkage|logn(?:cdf|fit|inv|like|pdf|rnd|stat)|lsline|mad|mahal|maineffectsplot|manova1|manovacluster|mdscale|mhsample|mle|mlecov|mnpdf|mnrfit|mnrnd|mnrval|moment|multcompare|multivarichart|mvn(?:cdf|pdf|rnd)|mvregress|mvregresslike|mvt(?:cdf|pdf|rnd)|NaiveBayes(?:\\.fit)?|nan(?:cov|max|mean|median|min|std|sum|var)|nbin(?:cdf|fit|inv|pdf|rnd|stat)|ncf(?:cdf|inv|pdf|rnd|stat)|nct(?:cdf|inv|pdf|rnd|stat)|ncx2(?:cdf|inv|pdf|rnd|stat)|NeighborSearcher|nlinfit|nlintool|nlmefit|nlmefitsa|nlparci|nlpredci|nnmf|nominal|NonLinearModel(?:\\.fit)?|norm(?:cdf|fit|inv|like|pdf|rnd|stat)|normplot|normspec|ordinal|outlierMeasure|parallelcoords|paretotails|partialcorr|pcacov|pcares|pdf|pdist|pdist2|pearsrnd|perfcurve|perms|piecewisedistribution|plsregress|poiss(?:cdf|fit|inv|pdf|rnd|tat)|polyconf|polytool|prctile|princomp|ProbDist(?:Kernel|Parametric|UnivKernel|UnivParam)?|probplot|procrustes|qqplot|qrandset|qrandstream|quantile|randg|random|randsample|randtool|range|rangesearch|ranksum|rayl(?:cdf|fit|inv|pdf|rnd|stat)|rcoplot|refcurve|refline|regress|Regression(?:BaggedEnsemble|Ensemble|PartitionedEnsemble|PartitionedModel|Tree(?:\\.(?:fit|template))?)|regstats|relieff|ridge|robustdemo|robustfit|rotatefactors|rowexch|rsmdemo|rstool|runstest|sampsizepwr|scatterhist|sequentialfs|signrank|signtest|silhouette|skewness|slicesample|sobolset|squareform|statget|statset|stepwise|stepwisefit|surfht|tabulate|tblread|tblwrite|tcdf|tdfread|tiedrank|tinv|tpdf|TreeBagger|treedisp|treefit|treeprune|treetest|treeval|trimmean|trnd|tstat|ttest|ttest2|unid(?:cdf|inv|pdf|rnd|stat)|unif(?:cdf|inv|it|pdf|rnd|stat)|vartest(?:2|n)?|wbl(?:cdf|fit|inv|like|pdf|rnd|stat)|wblplot|wishrnd|x2fx|xptread|zscore|ztest' ].join(\"|\"); var imageFunctions = [ 'adapthisteq|analyze75info|analyze75read|applycform|applylut|axes2pix|bestblk|blockproc|bwarea|bwareaopen|bwboundaries|bwconncomp|bwconvhull|bwdist|bwdistgeodesic|bweuler|bwhitmiss|bwlabel|bwlabeln|bwmorph|bwpack|bwperim|bwselect|bwtraceboundary|bwulterode|bwunpack|checkerboard|col2im|colfilt|conndef|convmtx2|corner|cornermetric|corr2|cp2tform|cpcorr|cpselect|cpstruct2pairs|dct2|dctmtx|deconvblind|deconvlucy|deconvreg|deconvwnr|decorrstretch|demosaic|dicom(?:anon|dict|info|lookup|read|uid|write)|edge|edgetaper|entropy|entropyfilt|fan2para|fanbeam|findbounds|fliptform|freqz2|fsamp2|fspecial|ftrans2|fwind1|fwind2|getheight|getimage|getimagemodel|getline|getneighbors|getnhood|getpts|getrangefromclass|getrect|getsequence|gray2ind|graycomatrix|graycoprops|graydist|grayslice|graythresh|hdrread|hdrwrite|histeq|hough|houghlines|houghpeaks|iccfind|iccread|iccroot|iccwrite|idct2|ifanbeam|im2bw|im2col|im2double|im2int16|im2java2d|im2single|im2uint16|im2uint8|imabsdiff|imadd|imadjust|ImageAdapter|imageinfo|imagemodel|imapplymatrix|imattributes|imbothat|imclearborder|imclose|imcolormaptool|imcomplement|imcontour|imcontrast|imcrop|imdilate|imdisplayrange|imdistline|imdivide|imellipse|imerode|imextendedmax|imextendedmin|imfill|imfilter|imfindcircles|imfreehand|imfuse|imgca|imgcf|imgetfile|imhandles|imhist|imhmax|imhmin|imimposemin|imlincomb|imline|immagbox|immovie|immultiply|imnoise|imopen|imoverview|imoverviewpanel|impixel|impixelinfo|impixelinfoval|impixelregion|impixelregionpanel|implay|impoint|impoly|impositionrect|improfile|imputfile|impyramid|imreconstruct|imrect|imregconfig|imregionalmax|imregionalmin|imregister|imresize|imroi|imrotate|imsave|imscrollpanel|imshow|imshowpair|imsubtract|imtool|imtophat|imtransform|imview|ind2gray|ind2rgb|interfileinfo|interfileread|intlut|ippl|iptaddcallback|iptcheckconn|iptcheckhandle|iptcheckinput|iptcheckmap|iptchecknargin|iptcheckstrs|iptdemos|iptgetapi|iptGetPointerBehavior|iptgetpref|ipticondir|iptnum2ordinal|iptPointerManager|iptprefs|iptremovecallback|iptSetPointerBehavior|iptsetpref|iptwindowalign|iradon|isbw|isflat|isgray|isicc|isind|isnitf|isrgb|isrset|lab2double|lab2uint16|lab2uint8|label2rgb|labelmatrix|makecform|makeConstrainToRectFcn|makehdr|makelut|makeresampler|maketform|mat2gray|mean2|medfilt2|montage|nitfinfo|nitfread|nlfilter|normxcorr2|ntsc2rgb|openrset|ordfilt2|otf2psf|padarray|para2fan|phantom|poly2mask|psf2otf|qtdecomp|qtgetblk|qtsetblk|radon|rangefilt|reflect|regionprops|registration\\.metric\\.(?:MattesMutualInformation|MeanSquares)|registration\\.optimizer\\.(?:OnePlusOneEvolutionary|RegularStepGradientDescent)|rgb2gray|rgb2ntsc|rgb2ycbcr|roicolor|roifill|roifilt2|roipoly|rsetwrite|std2|stdfilt|strel|stretchlim|subimage|tformarray|tformfwd|tforminv|tonemap|translate|truesize|uintlut|viscircles|warp|watershed|whitepoint|wiener2|xyz2double|xyz2uint16|ycbcr2rgb' ].join(\"|\"); var optimFunctions = [ 'bintprog|color|fgoalattain|fminbnd|fmincon|fminimax|fminsearch|fminunc|fseminf|fsolve|fzero|fzmult|gangstr|ktrlink|linprog|lsqcurvefit|lsqlin|lsqnonlin|lsqnonneg|optimget|optimset|optimtool|quadprog' ].join(\"|\"); // identifiers: variable/function name, or a chain of variable names joined by dots (obj.method, struct.field1.field2, etc..) // valid variable names (start with letter, and contains letters, digits, and underscores). // we match \"xx.yy\" as a whole so that if \"xx\" is plain and \"yy\" is not, we dont get a false positive for \"yy\" //var reIdent = '(?:[a-zA-Z][a-zA-Z0-9_]*)'; //var reIdentChain = '(?:' + reIdent + '(?:\\.' + reIdent + ')*' + ')'; // patterns that always start with a known character. Must have a shortcut string. var shortcutStylePatterns = [ // whitespaces: space, tab, carriage return, line feed, line tab, form-feed, non-break space [PR.PR_PLAIN, /^[ \\t\\r\\n\\v\\f\\xA0]+/, null, \" \\t\\r\\n\\u000b\\u000c\\u00a0\"], // block comments //TODO: chokes on nested block comments //TODO: false positives when the lines with %{ and %} contain non-spaces //[PR.PR_COMMENT, /^%(?:[^\\{].*|\\{(?:%|%*[^\\}%])*(?:\\}+%?)?)/, null], [PR.PR_COMMENT, /^%\\{[^%]*%+(?:[^\\}%][^%]*%+)*\\}/, null], // single-line comments [PR.PR_COMMENT, /^%[^\\r\\n]*/, null, \"%\"], // system commands [PR_SYSCMD, /^![^\\r\\n]*/, null, \"!\"] ]; // patterns that will be tried in order if the shortcut ones fail. May have shortcuts. var fallthroughStylePatterns = [ // line continuation [PR_LINE_CONTINUATION, /^\\.\\.\\.\\s*[\\r\\n]/, null], // error message [PR_ERROR, /^\\?\\?\\? [^\\r\\n]*/, null], // warning message [PR_WARNING, /^Warning: [^\\r\\n]*/, null], // command prompt/output //[PR_CODE_OUTPUT, /^>>\\s+[^\\r\\n]*[\\r\\n]{1,2}[^=]*=[^\\r\\n]*[\\r\\n]{1,2}[^\\r\\n]*/, null], // full command output (both loose/compact format): `>> EXP\\nVAR =\\n VAL` [PR_CODE_OUTPUT, /^>>\\s+/, null], // only the command prompt `>> ` [PR_CODE_OUTPUT, /^octave:\\d+>\\s+/, null], // Octave command prompt `octave:1> ` // identifier (chain) or closing-parenthesis/brace/bracket, and IS followed by transpose operator // this way we dont misdetect the transpose operator ' as the start of a string [\"lang-matlab-operators\", /^((?:[a-zA-Z][a-zA-Z0-9_]*(?:\\.[a-zA-Z][a-zA-Z0-9_]*)*|\\)|\\]|\\}|\\.)')/, null], // identifier (chain), and NOT followed by transpose operator // this must come AFTER the \"is followed by transpose\" step (otherwise it chops the last char of identifier) [\"lang-matlab-identifiers\", /^([a-zA-Z][a-zA-Z0-9_]*(?:\\.[a-zA-Z][a-zA-Z0-9_]*)*)(?!')/, null], // single-quoted strings: allow for escaping with '', no multilines //[PR.PR_STRING, /(?:(?"},{"title":"","date":"2021-03-03T02:50:12.471Z","updated":"2021-03-03T02:50:12.471Z","comments":true,"path":"plugins/prettify/lang-xq.js","permalink":"http://sinlapis.github.io/plugins/prettify/lang-xq.js","excerpt":"","text":"/** * @license * Copyright (C) 2011 Patrick Wied * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ /** * @fileoverview * Registers a language handler for XQuery. * * To use, include prettify.js and this file in your HTML page. * Then put your code in an HTML tag like * * * * @author Patrick Wied ( patpa7p@live.de ) * @version 2010-09-28 */ (function () { // Falls back to plain for stylesheets that don't style fun. var PR_FUNCTION = 'fun pln'; // Falls back to plaiin for stylesheets that don't style var. var PR_VARIABLE = 'var pln'; PR['registerLangHandler']( PR['createSimpleLexer']( [ // Matching $var-ia_bles [PR_VARIABLE, /^\\$[A-Za-z0-9_\\-]+/, null, \"$\"] ], [ // Matching lt and gt operators // Not the best matching solution but you have to differentiate between the gt operator and the tag closing char [PR['PR_PLAIN'], /^[\\s=][][\\s=]/], // Matching @Attributes [PR['PR_LITERAL'], /^\\@[\\w-]+/], // Matching xml tags [PR['PR_TAG'], /^$/i], // Matching single or multiline xquery comments -> (: :) [PR['PR_COMMENT'], /^\\(:[\\s\\S]*?:\\)/], // Tokenizing /{}:=;*,[]() as plain [PR['PR_PLAIN'], /^[\\/\\{\\};,\\[\\]\\(\\)]$/], // Matching a double or single quoted, possibly multi-line, string. // with the special condition that a { in a string changes to xquery context [PR['PR_STRING'], /^(?:\\\"(?:[^\\\"\\\\\\{]|\\\\[\\s\\S])*(?:\\\"|$)|\\'(?:[^\\'\\\\\\{]|\\\\[\\s\\S])*(?:\\'|$))/, null, '\"\\''], // Matching standard xquery keywords [PR['PR_KEYWORD'], /^(?:xquery|where|version|variable|union|typeswitch|treat|to|then|text|stable|sortby|some|self|schema|satisfies|returns|return|ref|processing-instruction|preceding-sibling|preceding|precedes|parent|only|of|node|namespace|module|let|item|intersect|instance|in|import|if|function|for|follows|following-sibling|following|external|except|every|else|element|descending|descendant-or-self|descendant|define|default|declare|comment|child|cast|case|before|attribute|assert|ascending|as|ancestor-or-self|ancestor|after|eq|order|by|or|and|schema-element|document-node|node|at)\\b/], // Matching standard xquery types [PR['PR_TYPE'], /^(?:xs:yearMonthDuration|xs:unsignedLong|xs:time|xs:string|xs:short|xs:QName|xs:Name|xs:long|xs:integer|xs:int|xs:gYearMonth|xs:gYear|xs:gMonthDay|xs:gDay|xs:float|xs:duration|xs:double|xs:decimal|xs:dayTimeDuration|xs:dateTime|xs:date|xs:byte|xs:boolean|xs:anyURI|xf:yearMonthDuration)\\b/, null], // Matching standard xquery functions [PR_FUNCTION, /^(?:xp:dereference|xinc:node-expand|xinc:link-references|xinc:link-expand|xhtml:restructure|xhtml:clean|xhtml:add-lists|xdmp:zip-manifest|xdmp:zip-get|xdmp:zip-create|xdmp:xquery-version|xdmp:word-convert|xdmp:with-namespaces|xdmp:version|xdmp:value|xdmp:user-roles|xdmp:user-last-login|xdmp:user|xdmp:url-encode|xdmp:url-decode|xdmp:uri-is-file|xdmp:uri-format|xdmp:uri-content-type|xdmp:unquote|xdmp:unpath|xdmp:triggers-database|xdmp:trace|xdmp:to-json|xdmp:tidy|xdmp:subbinary|xdmp:strftime|xdmp:spawn-in|xdmp:spawn|xdmp:sleep|xdmp:shutdown|xdmp:set-session-field|xdmp:set-response-encoding|xdmp:set-response-content-type|xdmp:set-response-code|xdmp:set-request-time-limit|xdmp:set|xdmp:servers|xdmp:server-status|xdmp:server-name|xdmp:server|xdmp:security-database|xdmp:security-assert|xdmp:schema-database|xdmp:save|xdmp:role-roles|xdmp:role|xdmp:rethrow|xdmp:restart|xdmp:request-timestamp|xdmp:request-status|xdmp:request-cancel|xdmp:request|xdmp:redirect-response|xdmp:random|xdmp:quote|xdmp:query-trace|xdmp:query-meters|xdmp:product-edition|xdmp:privilege-roles|xdmp:privilege|xdmp:pretty-print|xdmp:powerpoint-convert|xdmp:platform|xdmp:permission|xdmp:pdf-convert|xdmp:path|xdmp:octal-to-integer|xdmp:node-uri|xdmp:node-replace|xdmp:node-kind|xdmp:node-insert-child|xdmp:node-insert-before|xdmp:node-insert-after|xdmp:node-delete|xdmp:node-database|xdmp:mul64|xdmp:modules-root|xdmp:modules-database|xdmp:merging|xdmp:merge-cancel|xdmp:merge|xdmp:md5|xdmp:logout|xdmp:login|xdmp:log-level|xdmp:log|xdmp:lock-release|xdmp:lock-acquire|xdmp:load|xdmp:invoke-in|xdmp:invoke|xdmp:integer-to-octal|xdmp:integer-to-hex|xdmp:http-put|xdmp:http-post|xdmp:http-options|xdmp:http-head|xdmp:http-get|xdmp:http-delete|xdmp:hosts|xdmp:host-status|xdmp:host-name|xdmp:host|xdmp:hex-to-integer|xdmp:hash64|xdmp:hash32|xdmp:has-privilege|xdmp:groups|xdmp:group-serves|xdmp:group-servers|xdmp:group-name|xdmp:group-hosts|xdmp:group|xdmp:get-session-field-names|xdmp:get-session-field|xdmp:get-response-encoding|xdmp:get-response-code|xdmp:get-request-username|xdmp:get-request-user|xdmp:get-request-url|xdmp:get-request-protocol|xdmp:get-request-path|xdmp:get-request-method|xdmp:get-request-header-names|xdmp:get-request-header|xdmp:get-request-field-names|xdmp:get-request-field-filename|xdmp:get-request-field-content-type|xdmp:get-request-field|xdmp:get-request-client-certificate|xdmp:get-request-client-address|xdmp:get-request-body|xdmp:get-current-user|xdmp:get-current-roles|xdmp:get|xdmp:function-name|xdmp:function-module|xdmp:function|xdmp:from-json|xdmp:forests|xdmp:forest-status|xdmp:forest-restore|xdmp:forest-restart|xdmp:forest-name|xdmp:forest-delete|xdmp:forest-databases|xdmp:forest-counts|xdmp:forest-clear|xdmp:forest-backup|xdmp:forest|xdmp:filesystem-file|xdmp:filesystem-directory|xdmp:exists|xdmp:excel-convert|xdmp:eval-in|xdmp:eval|xdmp:estimate|xdmp:email|xdmp:element-content-type|xdmp:elapsed-time|xdmp:document-set-quality|xdmp:document-set-property|xdmp:document-set-properties|xdmp:document-set-permissions|xdmp:document-set-collections|xdmp:document-remove-properties|xdmp:document-remove-permissions|xdmp:document-remove-collections|xdmp:document-properties|xdmp:document-locks|xdmp:document-load|xdmp:document-insert|xdmp:document-get-quality|xdmp:document-get-properties|xdmp:document-get-permissions|xdmp:document-get-collections|xdmp:document-get|xdmp:document-forest|xdmp:document-delete|xdmp:document-add-properties|xdmp:document-add-permissions|xdmp:document-add-collections|xdmp:directory-properties|xdmp:directory-locks|xdmp:directory-delete|xdmp:directory-create|xdmp:directory|xdmp:diacritic-less|xdmp:describe|xdmp:default-permissions|xdmp:default-collections|xdmp:databases|xdmp:database-restore-validate|xdmp:database-restore-status|xdmp:database-restore-cancel|xdmp:database-restore|xdmp:database-name|xdmp:database-forests|xdmp:database-backup-validate|xdmp:database-backup-status|xdmp:database-backup-purge|xdmp:database-backup-cancel|xdmp:database-backup|xdmp:database|xdmp:collection-properties|xdmp:collection-locks|xdmp:collection-delete|xdmp:collation-canonical-uri|xdmp:castable-as|xdmp:can-grant-roles|xdmp:base64-encode|xdmp:base64-decode|xdmp:architecture|xdmp:apply|xdmp:amp-roles|xdmp:amp|xdmp:add64|xdmp:add-response-header|xdmp:access|trgr:trigger-set-recursive|trgr:trigger-set-permissions|trgr:trigger-set-name|trgr:trigger-set-module|trgr:trigger-set-event|trgr:trigger-set-description|trgr:trigger-remove-permissions|trgr:trigger-module|trgr:trigger-get-permissions|trgr:trigger-enable|trgr:trigger-disable|trgr:trigger-database-online-event|trgr:trigger-data-event|trgr:trigger-add-permissions|trgr:remove-trigger|trgr:property-content|trgr:pre-commit|trgr:post-commit|trgr:get-trigger-by-id|trgr:get-trigger|trgr:document-scope|trgr:document-content|trgr:directory-scope|trgr:create-trigger|trgr:collection-scope|trgr:any-property-content|thsr:set-entry|thsr:remove-term|thsr:remove-synonym|thsr:remove-entry|thsr:query-lookup|thsr:lookup|thsr:load|thsr:insert|thsr:expand|thsr:add-synonym|spell:suggest-detailed|spell:suggest|spell:remove-word|spell:make-dictionary|spell:load|spell:levenshtein-distance|spell:is-correct|spell:insert|spell:double-metaphone|spell:add-word|sec:users-collection|sec:user-set-roles|sec:user-set-password|sec:user-set-name|sec:user-set-description|sec:user-set-default-permissions|sec:user-set-default-collections|sec:user-remove-roles|sec:user-privileges|sec:user-get-roles|sec:user-get-description|sec:user-get-default-permissions|sec:user-get-default-collections|sec:user-doc-permissions|sec:user-doc-collections|sec:user-add-roles|sec:unprotect-collection|sec:uid-for-name|sec:set-realm|sec:security-version|sec:security-namespace|sec:security-installed|sec:security-collection|sec:roles-collection|sec:role-set-roles|sec:role-set-name|sec:role-set-description|sec:role-set-default-permissions|sec:role-set-default-collections|sec:role-remove-roles|sec:role-privileges|sec:role-get-roles|sec:role-get-description|sec:role-get-default-permissions|sec:role-get-default-collections|sec:role-doc-permissions|sec:role-doc-collections|sec:role-add-roles|sec:remove-user|sec:remove-role-from-users|sec:remove-role-from-role|sec:remove-role-from-privileges|sec:remove-role-from-amps|sec:remove-role|sec:remove-privilege|sec:remove-amp|sec:protect-collection|sec:privileges-collection|sec:privilege-set-roles|sec:privilege-set-name|sec:privilege-remove-roles|sec:privilege-get-roles|sec:privilege-add-roles|sec:priv-doc-permissions|sec:priv-doc-collections|sec:get-user-names|sec:get-unique-elem-id|sec:get-role-names|sec:get-role-ids|sec:get-privilege|sec:get-distinct-permissions|sec:get-collection|sec:get-amp|sec:create-user-with-role|sec:create-user|sec:create-role|sec:create-privilege|sec:create-amp|sec:collections-collection|sec:collection-set-permissions|sec:collection-remove-permissions|sec:collection-get-permissions|sec:collection-add-permissions|sec:check-admin|sec:amps-collection|sec:amp-set-roles|sec:amp-remove-roles|sec:amp-get-roles|sec:amp-doc-permissions|sec:amp-doc-collections|sec:amp-add-roles|search:unparse|search:suggest|search:snippet|search:search|search:resolve-nodes|search:resolve|search:remove-constraint|search:parse|search:get-default-options|search:estimate|search:check-options|prof:value|prof:reset|prof:report|prof:invoke|prof:eval|prof:enable|prof:disable|prof:allowed|ppt:clean|pki:template-set-request|pki:template-set-name|pki:template-set-key-type|pki:template-set-key-options|pki:template-set-description|pki:template-in-use|pki:template-get-version|pki:template-get-request|pki:template-get-name|pki:template-get-key-type|pki:template-get-key-options|pki:template-get-id|pki:template-get-description|pki:need-certificate|pki:is-temporary|pki:insert-trusted-certificates|pki:insert-template|pki:insert-signed-certificates|pki:insert-certificate-revocation-list|pki:get-trusted-certificate-ids|pki:get-template-ids|pki:get-template-certificate-authority|pki:get-template-by-name|pki:get-template|pki:get-pending-certificate-requests-xml|pki:get-pending-certificate-requests-pem|pki:get-pending-certificate-request|pki:get-certificates-for-template-xml|pki:get-certificates-for-template|pki:get-certificates|pki:get-certificate-xml|pki:get-certificate-pem|pki:get-certificate|pki:generate-temporary-certificate-if-necessary|pki:generate-temporary-certificate|pki:generate-template-certificate-authority|pki:generate-certificate-request|pki:delete-template|pki:delete-certificate|pki:create-template|pdf:make-toc|pdf:insert-toc-headers|pdf:get-toc|pdf:clean|p:status-transition|p:state-transition|p:remove|p:pipelines|p:insert|p:get-by-id|p:get|p:execute|p:create|p:condition|p:collection|p:action|ooxml:runs-merge|ooxml:package-uris|ooxml:package-parts-insert|ooxml:package-parts|msword:clean|mcgm:polygon|mcgm:point|mcgm:geospatial-query-from-elements|mcgm:geospatial-query|mcgm:circle|math:tanh|math:tan|math:sqrt|math:sinh|math:sin|math:pow|math:modf|math:log10|math:log|math:ldexp|math:frexp|math:fmod|math:floor|math:fabs|math:exp|math:cosh|math:cos|math:ceil|math:atan2|math:atan|math:asin|math:acos|map:put|map:map|map:keys|map:get|map:delete|map:count|map:clear|lnk:to|lnk:remove|lnk:insert|lnk:get|lnk:from|lnk:create|kml:polygon|kml:point|kml:interior-polygon|kml:geospatial-query-from-elements|kml:geospatial-query|kml:circle|kml:box|gml:polygon|gml:point|gml:interior-polygon|gml:geospatial-query-from-elements|gml:geospatial-query|gml:circle|gml:box|georss:point|georss:geospatial-query|georss:circle|geo:polygon|geo:point|geo:interior-polygon|geo:geospatial-query-from-elements|geo:geospatial-query|geo:circle|geo:box|fn:zero-or-one|fn:years-from-duration|fn:year-from-dateTime|fn:year-from-date|fn:upper-case|fn:unordered|fn:true|fn:translate|fn:trace|fn:tokenize|fn:timezone-from-time|fn:timezone-from-dateTime|fn:timezone-from-date|fn:sum|fn:subtract-dateTimes-yielding-yearMonthDuration|fn:subtract-dateTimes-yielding-dayTimeDuration|fn:substring-before|fn:substring-after|fn:substring|fn:subsequence|fn:string-to-codepoints|fn:string-pad|fn:string-length|fn:string-join|fn:string|fn:static-base-uri|fn:starts-with|fn:seconds-from-time|fn:seconds-from-duration|fn:seconds-from-dateTime|fn:round-half-to-even|fn:round|fn:root|fn:reverse|fn:resolve-uri|fn:resolve-QName|fn:replace|fn:remove|fn:QName|fn:prefix-from-QName|fn:position|fn:one-or-more|fn:number|fn:not|fn:normalize-unicode|fn:normalize-space|fn:node-name|fn:node-kind|fn:nilled|fn:namespace-uri-from-QName|fn:namespace-uri-for-prefix|fn:namespace-uri|fn:name|fn:months-from-duration|fn:month-from-dateTime|fn:month-from-date|fn:minutes-from-time|fn:minutes-from-duration|fn:minutes-from-dateTime|fn:min|fn:max|fn:matches|fn:lower-case|fn:local-name-from-QName|fn:local-name|fn:last|fn:lang|fn:iri-to-uri|fn:insert-before|fn:index-of|fn:in-scope-prefixes|fn:implicit-timezone|fn:idref|fn:id|fn:hours-from-time|fn:hours-from-duration|fn:hours-from-dateTime|fn:floor|fn:false|fn:expanded-QName|fn:exists|fn:exactly-one|fn:escape-uri|fn:escape-html-uri|fn:error|fn:ends-with|fn:encode-for-uri|fn:empty|fn:document-uri|fn:doc-available|fn:doc|fn:distinct-values|fn:distinct-nodes|fn:default-collation|fn:deep-equal|fn:days-from-duration|fn:day-from-dateTime|fn:day-from-date|fn:data|fn:current-time|fn:current-dateTime|fn:current-date|fn:count|fn:contains|fn:concat|fn:compare|fn:collection|fn:codepoints-to-string|fn:codepoint-equal|fn:ceiling|fn:boolean|fn:base-uri|fn:avg|fn:adjust-time-to-timezone|fn:adjust-dateTime-to-timezone|fn:adjust-date-to-timezone|fn:abs|feed:unsubscribe|feed:subscription|feed:subscribe|feed:request|feed:item|feed:description|excel:clean|entity:enrich|dom:set-pipelines|dom:set-permissions|dom:set-name|dom:set-evaluation-context|dom:set-domain-scope|dom:set-description|dom:remove-pipeline|dom:remove-permissions|dom:remove|dom:get|dom:evaluation-context|dom:domains|dom:domain-scope|dom:create|dom:configuration-set-restart-user|dom:configuration-set-permissions|dom:configuration-set-evaluation-context|dom:configuration-set-default-domain|dom:configuration-get|dom:configuration-create|dom:collection|dom:add-pipeline|dom:add-permissions|dls:retention-rules|dls:retention-rule-remove|dls:retention-rule-insert|dls:retention-rule|dls:purge|dls:node-expand|dls:link-references|dls:link-expand|dls:documents-query|dls:document-versions-query|dls:document-version-uri|dls:document-version-query|dls:document-version-delete|dls:document-version-as-of|dls:document-version|dls:document-update|dls:document-unmanage|dls:document-set-quality|dls:document-set-property|dls:document-set-properties|dls:document-set-permissions|dls:document-set-collections|dls:document-retention-rules|dls:document-remove-properties|dls:document-remove-permissions|dls:document-remove-collections|dls:document-purge|dls:document-manage|dls:document-is-managed|dls:document-insert-and-manage|dls:document-include-query|dls:document-history|dls:document-get-permissions|dls:document-extract-part|dls:document-delete|dls:document-checkout-status|dls:document-checkout|dls:document-checkin|dls:document-add-properties|dls:document-add-permissions|dls:document-add-collections|dls:break-checkout|dls:author-query|dls:as-of-query|dbk:convert|dbg:wait|dbg:value|dbg:stopped|dbg:stop|dbg:step|dbg:status|dbg:stack|dbg:out|dbg:next|dbg:line|dbg:invoke|dbg:function|dbg:finish|dbg:expr|dbg:eval|dbg:disconnect|dbg:detach|dbg:continue|dbg:connect|dbg:clear|dbg:breakpoints|dbg:break|dbg:attached|dbg:attach|cvt:save-converted-documents|cvt:part-uri|cvt:destination-uri|cvt:basepath|cvt:basename|cts:words|cts:word-query-weight|cts:word-query-text|cts:word-query-options|cts:word-query|cts:word-match|cts:walk|cts:uris|cts:uri-match|cts:train|cts:tokenize|cts:thresholds|cts:stem|cts:similar-query-weight|cts:similar-query-nodes|cts:similar-query|cts:shortest-distance|cts:search|cts:score|cts:reverse-query-weight|cts:reverse-query-nodes|cts:reverse-query|cts:remainder|cts:registered-query-weight|cts:registered-query-options|cts:registered-query-ids|cts:registered-query|cts:register|cts:query|cts:quality|cts:properties-query-query|cts:properties-query|cts:polygon-vertices|cts:polygon|cts:point-longitude|cts:point-latitude|cts:point|cts:or-query-queries|cts:or-query|cts:not-query-weight|cts:not-query-query|cts:not-query|cts:near-query-weight|cts:near-query-queries|cts:near-query-options|cts:near-query-distance|cts:near-query|cts:highlight|cts:geospatial-co-occurrences|cts:frequency|cts:fitness|cts:field-words|cts:field-word-query-weight|cts:field-word-query-text|cts:field-word-query-options|cts:field-word-query-field-name|cts:field-word-query|cts:field-word-match|cts:entity-highlight|cts:element-words|cts:element-word-query-weight|cts:element-word-query-text|cts:element-word-query-options|cts:element-word-query-element-name|cts:element-word-query|cts:element-word-match|cts:element-values|cts:element-value-ranges|cts:element-value-query-weight|cts:element-value-query-text|cts:element-value-query-options|cts:element-value-query-element-name|cts:element-value-query|cts:element-value-match|cts:element-value-geospatial-co-occurrences|cts:element-value-co-occurrences|cts:element-range-query-weight|cts:element-range-query-value|cts:element-range-query-options|cts:element-range-query-operator|cts:element-range-query-element-name|cts:element-range-query|cts:element-query-query|cts:element-query-element-name|cts:element-query|cts:element-pair-geospatial-values|cts:element-pair-geospatial-value-match|cts:element-pair-geospatial-query-weight|cts:element-pair-geospatial-query-region|cts:element-pair-geospatial-query-options|cts:element-pair-geospatial-query-longitude-name|cts:element-pair-geospatial-query-latitude-name|cts:element-pair-geospatial-query-element-name|cts:element-pair-geospatial-query|cts:element-pair-geospatial-boxes|cts:element-geospatial-values|cts:element-geospatial-value-match|cts:element-geospatial-query-weight|cts:element-geospatial-query-region|cts:element-geospatial-query-options|cts:element-geospatial-query-element-name|cts:element-geospatial-query|cts:element-geospatial-boxes|cts:element-child-geospatial-values|cts:element-child-geospatial-value-match|cts:element-child-geospatial-query-weight|cts:element-child-geospatial-query-region|cts:element-child-geospatial-query-options|cts:element-child-geospatial-query-element-name|cts:element-child-geospatial-query-child-name|cts:element-child-geospatial-query|cts:element-child-geospatial-boxes|cts:element-attribute-words|cts:element-attribute-word-query-weight|cts:element-attribute-word-query-text|cts:element-attribute-word-query-options|cts:element-attribute-word-query-element-name|cts:element-attribute-word-query-attribute-name|cts:element-attribute-word-query|cts:element-attribute-word-match|cts:element-attribute-values|cts:element-attribute-value-ranges|cts:element-attribute-value-query-weight|cts:element-attribute-value-query-text|cts:element-attribute-value-query-options|cts:element-attribute-value-query-element-name|cts:element-attribute-value-query-attribute-name|cts:element-attribute-value-query|cts:element-attribute-value-match|cts:element-attribute-value-geospatial-co-occurrences|cts:element-attribute-value-co-occurrences|cts:element-attribute-range-query-weight|cts:element-attribute-range-query-value|cts:element-attribute-range-query-options|cts:element-attribute-range-query-operator|cts:element-attribute-range-query-element-name|cts:element-attribute-range-query-attribute-name|cts:element-attribute-range-query|cts:element-attribute-pair-geospatial-values|cts:element-attribute-pair-geospatial-value-match|cts:element-attribute-pair-geospatial-query-weight|cts:element-attribute-pair-geospatial-query-region|cts:element-attribute-pair-geospatial-query-options|cts:element-attribute-pair-geospatial-query-longitude-name|cts:element-attribute-pair-geospatial-query-latitude-name|cts:element-attribute-pair-geospatial-query-element-name|cts:element-attribute-pair-geospatial-query|cts:element-attribute-pair-geospatial-boxes|cts:document-query-uris|cts:document-query|cts:distance|cts:directory-query-uris|cts:directory-query-depth|cts:directory-query|cts:destination|cts:deregister|cts:contains|cts:confidence|cts:collections|cts:collection-query-uris|cts:collection-query|cts:collection-match|cts:classify|cts:circle-radius|cts:circle-center|cts:circle|cts:box-west|cts:box-south|cts:box-north|cts:box-east|cts:box|cts:bearing|cts:arc-intersection|cts:and-query-queries|cts:and-query-options|cts:and-query|cts:and-not-query-positive-query|cts:and-not-query-negative-query|cts:and-not-query|css:get|css:convert|cpf:success|cpf:failure|cpf:document-set-state|cpf:document-set-processing-status|cpf:document-set-last-updated|cpf:document-set-error|cpf:document-get-state|cpf:document-get-processing-status|cpf:document-get-last-updated|cpf:document-get-error|cpf:check-transition|alert:spawn-matching-actions|alert:rule-user-id-query|alert:rule-set-user-id|alert:rule-set-query|alert:rule-set-options|alert:rule-set-name|alert:rule-set-description|alert:rule-set-action|alert:rule-remove|alert:rule-name-query|alert:rule-insert|alert:rule-id-query|alert:rule-get-user-id|alert:rule-get-query|alert:rule-get-options|alert:rule-get-name|alert:rule-get-id|alert:rule-get-description|alert:rule-get-action|alert:rule-action-query|alert:remove-triggers|alert:make-rule|alert:make-log-action|alert:make-config|alert:make-action|alert:invoke-matching-actions|alert:get-my-rules|alert:get-all-rules|alert:get-actions|alert:find-matching-rules|alert:create-triggers|alert:config-set-uri|alert:config-set-trigger-ids|alert:config-set-options|alert:config-set-name|alert:config-set-description|alert:config-set-cpf-domain-names|alert:config-set-cpf-domain-ids|alert:config-insert|alert:config-get-uri|alert:config-get-trigger-ids|alert:config-get-options|alert:config-get-name|alert:config-get-id|alert:config-get-description|alert:config-get-cpf-domain-names|alert:config-get-cpf-domain-ids|alert:config-get|alert:config-delete|alert:action-set-options|alert:action-set-name|alert:action-set-module-root|alert:action-set-module-db|alert:action-set-module|alert:action-set-description|alert:action-remove|alert:action-insert|alert:action-get-options|alert:action-get-name|alert:action-get-module-root|alert:action-get-module-db|alert:action-get-module|alert:action-get-description|zero-or-one|years-from-duration|year-from-dateTime|year-from-date|upper-case|unordered|true|translate|trace|tokenize|timezone-from-time|timezone-from-dateTime|timezone-from-date|sum|subtract-dateTimes-yielding-yearMonthDuration|subtract-dateTimes-yielding-dayTimeDuration|substring-before|substring-after|substring|subsequence|string-to-codepoints|string-pad|string-length|string-join|string|static-base-uri|starts-with|seconds-from-time|seconds-from-duration|seconds-from-dateTime|round-half-to-even|round|root|reverse|resolve-uri|resolve-QName|replace|remove|QName|prefix-from-QName|position|one-or-more|number|not|normalize-unicode|normalize-space|node-name|node-kind|nilled|namespace-uri-from-QName|namespace-uri-for-prefix|namespace-uri|name|months-from-duration|month-from-dateTime|month-from-date|minutes-from-time|minutes-from-duration|minutes-from-dateTime|min|max|matches|lower-case|local-name-from-QName|local-name|last|lang|iri-to-uri|insert-before|index-of|in-scope-prefixes|implicit-timezone|idref|id|hours-from-time|hours-from-duration|hours-from-dateTime|floor|false|expanded-QName|exists|exactly-one|escape-uri|escape-html-uri|error|ends-with|encode-for-uri|empty|document-uri|doc-available|doc|distinct-values|distinct-nodes|default-collation|deep-equal|days-from-duration|day-from-dateTime|day-from-date|data|current-time|current-dateTime|current-date|count|contains|concat|compare|collection|codepoints-to-string|codepoint-equal|ceiling|boolean|base-uri|avg|adjust-time-to-timezone|adjust-dateTime-to-timezone|adjust-date-to-timezone|abs)\\b/], // Matching normal words if none of the previous regular expressions matched [PR['PR_PLAIN'], /^[A-Za-z0-9_\\-\\:]+/], // Matching whitespaces [PR['PR_PLAIN'], /^[\\t\\n\\r \\xA0]+/] ]), ['xq', 'xquery']); })();"},{"title":"","date":"2021-03-03T02:50:12.471Z","updated":"2021-03-03T02:50:12.471Z","comments":true,"path":"plugins/prettify/prettify.js","permalink":"http://sinlapis.github.io/plugins/prettify/prettify.js","excerpt":"","text":"/** * @license * Copyright (C) 2006 Google Inc. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ /** * @fileoverview * some functions for browser-side pretty printing of code contained in html. * * * For a fairly comprehensive set of languages see the * README * file that came with this source. At a minimum, the lexer should work on a * number of languages including C and friends, Java, Python, Bash, SQL, HTML, * XML, CSS, Javascript, and Makefiles. It works passably on Ruby, PHP and Awk * and a subset of Perl, but, because of commenting conventions, doesn't work on * Smalltalk, Lisp-like, or CAML-like languages without an explicit lang class. * * Usage: * include this source file in an html page via * {@code } * define style rules. See the example page for examples. * mark the {@code } and {@code } tags in your source with * {@code class=prettyprint.} * You can also use the (html deprecated) {@code } tag, but the pretty * printer needs to do more substantial DOM manipulations to support that, so * some css styles may not be preserved. * * That's it. I wanted to keep the API as simple as possible, so there's no * need to specify which language the code is in, but if you wish, you can add * another class to the {@code } or {@code } element to specify the * language, as in {@code }. Any class that * starts with \"lang-\" followed by a file extension, specifies the file type. * See the \"lang-*.js\" files in this directory for code that implements * per-language file handlers. * * Change log: * cbeust, 2006/08/22 * * Java annotations (start with \"@\") are now captured as literals (\"lit\") * * @requires console */ // JSLint declarations /*global console, document, navigator, setTimeout, window, define */ /** * @typedef {!Array.} * Alternating indices and the decorations that should be inserted there. * The indices are monotonically increasing. */ var DecorationsT; /** * @typedef {!{ * sourceNode: !Element, * pre: !(number|boolean), * langExtension: ?string, * numberLines: ?(number|boolean), * sourceCode: ?string, * spans: ?(Array.), * basePos: ?number, * decorations: ?DecorationsT * }} * * sourceNodethe element containing the source * sourceCodesource as plain text * pretruthy if white-space in text nodes * should be considered significant. * spans alternating span start indices into source * and the text node or element (e.g. {@code }) corresponding to that * span. * decorationsan array of style classes preceded * by the position at which they start in job.sourceCode in order * basePosinteger position of this.sourceCode in the larger chunk of * source. * */ var JobT; /** * @typedef {!{ * sourceCode: string, * spans: !(Array.) * }} * * sourceCodesource as plain text * spans alternating span start indices into source * and the text node or element (e.g. {@code }) corresponding to that * span. * */ var SourceSpansT; /** @define {boolean} */ var IN_GLOBAL_SCOPE = false; var HACK_TO_FIX_JS_INCLUDE_PL; /** * {@type !{ * 'createSimpleLexer': function (Array, Array): (function (JobT)), * 'registerLangHandler': function (function (JobT), Array.), * 'PR_ATTRIB_NAME': string, * 'PR_ATTRIB_NAME': string, * 'PR_ATTRIB_VALUE': string, * 'PR_COMMENT': string, * 'PR_DECLARATION': string, * 'PR_KEYWORD': string, * 'PR_LITERAL': string, * 'PR_NOCODE': string, * 'PR_PLAIN': string, * 'PR_PUNCTUATION': string, * 'PR_SOURCE': string, * 'PR_STRING': string, * 'PR_TAG': string, * 'PR_TYPE': string, * 'prettyPrintOne': function (string, string, number|boolean), * 'prettyPrint': function (?function, ?(HTMLElement|HTMLDocument)) * }} * @const */ var PR; /** * Split {@code prettyPrint} into multiple timeouts so as not to interfere with * UI events. * If set to {@code false}, {@code prettyPrint()} is synchronous. */ window['PR_SHOULD_USE_CONTINUATION'] = true; /** * Pretty print a chunk of code. * @param {string} sourceCodeHtml The HTML to pretty print. * @param {string} opt_langExtension The language name to use. * Typically, a filename extension like 'cpp' or 'java'. * @param {number|boolean} opt_numberLines True to number lines, * or the 1-indexed number of the first line in sourceCodeHtml. * @return {string} code as html, but prettier */ var prettyPrintOne; /** * Find all the {@code } and {@code } tags in the DOM with * {@code class=prettyprint} and prettify them. * * @param {Function} opt_whenDone called when prettifying is done. * @param {HTMLElement|HTMLDocument} opt_root an element or document * containing all the elements to pretty print. * Defaults to {@code document.body}. */ var prettyPrint; (function () { var win = window; // Keyword lists for various languages. // We use things that coerce to strings to make them compact when minified // and to defeat aggressive optimizers that fold large string constants. var FLOW_CONTROL_KEYWORDS = [\"break,continue,do,else,for,if,return,while\"]; var C_KEYWORDS = [FLOW_CONTROL_KEYWORDS,\"auto,case,char,const,default,\" + \"double,enum,extern,float,goto,inline,int,long,register,restrict,short,signed,\" + \"sizeof,static,struct,switch,typedef,union,unsigned,void,volatile\"]; var COMMON_KEYWORDS = [C_KEYWORDS,\"catch,class,delete,false,import,\" + \"new,operator,private,protected,public,this,throw,true,try,typeof\"]; var CPP_KEYWORDS = [COMMON_KEYWORDS,\"alignas,alignof,align_union,asm,axiom,bool,\" + \"concept,concept_map,const_cast,constexpr,decltype,delegate,\" + \"dynamic_cast,explicit,export,friend,generic,late_check,\" + \"mutable,namespace,noexcept,noreturn,nullptr,property,reinterpret_cast,static_assert,\" + \"static_cast,template,typeid,typename,using,virtual,where\"]; var JAVA_KEYWORDS = [COMMON_KEYWORDS, \"abstract,assert,boolean,byte,extends,finally,final,implements,import,\" + \"instanceof,interface,null,native,package,strictfp,super,synchronized,\" + \"throws,transient\"]; var CSHARP_KEYWORDS = [COMMON_KEYWORDS, \"abstract,add,alias,as,ascending,async,await,base,bool,by,byte,checked,decimal,delegate,descending,\" + \"dynamic,event,finally,fixed,foreach,from,get,global,group,implicit,in,interface,\" + \"internal,into,is,join,let,lock,null,object,out,override,orderby,params,\" + \"partial,readonly,ref,remove,sbyte,sealed,select,set,stackalloc,string,select,uint,ulong,\" + \"unchecked,unsafe,ushort,value,var,virtual,where,yield\"]; var COFFEE_KEYWORDS = \"all,and,by,catch,class,else,extends,false,finally,\" + \"for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,\" + \"throw,true,try,unless,until,when,while,yes\"; var JSCRIPT_KEYWORDS = [COMMON_KEYWORDS, \"abstract,async,await,constructor,debugger,enum,eval,export,function,\" + \"get,implements,instanceof,interface,let,null,set,undefined,var,with,\" + \"yield,Infinity,NaN\"]; var PERL_KEYWORDS = \"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,\" + \"goto,if,import,last,local,my,next,no,our,print,package,redo,require,\" + \"sub,undef,unless,until,use,wantarray,while,BEGIN,END\"; var PYTHON_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"and,as,assert,class,def,del,\" + \"elif,except,exec,finally,from,global,import,in,is,lambda,\" + \"nonlocal,not,or,pass,print,raise,try,with,yield,\" + \"False,True,None\"]; var RUBY_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"alias,and,begin,case,class,\" + \"def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,\" + \"rescue,retry,self,super,then,true,undef,unless,until,when,yield,\" + \"BEGIN,END\"]; var SH_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"case,done,elif,esac,eval,fi,\" + \"function,in,local,set,then,until\"]; var ALL_KEYWORDS = [ CPP_KEYWORDS, CSHARP_KEYWORDS, JAVA_KEYWORDS, JSCRIPT_KEYWORDS, PERL_KEYWORDS, PYTHON_KEYWORDS, RUBY_KEYWORDS, SH_KEYWORDS]; var C_TYPES = /^(DIR|FILE|array|vector|(de|priority_)?queue|(forward_)?list|stack|(const_)?(reverse_)?iterator|(unordered_)?(multi)?(set|map)|bitset|u?(int|float)\\d*)\\b/; // token style names. correspond to css classes /** * token style for a string literal * @const */ var PR_STRING = 'str'; /** * token style for a keyword * @const */ var PR_KEYWORD = 'kwd'; /** * token style for a comment * @const */ var PR_COMMENT = 'com'; /** * token style for a type * @const */ var PR_TYPE = 'typ'; /** * token style for a literal value. e.g. 1, null, true. * @const */ var PR_LITERAL = 'lit'; /** * token style for a punctuation string. * @const */ var PR_PUNCTUATION = 'pun'; /** * token style for plain text. * @const */ var PR_PLAIN = 'pln'; /** * token style for an sgml tag. * @const */ var PR_TAG = 'tag'; /** * token style for a markup declaration such as a DOCTYPE. * @const */ var PR_DECLARATION = 'dec'; /** * token style for embedded source. * @const */ var PR_SOURCE = 'src'; /** * token style for an sgml attribute name. * @const */ var PR_ATTRIB_NAME = 'atn'; /** * token style for an sgml attribute value. * @const */ var PR_ATTRIB_VALUE = 'atv'; /** * A class that indicates a section of markup that is not code, e.g. to allow * embedding of line numbers within code listings. * @const */ var PR_NOCODE = 'nocode'; /** * A set of tokens that can precede a regular expression literal in * javascript * http://web.archive.org/web/20070717142515/http://www.mozilla.org/js/language/js20/rationale/syntax.html * has the full list, but I've removed ones that might be problematic when * seen in languages that don't support regular expression literals. * * Specifically, I've removed any keywords that can't precede a regexp * literal in a syntactically legal javascript program, and I've removed the * \"in\" keyword since it's not a keyword in many languages, and might be used * as a count of inches. * * The link above does not accurately describe EcmaScript rules since * it fails to distinguish between (a=++/b/i) and (a++/b/i) but it works * very well in practice. * * @private * @const */ var REGEXP_PRECEDER_PATTERN = '(?:^^\\\\.?|[+-]|[!=]=?=?|\\\\#|%=?|&&?=?|\\\\(|\\\\*=?|[+\\\\-]=|->|\\\\/=?|::?|?>?=?|,|;|\\\\?|@|\\\\[|~|{|\\\\^\\\\^?=?|\\\\|\\\\|?=?|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\\\\s*'; // CAVEAT: this does not properly handle the case where a regular // expression immediately follows another since a regular expression may // have flags for case-sensitivity and the like. Having regexp tokens // adjacent is not valid in any language I'm aware of, so I'm punting. // TODO: maybe style special characters inside a regexp as punctuation. /** * Given a group of {@link RegExp}s, returns a {@code RegExp} that globally * matches the union of the sets of strings matched by the input RegExp. * Since it matches globally, if the input strings have a start-of-input * anchor (/^.../), it is ignored for the purposes of unioning. * @param {Array.} regexs non multiline, non-global regexs. * @return {RegExp} a global regex. */ function combinePrefixPatterns(regexs) { var capturedGroupIndex = 0; var needToFoldCase = false; var ignoreCase = false; for (var i = 0, n = regexs.length; i < n; ++i) { var regex = regexs[i]; if (regex.ignoreCase) { ignoreCase = true; } else if (/[a-z]/i.test(regex.source.replace( /\\\\u[0-9a-f]{4}|\\\\x[0-9a-f]{2}|\\\\[^ux]/gi, ''))) { needToFoldCase = true; ignoreCase = false; break; } } var escapeCharToCodeUnit = { 'b': 8, 't': 9, 'n': 0xa, 'v': 0xb, 'f': 0xc, 'r': 0xd }; function decodeEscape(charsetPart) { var cc0 = charsetPart.charCodeAt(0); if (cc0 !== 92 /* \\\\ */) { return cc0; } var c1 = charsetPart.charAt(1); cc0 = escapeCharToCodeUnit[c1]; if (cc0) { return cc0; } else if ('0' = 0;) { shortcuts[shortcutChars.charAt(c)] = patternParts; } } var regex = patternParts[1]; var k = '' + regex; if (!regexKeys.hasOwnProperty(k)) { allRegexs.push(regex); regexKeys[k] = null; } } allRegexs.push(/[\\0-\\uffff]/); tokenizer = combinePrefixPatterns(allRegexs); })(); var nPatterns = fallthroughStylePatterns.length; /** * Lexes job.sourceCode and attaches an output array job.decorations of * style classes preceded by the position at which they start in * job.sourceCode in order. * * @type{function (JobT)} */ var decorate = function (job) { var sourceCode = job.sourceCode, basePos = job.basePos; var sourceNode = job.sourceNode; /** Even entries are positions in source in ascending order. Odd enties * are style markers (e.g., PR_COMMENT) that run from that position until * the end. * @type {DecorationsT} */ var decorations = [basePos, PR_PLAIN]; var pos = 0; // index into sourceCode var tokens = sourceCode.match(tokenizer) || []; var styleCache = {}; for (var ti = 0, nTokens = tokens.length; ti < nTokens; ++ti) { var token = tokens[ti]; var style = styleCache[token]; var match = void 0; var isEmbedded; if (typeof style === 'string') { isEmbedded = false; } else { var patternParts = shortcuts[token.charAt(0)]; if (patternParts) { match = token.match(patternParts[1]); style = patternParts[0]; } else { for (var i = 0; i < nPatterns; ++i) { patternParts = fallthroughStylePatterns[i]; match = token.match(patternParts[1]); if (match) { style = patternParts[0]; break; } } if (!match) { // make sure that we make progress style = PR_PLAIN; } } isEmbedded = style.length >= 5 && 'lang-' === style.substring(0, 5); if (isEmbedded && !(match && typeof match[1] === 'string')) { isEmbedded = false; style = PR_SOURCE; } if (!isEmbedded) { styleCache[token] = style; } } var tokenStart = pos; pos += token.length; if (!isEmbedded) { decorations.push(basePos + tokenStart, style); } else { // Treat group 1 as an embedded block of source code. var embeddedSource = match[1]; var embeddedSourceStart = token.indexOf(embeddedSource); var embeddedSourceEnd = embeddedSourceStart + embeddedSource.length; if (match[2]) { // If embeddedSource can be blank, then it would match at the // beginning which would cause us to infinitely recurse on the // entire token, so we catch the right context in match[2]. embeddedSourceEnd = token.length - match[2].length; embeddedSourceStart = embeddedSourceEnd - embeddedSource.length; } var lang = style.substring(5); // Decorate the left of the embedded source appendDecorations( sourceNode, basePos + tokenStart, token.substring(0, embeddedSourceStart), decorate, decorations); // Decorate the embedded source appendDecorations( sourceNode, basePos + tokenStart + embeddedSourceStart, embeddedSource, langHandlerForExtension(lang, embeddedSource), decorations); // Decorate the right of the embedded section appendDecorations( sourceNode, basePos + tokenStart + embeddedSourceEnd, token.substring(embeddedSourceEnd), decorate, decorations); } } job.decorations = decorations; }; return decorate; } /** returns a function that produces a list of decorations from source text. * * This code treats \", ', and ` as string delimiters, and \\ as a string * escape. It does not recognize perl's qq() style strings. * It has no special handling for double delimiter escapes as in basic, or * the tripled delimiters used in python, but should work on those regardless * although in those cases a single string literal may be broken up into * multiple adjacent string literals. * * It recognizes C, C++, and shell style comments. * * @param {Object} options a set of optional parameters. * @return {function (JobT)} a function that examines the source code * in the input job and builds a decoration list which it attaches to * the job. */ function sourceDecorator(options) { var shortcutStylePatterns = [], fallthroughStylePatterns = []; if (options['tripleQuotedStrings']) { // '''multi-line-string''', 'single-line-string', and double-quoted shortcutStylePatterns.push( [PR_STRING, /^(?:\\'\\'\\'(?:[^\\'\\\\]|\\\\[\\s\\S]|\\'{1,2}(?=[^\\']))*(?:\\'\\'\\'|$)|\\\"\\\"\\\"(?:[^\\\"\\\\]|\\\\[\\s\\S]|\\\"{1,2}(?=[^\\\"]))*(?:\\\"\\\"\\\"|$)|\\'(?:[^\\\\\\']|\\\\[\\s\\S])*(?:\\'|$)|\\\"(?:[^\\\\\\\"]|\\\\[\\s\\S])*(?:\\\"|$))/, null, '\\'\"']); } else if (options['multiLineStrings']) { // 'multi-line-string', \"multi-line-string\" shortcutStylePatterns.push( [PR_STRING, /^(?:\\'(?:[^\\\\\\']|\\\\[\\s\\S])*(?:\\'|$)|\\\"(?:[^\\\\\\\"]|\\\\[\\s\\S])*(?:\\\"|$)|\\`(?:[^\\\\\\`]|\\\\[\\s\\S])*(?:\\`|$))/, null, '\\'\"`']); } else { // 'single-line-string', \"single-line-string\" shortcutStylePatterns.push( [PR_STRING, /^(?:\\'(?:[^\\\\\\'\\r\\n]|\\\\.)*(?:\\'|$)|\\\"(?:[^\\\\\\\"\\r\\n]|\\\\.)*(?:\\\"|$))/, null, '\"\\'']); } if (options['verbatimStrings']) { // verbatim-string-literal production from the C# grammar. See issue 93. fallthroughStylePatterns.push( [PR_STRING, /^@\\\"(?:[^\\\"]|\\\"\\\")*(?:\\\"|$)/, null]); } var hc = options['hashComments']; if (hc) { if (options['cStyleComments']) { if (hc > 1) { // multiline hash comments shortcutStylePatterns.push( [PR_COMMENT, /^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/, null, '#']); } else { // Stop C preprocessor declarations at an unclosed open comment shortcutStylePatterns.push( [PR_COMMENT, /^#(?:(?:define|e(?:l|nd)if|else|error|ifn?def|include|line|pragma|undef|warning)\\b|[^\\r\\n]*)/, null, '#']); } // #include fallthroughStylePatterns.push( [PR_STRING, /^/, null]); } else { shortcutStylePatterns.push([PR_COMMENT, /^#[^\\r\\n]*/, null, '#']); } } if (options['cStyleComments']) { fallthroughStylePatterns.push([PR_COMMENT, /^\\/\\/[^\\r\\n]*/, null]); fallthroughStylePatterns.push( [PR_COMMENT, /^\\/\\*[\\s\\S]*?(?:\\*\\/|$)/, null]); } var regexLiterals = options['regexLiterals']; if (regexLiterals) { /** * @const */ var regexExcls = regexLiterals > 1 ? '' // Multiline regex literals : '\\n\\r'; /** * @const */ var regexAny = regexExcls ? '.' : '[\\\\S\\\\s]'; /** * @const */ var REGEX_LITERAL = ( // A regular expression literal starts with a slash that is // not followed by * or / so that it is not confused with // comments. '/(?=[^/*' + regexExcls + '])' // and then contains any number of raw characters, + '(?:[^/\\\\x5B\\\\x5C' + regexExcls + ']' // escape sequences (\\x5C), + '|\\\\x5C' + regexAny // or non-nesting character sets (\\x5B\\x5D); + '|\\\\x5B(?:[^\\\\x5C\\\\x5D' + regexExcls + ']' + '|\\\\x5C' + regexAny + ')*(?:\\\\x5D|$))+' // finally closed by a /. + '/'); fallthroughStylePatterns.push( ['lang-regex', RegExp('^' + REGEXP_PRECEDER_PATTERN + '(' + REGEX_LITERAL + ')') ]); } var types = options['types']; if (types) { fallthroughStylePatterns.push([PR_TYPE, types]); } var keywords = (\"\" + options['keywords']).replace(/^ | $/g, ''); if (keywords.length) { fallthroughStylePatterns.push( [PR_KEYWORD, new RegExp('^(?:' + keywords.replace(/[\\s,]+/g, '|') + ')\\\\b'), null]); } shortcutStylePatterns.push([PR_PLAIN, /^\\s+/, null, ' \\r\\n\\t\\xA0']); var punctuation = // The Bash man page says // A word is a sequence of characters considered as a single // unit by GRUB. Words are separated by metacharacters, // which are the following plus space, tab, and newline: { } // | & $ ; < > // ... // A word beginning with # causes that word and all remaining // characters on that line to be ignored. // which means that only a '#' after /(?:^|[{}|&$;\\s])/ starts a // comment but empirically // $ echo // $ echo \\$# // $# // $ echo }# // }# // so /(?:^|[|&;\\s])/ is more appropriate. // http://gcc.gnu.org/onlinedocs/gcc-2.95.3/cpp_1.html#SEC3 // suggests that this definition is compatible with a // default mode that tries to use a single token definition // to recognize both bash/python style comments and C // preprocessor directives. // This definition of punctuation does not include # in the list of // follow-on exclusions, so # will not be broken before if preceeded // by a punctuation character. We could try to exclude # after // [|&;] but that doesn't seem to cause many major problems. // If that does turn out to be a problem, we should change the below // when hc is truthy to include # in the run of punctuation characters // only when not followint [|&;]. '^.[^\\\\s\\\\w.$@\\'\"`/\\\\\\\\]*'; if (options['regexLiterals']) { punctuation += '(?!\\s*\\/)'; } fallthroughStylePatterns.push( // TODO(mikesamuel): recognize non-latin letters and numerals in idents [PR_LITERAL, /^@[a-z_$][a-z_$@0-9]*/i, null], [PR_TYPE, /^(?:[@_]?[A-Z]+[a-z][A-Za-z_$@0-9]*|\\w+_t\\b)/, null], [PR_PLAIN, /^[a-z_$][a-z_$@0-9]*/i, null], [PR_LITERAL, new RegExp( '^(?:' // A hex number + '0x[a-f0-9]+' // or an octal or decimal number, + '|(?:\\\\d(?:_\\\\d+)*\\\\d*(?:\\\\.\\\\d*)?|\\\\.\\\\d\\\\+)' // possibly in scientific notation + '(?:e[+\\\\-]?\\\\d+)?' + ')' // with an optional modifier like UL for unsigned long + '[a-z]*', 'i'), null, '0123456789'], // Don't treat escaped quotes in bash as starting strings. // See issue 144. [PR_PLAIN, /^\\\\[\\s\\S]?/, null], [PR_PUNCTUATION, new RegExp(punctuation), null]); return createSimpleLexer(shortcutStylePatterns, fallthroughStylePatterns); } var decorateSource = sourceDecorator({ 'keywords': ALL_KEYWORDS, 'hashComments': true, 'cStyleComments': true, 'multiLineStrings': true, 'regexLiterals': true }); /** * Given a DOM subtree, wraps it in a list, and puts each line into its own * list item. * * @param {Node} node modified in place. Its content is pulled into an * HTMLOListElement, and each line is moved into a separate list item. * This requires cloning elements, so the input might not have unique * IDs after numbering. * @param {number|null|boolean} startLineNum * If truthy, coerced to an integer which is the 1-indexed line number * of the first line of code. The number of the first line will be * attached to the list. * @param {boolean} isPreformatted true iff white-space in text nodes should * be treated as significant. */ function numberLines(node, startLineNum, isPreformatted) { var nocode = /(?:^|\\s)nocode(?:\\s|$)/; var lineBreak = /\\r\\n?|\\n/; var document = node.ownerDocument; var li = document.createElement('li'); while (node.firstChild) { li.appendChild(node.firstChild); } // An array of lines. We split below, so this is initialized to one // un-split line. var listItems = [li]; function walk(node) { var type = node.nodeType; if (type == 1 && !nocode.test(node.className)) { // Element if ('br' === node.nodeName) { breakAfter(node); // Discard the since it is now flush against a . if (node.parentNode) { node.parentNode.removeChild(node); } } else { for (var child = node.firstChild; child; child = child.nextSibling) { walk(child); } } } else if ((type == 3 || type == 4) && isPreformatted) { // Text var text = node.nodeValue; var match = text.match(lineBreak); if (match) { var firstLine = text.substring(0, match.index); node.nodeValue = firstLine; var tail = text.substring(match.index + match[0].length); if (tail) { var parent = node.parentNode; parent.insertBefore( document.createTextNode(tail), node.nextSibling); } breakAfter(node); if (!firstLine) { // Don't leave blank text nodes in the DOM. node.parentNode.removeChild(node); } } } } // Split a line after the given node. function breakAfter(lineEndNode) { // If there's nothing to the right, then we can skip ending the line // here, and move root-wards since splitting just before an end-tag // would require us to create a bunch of empty copies. while (!lineEndNode.nextSibling) { lineEndNode = lineEndNode.parentNode; if (!lineEndNode) { return; } } function breakLeftOf(limit, copy) { // Clone shallowly if this node needs to be on both sides of the break. var rightSide = copy ? limit.cloneNode(false) : limit; var parent = limit.parentNode; if (parent) { // We clone the parent chain. // This helps us resurrect important styling elements that cross lines. // E.g. in FooBar // should be rewritten to FooBar. var parentClone = breakLeftOf(parent, 1); // Move the clone and everything to the right of the original // onto the cloned parent. var next = limit.nextSibling; parentClone.appendChild(rightSide); for (var sibling = next; sibling; sibling = next) { next = sibling.nextSibling; parentClone.appendChild(sibling); } } return rightSide; } var copiedListItem = breakLeftOf(lineEndNode.nextSibling, 0); // Walk the parent chain until we reach an unattached LI. for (var parent; // Check nodeType since IE invents document fragments. (parent = copiedListItem.parentNode) && parent.nodeType === 1;) { copiedListItem = parent; } // Put it on the list of lines for later processing. listItems.push(copiedListItem); } // Split lines while there are lines left to split. for (var i = 0; // Number of lines that have been split so far. i < listItems.length; // length updated by breakAfter calls. ++i) { walk(listItems[i]); } // Make sure numeric indices show correctly. if (startLineNum === (startLineNum|0)) { listItems[0].setAttribute('value', startLineNum); } var ol = document.createElement('ol'); ol.className = 'linenums'; var offset = Math.max(0, ((startLineNum - 1 /* zero index */)) | 0) || 0; for (var i = 0, n = listItems.length; i < n; ++i) { li = listItems[i]; // Stick a class on the LIs so that stylesheets can // color odd/even rows, or any other row pattern that // is co-prime with 10. li.className = 'L' + ((i + offset) % 10); if (!li.firstChild) { li.appendChild(document.createTextNode('\\xA0')); } ol.appendChild(li); } node.appendChild(ol); } /** * Breaks {@code job.sourceCode} around style boundaries in * {@code job.decorations} and modifies {@code job.sourceNode} in place. * @param {JobT} job * @private */ function recombineTagsAndDecorations(job) { var isIE8OrEarlier = /\\bMSIE\\s(\\d+)/.exec(navigator.userAgent); isIE8OrEarlier = isIE8OrEarlier && +isIE8OrEarlier[1]"},{"title":"","date":"2021-03-03T02:50:12.471Z","updated":"2021-03-03T02:50:12.471Z","comments":true,"path":"plugins/prettify/run_prettify.js","permalink":"http://sinlapis.github.io/plugins/prettify/run_prettify.js","excerpt":"","text":"/** * @license * Copyright (C) 2013 Google Inc. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ /** * @fileoverview * * Looks at query parameters to decide which language handlers and style-sheets * to load. * * Query Parameter Format Effect Default * +------------------+---------------+------------------------------+--------+ * | autorun= | true | false | If true then prettyPrint() | \"true\" | * | | | is called on page load. | | * +------------------+---------------+------------------------------+--------+ * | lang= | language name | Loads the language handler | Can | * | | | named \"lang-.js\". | appear | * | | | See available handlers at | many | * | | | https://github.com/google/ | times. | * | | | code-prettify/tree/master/ | | * | | | src | | * +------------------+---------------+------------------------------+--------+ * | skin= | skin name | Loads the skin stylesheet | none. | * | | | named \".css\". | | * | | | https://cdn.rawgit.com/ | | * | | | google/code-prettify/master/ | | * | | | styles/index.html | | * +------------------+---------------+------------------------------+--------+ * | callback= | JS identifier | When \"prettyPrint\" finishes | none | * | | | window.exports[js_ident] is | | * | | | called. | | * | | | The callback must be under | | * | | | exports to reduce the risk | | * | | | of XSS via query parameter | | * | | | injection. | | * +------------------+---------------+------------------------------+--------+ * * Exmaples * .../run_prettify.js?lang=css&skin=sunburst * 1. Loads the CSS language handler which can be used to prettify CSS * stylesheets, HTML element bodies and style=\"...\" attributes * values. * 2. Loads the sunburst.css stylesheet instead of the default prettify.css * stylesheet. * A gallery of stylesheets is available at * https://cdn.rawgit.com/google/code-prettify/master/styles/index.html * 3. Since autorun=false is not specified, calls prettyPrint() on page load. * */ /** * @typedef {!Array.} * Alternating indices and the decorations that should be inserted there. * The indices are monotonically increasing. */ var DecorationsT; /** * @typedef {!{ * sourceNode: !Element, * pre: !(number|boolean), * langExtension: ?string, * numberLines: ?(number|boolean), * sourceCode: ?string, * spans: ?(Array.), * basePos: ?number, * decorations: ?DecorationsT * }} * * sourceNodethe element containing the source * sourceCodesource as plain text * pretruthy if white-space in text nodes * should be considered significant. * spans alternating span start indices into source * and the text node or element (e.g. {@code }) corresponding to that * span. * decorationsan array of style classes preceded * by the position at which they start in job.sourceCode in order * basePosinteger position of this.sourceCode in the larger chunk of * source. * */ var JobT; /** * @typedef {!{ * sourceCode: string, * spans: !(Array.) * }} * * sourceCodesource as plain text * spans alternating span start indices into source * and the text node or element (e.g. {@code }) corresponding to that * span. * */ var SourceSpansT; /** @define {boolean} */ var IN_GLOBAL_SCOPE = false; (function () { \"use strict\"; var win = window; var doc = document; var root = doc.documentElement; var head = doc['head'] || doc.getElementsByTagName(\"head\")[0] || root; // From http://javascript.nwbox.com/ContentLoaded/contentloaded.js // Author: Diego Perini (diego.perini at gmail.com) // Summary: cross-browser wrapper for DOMContentLoaded // Updated: 20101020 // License: MIT // Version: 1.2 function contentLoaded(callback) { var addEventListener = doc['addEventListener']; var done = false, top = true, add = addEventListener ? 'addEventListener' : 'attachEvent', rem = addEventListener ? 'removeEventListener' : 'detachEvent', pre = addEventListener ? '' : 'on', init = function(e) { if (e.type == 'readystatechange' && doc.readyState != 'complete') { return; } (e.type == 'load' ? win : doc)[rem](pre + e.type, init, false); if (!done && (done = true)) { callback.call(win, e.type || e); } }, poll = function() { try { root.doScroll('left'); } catch(e) { win.setTimeout(poll, 50); return; } init('poll'); }; if (doc.readyState == 'complete') { callback.call(win, 'lazy'); } else { if (doc.createEventObject && root.doScroll) { try { top = !win.frameElement; } catch(e) { } if (top) { poll(); } } doc[add](pre + 'DOMContentLoaded', init, false); doc[add](pre + 'readystatechange', init, false); win[add](pre + 'load', init, false); } } // Given a list of URLs to stylesheets, loads the first that loads without // triggering an error event. function loadStylesheetsFallingBack(stylesheets) { var n = stylesheets.length; function load(i) { if (i === n) { return; } var link = doc.createElement('link'); link.rel = 'stylesheet'; link.type = 'text/css'; if (i + 1 < n) { // http://pieisgood.org/test/script-link-events/ indicates that many // versions of IE do not support onerror on s, though // http://msdn.microsoft.com/en-us/library/ie/ms535848(v=vs.85).aspx // indicates that recent IEs do support error. link.error = link.onerror = function () { load(i + 1); }; } link.href = stylesheets[i]; head.appendChild(link); } load(0); } var scriptQuery = ''; // Look for the node that loads this script to get its parameters. // This starts looking at the end instead of just considering the last // because deferred and async scripts run out of order. // If the script is loaded twice, then this will run in reverse order. var scripts = doc.getElementsByTagName('script'); for (var i = scripts.length; --i >= 0;) { var script = scripts[i]; var match = script.src.match( /^[^?#]*\\/run_prettify\\.js(\\?[^#]*)?(?:#.*)?$/); if (match) { scriptQuery = match[1] || ''; // Remove the script from the DOM so that multiple runs at least run // multiple times even if parameter sets are interpreted in reverse // order. script.parentNode.removeChild(script); break; } } // Pull parameters into local variables. var autorun = true; var langs = []; var skins = []; var callbacks = []; scriptQuery.replace( /[?&]([^&=]+)=([^&]+)/g, function (_, name, value) { value = decodeURIComponent(value); name = decodeURIComponent(name); if (name == 'autorun') { autorun = !/^[0fn]/i.test(value); } else if (name == 'lang') { langs.push(value); } else if (name == 'skin') { skins.push(value); } else if (name == 'callback') { callbacks.push(value); } }); // Use https to avoid mixed content warnings in client pages and to // prevent a MITM from rewrite prettify mid-flight. // This only works if this script is loaded via https : something // over which we exercise no control. var LOADER_BASE_URL = 'https://cdn.rawgit.com/google/code-prettify/master/loader'; for (var i = 0, n = langs.length; i < n; ++i) (function (lang) { var script = doc.createElement(\"script\"); // Excerpted from jQuery.ajaxTransport(\"script\") to fire events when // a script is finished loading. // Attach handlers for each script script.onload = script.onerror = script.onreadystatechange = function () { if (script && ( !script.readyState || /loaded|complete/.test(script.readyState))) { // Handle memory leak in IE script.onerror = script.onload = script.onreadystatechange = null; --pendingLanguages; checkPendingLanguages(); // Remove the script if (script.parentNode) { script.parentNode.removeChild(script); } script = null; } }; script.type = 'text/javascript'; script.src = LOADER_BASE_URL + '/lang-' + encodeURIComponent(langs[i]) + '.js'; // Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending head.insertBefore(script, head.firstChild); })(langs[i]); var pendingLanguages = langs.length; function checkPendingLanguages() { if (!pendingLanguages) { win.setTimeout(onLangsLoaded, 0); } } var skinUrls = []; for (var i = 0, n = skins.length; i < n; ++i) { skinUrls.push(LOADER_BASE_URL + '/skins/' + encodeURIComponent(skins[i]) + '.css'); } skinUrls.push(LOADER_BASE_URL + '/prettify.css'); loadStylesheetsFallingBack(skinUrls); var prettyPrint = (function () { /** * @license * Copyright (C) 2006 Google Inc. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ /** * @fileoverview * some functions for browser-side pretty printing of code contained in html. * * * For a fairly comprehensive set of languages see the * README * file that came with this source. At a minimum, the lexer should work on a * number of languages including C and friends, Java, Python, Bash, SQL, HTML, * XML, CSS, Javascript, and Makefiles. It works passably on Ruby, PHP and Awk * and a subset of Perl, but, because of commenting conventions, doesn't work on * Smalltalk, Lisp-like, or CAML-like languages without an explicit lang class. * * Usage: * include this source file in an html page via * {@code } * define style rules. See the example page for examples. * mark the {@code } and {@code } tags in your source with * {@code class=prettyprint.} * You can also use the (html deprecated) {@code } tag, but the pretty * printer needs to do more substantial DOM manipulations to support that, so * some css styles may not be preserved. * * That's it. I wanted to keep the API as simple as possible, so there's no * need to specify which language the code is in, but if you wish, you can add * another class to the {@code } or {@code } element to specify the * language, as in {@code }. Any class that * starts with \"lang-\" followed by a file extension, specifies the file type. * See the \"lang-*.js\" files in this directory for code that implements * per-language file handlers. * * Change log: * cbeust, 2006/08/22 * * Java annotations (start with \"@\") are now captured as literals (\"lit\") * * @requires console */ // JSLint declarations /*global console, document, navigator, setTimeout, window, define */ var HACK_TO_FIX_JS_INCLUDE_PL; /** * {@type !{ * 'createSimpleLexer': function (Array, Array): (function (JobT)), * 'registerLangHandler': function (function (JobT), Array.), * 'PR_ATTRIB_NAME': string, * 'PR_ATTRIB_NAME': string, * 'PR_ATTRIB_VALUE': string, * 'PR_COMMENT': string, * 'PR_DECLARATION': string, * 'PR_KEYWORD': string, * 'PR_LITERAL': string, * 'PR_NOCODE': string, * 'PR_PLAIN': string, * 'PR_PUNCTUATION': string, * 'PR_SOURCE': string, * 'PR_STRING': string, * 'PR_TAG': string, * 'PR_TYPE': string, * 'prettyPrintOne': function (string, string, number|boolean), * 'prettyPrint': function (?function, ?(HTMLElement|HTMLDocument)) * }} * @const */ var PR; /** * Split {@code prettyPrint} into multiple timeouts so as not to interfere with * UI events. * If set to {@code false}, {@code prettyPrint()} is synchronous. */ window['PR_SHOULD_USE_CONTINUATION'] = true; /** * Pretty print a chunk of code. * @param {string} sourceCodeHtml The HTML to pretty print. * @param {string} opt_langExtension The language name to use. * Typically, a filename extension like 'cpp' or 'java'. * @param {number|boolean} opt_numberLines True to number lines, * or the 1-indexed number of the first line in sourceCodeHtml. * @return {string} code as html, but prettier */ var prettyPrintOne; /** * Find all the {@code } and {@code } tags in the DOM with * {@code class=prettyprint} and prettify them. * * @param {Function} opt_whenDone called when prettifying is done. * @param {HTMLElement|HTMLDocument} opt_root an element or document * containing all the elements to pretty print. * Defaults to {@code document.body}. */ var prettyPrint; (function () { var win = window; // Keyword lists for various languages. // We use things that coerce to strings to make them compact when minified // and to defeat aggressive optimizers that fold large string constants. var FLOW_CONTROL_KEYWORDS = [\"break,continue,do,else,for,if,return,while\"]; var C_KEYWORDS = [FLOW_CONTROL_KEYWORDS,\"auto,case,char,const,default,\" + \"double,enum,extern,float,goto,inline,int,long,register,restrict,short,signed,\" + \"sizeof,static,struct,switch,typedef,union,unsigned,void,volatile\"]; var COMMON_KEYWORDS = [C_KEYWORDS,\"catch,class,delete,false,import,\" + \"new,operator,private,protected,public,this,throw,true,try,typeof\"]; var CPP_KEYWORDS = [COMMON_KEYWORDS,\"alignas,alignof,align_union,asm,axiom,bool,\" + \"concept,concept_map,const_cast,constexpr,decltype,delegate,\" + \"dynamic_cast,explicit,export,friend,generic,late_check,\" + \"mutable,namespace,noexcept,noreturn,nullptr,property,reinterpret_cast,static_assert,\" + \"static_cast,template,typeid,typename,using,virtual,where\"]; var JAVA_KEYWORDS = [COMMON_KEYWORDS, \"abstract,assert,boolean,byte,extends,finally,final,implements,import,\" + \"instanceof,interface,null,native,package,strictfp,super,synchronized,\" + \"throws,transient\"]; var CSHARP_KEYWORDS = [COMMON_KEYWORDS, \"abstract,add,alias,as,ascending,async,await,base,bool,by,byte,checked,decimal,delegate,descending,\" + \"dynamic,event,finally,fixed,foreach,from,get,global,group,implicit,in,interface,\" + \"internal,into,is,join,let,lock,null,object,out,override,orderby,params,\" + \"partial,readonly,ref,remove,sbyte,sealed,select,set,stackalloc,string,select,uint,ulong,\" + \"unchecked,unsafe,ushort,value,var,virtual,where,yield\"]; var COFFEE_KEYWORDS = \"all,and,by,catch,class,else,extends,false,finally,\" + \"for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,\" + \"throw,true,try,unless,until,when,while,yes\"; var JSCRIPT_KEYWORDS = [COMMON_KEYWORDS, \"abstract,async,await,constructor,debugger,enum,eval,export,function,\" + \"get,implements,instanceof,interface,let,null,set,undefined,var,with,\" + \"yield,Infinity,NaN\"]; var PERL_KEYWORDS = \"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,\" + \"goto,if,import,last,local,my,next,no,our,print,package,redo,require,\" + \"sub,undef,unless,until,use,wantarray,while,BEGIN,END\"; var PYTHON_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"and,as,assert,class,def,del,\" + \"elif,except,exec,finally,from,global,import,in,is,lambda,\" + \"nonlocal,not,or,pass,print,raise,try,with,yield,\" + \"False,True,None\"]; var RUBY_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"alias,and,begin,case,class,\" + \"def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,\" + \"rescue,retry,self,super,then,true,undef,unless,until,when,yield,\" + \"BEGIN,END\"]; var SH_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"case,done,elif,esac,eval,fi,\" + \"function,in,local,set,then,until\"]; var ALL_KEYWORDS = [ CPP_KEYWORDS, CSHARP_KEYWORDS, JAVA_KEYWORDS, JSCRIPT_KEYWORDS, PERL_KEYWORDS, PYTHON_KEYWORDS, RUBY_KEYWORDS, SH_KEYWORDS]; var C_TYPES = /^(DIR|FILE|array|vector|(de|priority_)?queue|(forward_)?list|stack|(const_)?(reverse_)?iterator|(unordered_)?(multi)?(set|map)|bitset|u?(int|float)\\d*)\\b/; // token style names. correspond to css classes /** * token style for a string literal * @const */ var PR_STRING = 'str'; /** * token style for a keyword * @const */ var PR_KEYWORD = 'kwd'; /** * token style for a comment * @const */ var PR_COMMENT = 'com'; /** * token style for a type * @const */ var PR_TYPE = 'typ'; /** * token style for a literal value. e.g. 1, null, true. * @const */ var PR_LITERAL = 'lit'; /** * token style for a punctuation string. * @const */ var PR_PUNCTUATION = 'pun'; /** * token style for plain text. * @const */ var PR_PLAIN = 'pln'; /** * token style for an sgml tag. * @const */ var PR_TAG = 'tag'; /** * token style for a markup declaration such as a DOCTYPE. * @const */ var PR_DECLARATION = 'dec'; /** * token style for embedded source. * @const */ var PR_SOURCE = 'src'; /** * token style for an sgml attribute name. * @const */ var PR_ATTRIB_NAME = 'atn'; /** * token style for an sgml attribute value. * @const */ var PR_ATTRIB_VALUE = 'atv'; /** * A class that indicates a section of markup that is not code, e.g. to allow * embedding of line numbers within code listings. * @const */ var PR_NOCODE = 'nocode'; /** * A set of tokens that can precede a regular expression literal in * javascript * http://web.archive.org/web/20070717142515/http://www.mozilla.org/js/language/js20/rationale/syntax.html * has the full list, but I've removed ones that might be problematic when * seen in languages that don't support regular expression literals. * * Specifically, I've removed any keywords that can't precede a regexp * literal in a syntactically legal javascript program, and I've removed the * \"in\" keyword since it's not a keyword in many languages, and might be used * as a count of inches. * * The link above does not accurately describe EcmaScript rules since * it fails to distinguish between (a=++/b/i) and (a++/b/i) but it works * very well in practice. * * @private * @const */ var REGEXP_PRECEDER_PATTERN = '(?:^^\\\\.?|[+-]|[!=]=?=?|\\\\#|%=?|&&?=?|\\\\(|\\\\*=?|[+\\\\-]=|->|\\\\/=?|::?|?>?=?|,|;|\\\\?|@|\\\\[|~|{|\\\\^\\\\^?=?|\\\\|\\\\|?=?|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\\\\s*'; // CAVEAT: this does not properly handle the case where a regular // expression immediately follows another since a regular expression may // have flags for case-sensitivity and the like. Having regexp tokens // adjacent is not valid in any language I'm aware of, so I'm punting. // TODO: maybe style special characters inside a regexp as punctuation. /** * Given a group of {@link RegExp}s, returns a {@code RegExp} that globally * matches the union of the sets of strings matched by the input RegExp. * Since it matches globally, if the input strings have a start-of-input * anchor (/^.../), it is ignored for the purposes of unioning. * @param {Array.} regexs non multiline, non-global regexs. * @return {RegExp} a global regex. */ function combinePrefixPatterns(regexs) { var capturedGroupIndex = 0; var needToFoldCase = false; var ignoreCase = false; for (var i = 0, n = regexs.length; i < n; ++i) { var regex = regexs[i]; if (regex.ignoreCase) { ignoreCase = true; } else if (/[a-z]/i.test(regex.source.replace( /\\\\u[0-9a-f]{4}|\\\\x[0-9a-f]{2}|\\\\[^ux]/gi, ''))) { needToFoldCase = true; ignoreCase = false; break; } } var escapeCharToCodeUnit = { 'b': 8, 't': 9, 'n': 0xa, 'v': 0xb, 'f': 0xc, 'r': 0xd }; function decodeEscape(charsetPart) { var cc0 = charsetPart.charCodeAt(0); if (cc0 !== 92 /* \\\\ */) { return cc0; } var c1 = charsetPart.charAt(1); cc0 = escapeCharToCodeUnit[c1]; if (cc0) { return cc0; } else if ('0' = 0;) { shortcuts[shortcutChars.charAt(c)] = patternParts; } } var regex = patternParts[1]; var k = '' + regex; if (!regexKeys.hasOwnProperty(k)) { allRegexs.push(regex); regexKeys[k] = null; } } allRegexs.push(/[\\0-\\uffff]/); tokenizer = combinePrefixPatterns(allRegexs); })(); var nPatterns = fallthroughStylePatterns.length; /** * Lexes job.sourceCode and attaches an output array job.decorations of * style classes preceded by the position at which they start in * job.sourceCode in order. * * @type{function (JobT)} */ var decorate = function (job) { var sourceCode = job.sourceCode, basePos = job.basePos; var sourceNode = job.sourceNode; /** Even entries are positions in source in ascending order. Odd enties * are style markers (e.g., PR_COMMENT) that run from that position until * the end. * @type {DecorationsT} */ var decorations = [basePos, PR_PLAIN]; var pos = 0; // index into sourceCode var tokens = sourceCode.match(tokenizer) || []; var styleCache = {}; for (var ti = 0, nTokens = tokens.length; ti < nTokens; ++ti) { var token = tokens[ti]; var style = styleCache[token]; var match = void 0; var isEmbedded; if (typeof style === 'string') { isEmbedded = false; } else { var patternParts = shortcuts[token.charAt(0)]; if (patternParts) { match = token.match(patternParts[1]); style = patternParts[0]; } else { for (var i = 0; i < nPatterns; ++i) { patternParts = fallthroughStylePatterns[i]; match = token.match(patternParts[1]); if (match) { style = patternParts[0]; break; } } if (!match) { // make sure that we make progress style = PR_PLAIN; } } isEmbedded = style.length >= 5 && 'lang-' === style.substring(0, 5); if (isEmbedded && !(match && typeof match[1] === 'string')) { isEmbedded = false; style = PR_SOURCE; } if (!isEmbedded) { styleCache[token] = style; } } var tokenStart = pos; pos += token.length; if (!isEmbedded) { decorations.push(basePos + tokenStart, style); } else { // Treat group 1 as an embedded block of source code. var embeddedSource = match[1]; var embeddedSourceStart = token.indexOf(embeddedSource); var embeddedSourceEnd = embeddedSourceStart + embeddedSource.length; if (match[2]) { // If embeddedSource can be blank, then it would match at the // beginning which would cause us to infinitely recurse on the // entire token, so we catch the right context in match[2]. embeddedSourceEnd = token.length - match[2].length; embeddedSourceStart = embeddedSourceEnd - embeddedSource.length; } var lang = style.substring(5); // Decorate the left of the embedded source appendDecorations( sourceNode, basePos + tokenStart, token.substring(0, embeddedSourceStart), decorate, decorations); // Decorate the embedded source appendDecorations( sourceNode, basePos + tokenStart + embeddedSourceStart, embeddedSource, langHandlerForExtension(lang, embeddedSource), decorations); // Decorate the right of the embedded section appendDecorations( sourceNode, basePos + tokenStart + embeddedSourceEnd, token.substring(embeddedSourceEnd), decorate, decorations); } } job.decorations = decorations; }; return decorate; } /** returns a function that produces a list of decorations from source text. * * This code treats \", ', and ` as string delimiters, and \\ as a string * escape. It does not recognize perl's qq() style strings. * It has no special handling for double delimiter escapes as in basic, or * the tripled delimiters used in python, but should work on those regardless * although in those cases a single string literal may be broken up into * multiple adjacent string literals. * * It recognizes C, C++, and shell style comments. * * @param {Object} options a set of optional parameters. * @return {function (JobT)} a function that examines the source code * in the input job and builds a decoration list which it attaches to * the job. */ function sourceDecorator(options) { var shortcutStylePatterns = [], fallthroughStylePatterns = []; if (options['tripleQuotedStrings']) { // '''multi-line-string''', 'single-line-string', and double-quoted shortcutStylePatterns.push( [PR_STRING, /^(?:\\'\\'\\'(?:[^\\'\\\\]|\\\\[\\s\\S]|\\'{1,2}(?=[^\\']))*(?:\\'\\'\\'|$)|\\\"\\\"\\\"(?:[^\\\"\\\\]|\\\\[\\s\\S]|\\\"{1,2}(?=[^\\\"]))*(?:\\\"\\\"\\\"|$)|\\'(?:[^\\\\\\']|\\\\[\\s\\S])*(?:\\'|$)|\\\"(?:[^\\\\\\\"]|\\\\[\\s\\S])*(?:\\\"|$))/, null, '\\'\"']); } else if (options['multiLineStrings']) { // 'multi-line-string', \"multi-line-string\" shortcutStylePatterns.push( [PR_STRING, /^(?:\\'(?:[^\\\\\\']|\\\\[\\s\\S])*(?:\\'|$)|\\\"(?:[^\\\\\\\"]|\\\\[\\s\\S])*(?:\\\"|$)|\\`(?:[^\\\\\\`]|\\\\[\\s\\S])*(?:\\`|$))/, null, '\\'\"`']); } else { // 'single-line-string', \"single-line-string\" shortcutStylePatterns.push( [PR_STRING, /^(?:\\'(?:[^\\\\\\'\\r\\n]|\\\\.)*(?:\\'|$)|\\\"(?:[^\\\\\\\"\\r\\n]|\\\\.)*(?:\\\"|$))/, null, '\"\\'']); } if (options['verbatimStrings']) { // verbatim-string-literal production from the C# grammar. See issue 93. fallthroughStylePatterns.push( [PR_STRING, /^@\\\"(?:[^\\\"]|\\\"\\\")*(?:\\\"|$)/, null]); } var hc = options['hashComments']; if (hc) { if (options['cStyleComments']) { if (hc > 1) { // multiline hash comments shortcutStylePatterns.push( [PR_COMMENT, /^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/, null, '#']); } else { // Stop C preprocessor declarations at an unclosed open comment shortcutStylePatterns.push( [PR_COMMENT, /^#(?:(?:define|e(?:l|nd)if|else|error|ifn?def|include|line|pragma|undef|warning)\\b|[^\\r\\n]*)/, null, '#']); } // #include fallthroughStylePatterns.push( [PR_STRING, /^/, null]); } else { shortcutStylePatterns.push([PR_COMMENT, /^#[^\\r\\n]*/, null, '#']); } } if (options['cStyleComments']) { fallthroughStylePatterns.push([PR_COMMENT, /^\\/\\/[^\\r\\n]*/, null]); fallthroughStylePatterns.push( [PR_COMMENT, /^\\/\\*[\\s\\S]*?(?:\\*\\/|$)/, null]); } var regexLiterals = options['regexLiterals']; if (regexLiterals) { /** * @const */ var regexExcls = regexLiterals > 1 ? '' // Multiline regex literals : '\\n\\r'; /** * @const */ var regexAny = regexExcls ? '.' : '[\\\\S\\\\s]'; /** * @const */ var REGEX_LITERAL = ( // A regular expression literal starts with a slash that is // not followed by * or / so that it is not confused with // comments. '/(?=[^/*' + regexExcls + '])' // and then contains any number of raw characters, + '(?:[^/\\\\x5B\\\\x5C' + regexExcls + ']' // escape sequences (\\x5C), + '|\\\\x5C' + regexAny // or non-nesting character sets (\\x5B\\x5D); + '|\\\\x5B(?:[^\\\\x5C\\\\x5D' + regexExcls + ']' + '|\\\\x5C' + regexAny + ')*(?:\\\\x5D|$))+' // finally closed by a /. + '/'); fallthroughStylePatterns.push( ['lang-regex', RegExp('^' + REGEXP_PRECEDER_PATTERN + '(' + REGEX_LITERAL + ')') ]); } var types = options['types']; if (types) { fallthroughStylePatterns.push([PR_TYPE, types]); } var keywords = (\"\" + options['keywords']).replace(/^ | $/g, ''); if (keywords.length) { fallthroughStylePatterns.push( [PR_KEYWORD, new RegExp('^(?:' + keywords.replace(/[\\s,]+/g, '|') + ')\\\\b'), null]); } shortcutStylePatterns.push([PR_PLAIN, /^\\s+/, null, ' \\r\\n\\t\\xA0']); var punctuation = // The Bash man page says // A word is a sequence of characters considered as a single // unit by GRUB. Words are separated by metacharacters, // which are the following plus space, tab, and newline: { } // | & $ ; < > // ... // A word beginning with # causes that word and all remaining // characters on that line to be ignored. // which means that only a '#' after /(?:^|[{}|&$;\\s])/ starts a // comment but empirically // $ echo // $ echo \\$# // $# // $ echo }# // }# // so /(?:^|[|&;\\s])/ is more appropriate. // http://gcc.gnu.org/onlinedocs/gcc-2.95.3/cpp_1.html#SEC3 // suggests that this definition is compatible with a // default mode that tries to use a single token definition // to recognize both bash/python style comments and C // preprocessor directives. // This definition of punctuation does not include # in the list of // follow-on exclusions, so # will not be broken before if preceeded // by a punctuation character. We could try to exclude # after // [|&;] but that doesn't seem to cause many major problems. // If that does turn out to be a problem, we should change the below // when hc is truthy to include # in the run of punctuation characters // only when not followint [|&;]. '^.[^\\\\s\\\\w.$@\\'\"`/\\\\\\\\]*'; if (options['regexLiterals']) { punctuation += '(?!\\s*\\/)'; } fallthroughStylePatterns.push( // TODO(mikesamuel): recognize non-latin letters and numerals in idents [PR_LITERAL, /^@[a-z_$][a-z_$@0-9]*/i, null], [PR_TYPE, /^(?:[@_]?[A-Z]+[a-z][A-Za-z_$@0-9]*|\\w+_t\\b)/, null], [PR_PLAIN, /^[a-z_$][a-z_$@0-9]*/i, null], [PR_LITERAL, new RegExp( '^(?:' // A hex number + '0x[a-f0-9]+' // or an octal or decimal number, + '|(?:\\\\d(?:_\\\\d+)*\\\\d*(?:\\\\.\\\\d*)?|\\\\.\\\\d\\\\+)' // possibly in scientific notation + '(?:e[+\\\\-]?\\\\d+)?' + ')' // with an optional modifier like UL for unsigned long + '[a-z]*', 'i'), null, '0123456789'], // Don't treat escaped quotes in bash as starting strings. // See issue 144. [PR_PLAIN, /^\\\\[\\s\\S]?/, null], [PR_PUNCTUATION, new RegExp(punctuation), null]); return createSimpleLexer(shortcutStylePatterns, fallthroughStylePatterns); } var decorateSource = sourceDecorator({ 'keywords': ALL_KEYWORDS, 'hashComments': true, 'cStyleComments': true, 'multiLineStrings': true, 'regexLiterals': true }); /** * Given a DOM subtree, wraps it in a list, and puts each line into its own * list item. * * @param {Node} node modified in place. Its content is pulled into an * HTMLOListElement, and each line is moved into a separate list item. * This requires cloning elements, so the input might not have unique * IDs after numbering. * @param {number|null|boolean} startLineNum * If truthy, coerced to an integer which is the 1-indexed line number * of the first line of code. The number of the first line will be * attached to the list. * @param {boolean} isPreformatted true iff white-space in text nodes should * be treated as significant. */ function numberLines(node, startLineNum, isPreformatted) { var nocode = /(?:^|\\s)nocode(?:\\s|$)/; var lineBreak = /\\r\\n?|\\n/; var document = node.ownerDocument; var li = document.createElement('li'); while (node.firstChild) { li.appendChild(node.firstChild); } // An array of lines. We split below, so this is initialized to one // un-split line. var listItems = [li]; function walk(node) { var type = node.nodeType; if (type == 1 && !nocode.test(node.className)) { // Element if ('br' === node.nodeName) { breakAfter(node); // Discard the since it is now flush against a . if (node.parentNode) { node.parentNode.removeChild(node); } } else { for (var child = node.firstChild; child; child = child.nextSibling) { walk(child); } } } else if ((type == 3 || type == 4) && isPreformatted) { // Text var text = node.nodeValue; var match = text.match(lineBreak); if (match) { var firstLine = text.substring(0, match.index); node.nodeValue = firstLine; var tail = text.substring(match.index + match[0].length); if (tail) { var parent = node.parentNode; parent.insertBefore( document.createTextNode(tail), node.nextSibling); } breakAfter(node); if (!firstLine) { // Don't leave blank text nodes in the DOM. node.parentNode.removeChild(node); } } } } // Split a line after the given node. function breakAfter(lineEndNode) { // If there's nothing to the right, then we can skip ending the line // here, and move root-wards since splitting just before an end-tag // would require us to create a bunch of empty copies. while (!lineEndNode.nextSibling) { lineEndNode = lineEndNode.parentNode; if (!lineEndNode) { return; } } function breakLeftOf(limit, copy) { // Clone shallowly if this node needs to be on both sides of the break. var rightSide = copy ? limit.cloneNode(false) : limit; var parent = limit.parentNode; if (parent) { // We clone the parent chain. // This helps us resurrect important styling elements that cross lines. // E.g. in FooBar // should be rewritten to FooBar. var parentClone = breakLeftOf(parent, 1); // Move the clone and everything to the right of the original // onto the cloned parent. var next = limit.nextSibling; parentClone.appendChild(rightSide); for (var sibling = next; sibling; sibling = next) { next = sibling.nextSibling; parentClone.appendChild(sibling); } } return rightSide; } var copiedListItem = breakLeftOf(lineEndNode.nextSibling, 0); // Walk the parent chain until we reach an unattached LI. for (var parent; // Check nodeType since IE invents document fragments. (parent = copiedListItem.parentNode) && parent.nodeType === 1;) { copiedListItem = parent; } // Put it on the list of lines for later processing. listItems.push(copiedListItem); } // Split lines while there are lines left to split. for (var i = 0; // Number of lines that have been split so far. i < listItems.length; // length updated by breakAfter calls. ++i) { walk(listItems[i]); } // Make sure numeric indices show correctly. if (startLineNum === (startLineNum|0)) { listItems[0].setAttribute('value', startLineNum); } var ol = document.createElement('ol'); ol.className = 'linenums'; var offset = Math.max(0, ((startLineNum - 1 /* zero index */)) | 0) || 0; for (var i = 0, n = listItems.length; i < n; ++i) { li = listItems[i]; // Stick a class on the LIs so that stylesheets can // color odd/even rows, or any other row pattern that // is co-prime with 10. li.className = 'L' + ((i + offset) % 10); if (!li.firstChild) { li.appendChild(document.createTextNode('\\xA0')); } ol.appendChild(li); } node.appendChild(ol); } /** * Breaks {@code job.sourceCode} around style boundaries in * {@code job.decorations} and modifies {@code job.sourceNode} in place. * @param {JobT} job * @private */ function recombineTagsAndDecorations(job) { var isIE8OrEarlier = /\\bMSIE\\s(\\d+)/.exec(navigator.userAgent); isIE8OrEarlier = isIE8OrEarlier && +isIE8OrEarlier[1]"}],"posts":[{"title":"使用redis+lettuce实现消息队列和生产消费","slug":"使用redis-lettuce实现消息队列和生产消费","date":"2020-01-29T01:05:52.000Z","updated":"2021-03-03T02:50:12.463Z","comments":true,"path":"2020/01/29/使用redis-lettuce实现消息队列和生产消费/","link":"","permalink":"http://sinlapis.github.io/2020/01/29/使用redis-lettuce实现消息队列和生产消费/","excerpt":"","text":"准备安装redis使用Docker部署redis docker run --name redis-mq -d -p 6379:6379 redis redis-server --appendonly yes 创建stream和group安装redis-cli apt install -y redis-cli 进入redis-cli redis-cli -h localhost -p 6379 创建空的stream和对应的group xgroup create testTask testGroup $ mkstream 代码实现配置依赖使用lettuce作为redis连接库 dependencies { implementation(kotlin(\"stdlib-jdk8\")) implementation(\"io.lettuce:lettuce-core:5.2.1.RELEASE\") } 生产者fun consume() { val client = RedisClient.create(\"redis://192.168.75.120:6379/0\") val connection = client.connect() val commands = connection.sync() val consumer = io.lettuce.core.Consumer.from(\"testGroup\", \"testTask\") val content = commands.xreadgroup( consumer, XReadArgs.StreamOffset.lastConsumed(\"testTask\") ) println(content.size) for (c in content) { for (k in c.body.keys) { println(\"$k: ${c.body[k]}\") } } } 消费者fun main() { val client = RedisClient.create(\"redis://192.168.75.120:6379/0\") val connection = client.connect() val commands = connection.sync() val body = HashMap&lt;String, String>() for (i in 1..10) { body[i.toString()] = \"test\" } commands.xadd(\"testTask\", body) }","categories":[{"name":"redis","slug":"redis","permalink":"http://sinlapis.github.io/categories/redis/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"http://sinlapis.github.io/tags/kotlin/"},{"name":"redis","slug":"redis","permalink":"http://sinlapis.github.io/tags/redis/"},{"name":"lettuce","slug":"lettuce","permalink":"http://sinlapis.github.io/tags/lettuce/"}]},{"title":"使用Gradle打包Kotlin代码以及所有依赖","slug":"使用Gradle打包Kotlin代码以及所有依赖","date":"2020-01-14T02:27:12.000Z","updated":"2021-03-03T02:50:12.463Z","comments":true,"path":"2020/01/14/使用Gradle打包Kotlin代码以及所有依赖/","link":"","permalink":"http://sinlapis.github.io/2020/01/14/使用Gradle打包Kotlin代码以及所有依赖/","excerpt":"","text":"使用插件Shadow进行打包。build.gradle如下： plugins { id 'org.jetbrains.kotlin.jvm' version '1.3.61' id 'com.github.johnrengelman.shadow' version '5.2.0' } group 'org.example' version '1.0-SNAPSHOT' repositories { mavenCentral() jcenter() } dependencies { implementation \"org.jetbrains.kotlin:kotlin-stdlib-jdk8\" implementation \"org.apache.kafka:kafka-clients:2.4.0\" implementation \"org.apache.kafka:kafka-streams:2.4.0\" implementation \"org.apache.logging.log4j:log4j-api:2.13.0\" implementation \"org.apache.logging.log4j:log4j-core:2.13.0\" implementation \"org.slf4j:slf4j-log4j12:1.7.30\" } compileKotlin { kotlinOptions.jvmTarget = \"1.8\" } compileTestKotlin { kotlinOptions.jvmTarget = \"1.8\" } jar { manifest { attributes \"Main-Class\": \"org.example.testK8s.MainKt\" } } 之后执行下面的指令（或者在IDEA右侧的Gradle面板可以找到）进行打包： gradle shadowJar","categories":[{"name":"杂项","slug":"杂项","permalink":"http://sinlapis.github.io/categories/杂项/"}],"tags":[{"name":"Gradle","slug":"Gradle","permalink":"http://sinlapis.github.io/tags/Gradle/"},{"name":"Kotlin","slug":"Kotlin","permalink":"http://sinlapis.github.io/tags/Kotlin/"}]},{"title":"使用Java/Kotlin等外部消费者无法消费Kafka消息","slug":"使用Java-Kotlin等外部消费者无法消费Kafka消息","date":"2020-01-14T02:07:57.000Z","updated":"2021-03-03T02:50:12.463Z","comments":true,"path":"2020/01/14/使用Java-Kotlin等外部消费者无法消费Kafka消息/","link":"","permalink":"http://sinlapis.github.io/2020/01/14/使用Java-Kotlin等外部消费者无法消费Kafka消息/","excerpt":"","text":"问题有一Kafka集群，在集群内机器上生产消费消息均正常，但是使用外部机器（未部署Kafka）无法消费。 解决在Kafka配置server.properties中加入字段： port=9092 advertised.host.name=192.168.226.10","categories":[{"name":"杂项","slug":"杂项","permalink":"http://sinlapis.github.io/categories/杂项/"}],"tags":[{"name":"Kafka","slug":"Kafka","permalink":"http://sinlapis.github.io/tags/Kafka/"}]},{"title":"使用K8s和Kafka实现工作队列的并行处理","slug":"使用K8s和Kafka实现工作队列的并行处理","date":"2020-01-10T06:34:12.000Z","updated":"2021-03-03T02:50:12.463Z","comments":true,"path":"2020/01/10/使用K8s和Kafka实现工作队列的并行处理/","link":"","permalink":"http://sinlapis.github.io/2020/01/10/使用K8s和Kafka实现工作队列的并行处理/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"使用K3s搭建Kubernetes集群","slug":"使用K3s搭建Kubernetes集群","date":"2020-01-09T03:07:46.000Z","updated":"2021-03-03T02:50:12.463Z","comments":true,"path":"2020/01/09/使用K3s搭建Kubernetes集群/","link":"","permalink":"http://sinlapis.github.io/2020/01/09/使用K3s搭建Kubernetes集群/","excerpt":"","text":"使用K3s搭建Kubernetes集群主要参考你的第一次轻量级K8S体验 —— 记一次Rancher 2.2 + K3S集成部署过程 需要至少2台机器。 当前各软件版本为： 软件名 版本 Docker 18.09.9 K3s v1.17.0+k3s.1 rancher v2.3.3 Docker安装直接参考官方文档 安装依赖使apt可以使用HTTPS的仓库 apt install -y \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg-agent \\ software-properties-common 添加Docker官方的GPG密钥 curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 添加Docker稳定版仓库 add-apt-repository \\ \"deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) \\ stable\" 更新apt索引 apt update 安装Docker apt-get install -y docker-ce docker-ce-cli containerd.io 配置registry docker pull registry:2 docker run -d -p 5000:5000 --restart=always --name registry \\ -v /var/data:/var/lib/registry registry:2 修改Docker配置/etc/docker/daemon.json { \"insecure-registries\" : [\"192.168.226.11:5000\"] } rancher安装选择一台安装rancher server，这台不安装k3s，好像会有冲突。 docker run -d -v /data/docker/rancher-server/var/lib/rancher/:/var/lib/rancher/ --restart=unless-stopped --name rancher-server -p 80:80 -p 443:443 rancher/rancher:stable 之后访问http://192.168.226.10/（改成自己的ip）进行初始化部署。设定密码和地址后，可选切换语言。 选择添加集群 -&gt; 导入，输入集群名，然后点击创建。保存最后一条指令，记得在kubectl前添加k3s。 k3s安装到k3s - Releases下载k3s文件（约50MB的那个），上传至/usr/local/bin/，并执行下面指令 chmod +x /usr/local/bin/k3s 下载pause镜像 docker pull kubernetes/pause:latest docker tag kubernetes/pause:latest k8s.gcr.io/pause 执行官方安装脚本 curl -sfL https://get.k3s.io | sh - 配置容器引擎使用Docker vim /etc/systemd/system/multi-user.target.wants/k3s.service 在文件中ExecStart字段最后一个\\后添加一行，并填入--docker，类似下面 ExecStart=/usr/local/bin/k3s \\ server \\ --docker 保存配置并重启k3s systemctl daemon-reload systemctl restart k3s 执行之前保存的指令，注意不要直接使用下面的样例，主机地址和yaml文件名要使用刚才生成的。 curl --insecure -sfL https://192.168.226.11/v3/import/nb4hcqpzsvggwhcsfgpj5vjss8s2wsqbhv82d72s68hx8cf6gfzhsj.yaml | k3s kubectl apply -f - 稍等一会界面就会出现节点状态。 容器执行测试参考Kubernetes官方文档 先准备一个镜像 docker pull busybox docker tag busybox:latest 192.168.226.11:5000/busybox:latest docker push 192.168.226.11:5000/busybox:latest 假设现在我们从私有仓库拉取一个镜像并执行。 创建job.yaml文件 apiVersion: batch/v1beta1 kind: CronJob metadata: name: hello spec: schedule: \"*/1 * * * *\" jobTemplate: spec: template: spec: containers: - name: hello image: 192.168.226.11:5000/busybox args: - /bin/sh - -c - date; echo Hello from the Kubernetes cluster restartPolicy: OnFailure 创建Job k3s kubectl create -f job.yaml 查看Job状态 kubectl get cronjob hello 查看Job创建的Pod kubectl get jobs 选择上面的一个已完成的pod的id，例如hello-1578545280。获取这个pod的输出 pods=$(kubectl get pods --selector=job-name=hello-1578545280 --output=jsonpath={.items[*].metadata.name}) kubectl logs $pods 添加节点新节点同样先安装Docker。安装k3s按如下步骤。 查看主节点的node-token cat /var/lib/rancher/k3s/server/node-token 在新节点上安装并启动为普通节点，注意ip地址和token改成自己的。 curl -sfL https://get.k3s.io | K3S_URL=https://192.168.226.11:6443 K3S_TOKEN=K105933dce21eca704fb3913c26976e0c13c36878fc0c846a0780915c12fccdd78e::server:1a8e2a73e1247868ccb5b3ce0b3cbc7e sh - 同样需要配置容器引擎使用Docker vim /etc/systemd/system/multi-user.target.wants/k3s-agent.service 修改方式和主节点一样，然后重启k3s-agent，在rancher界面即可看到新加入的节点。","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"http://sinlapis.github.io/categories/Kubernetes/"}],"tags":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"http://sinlapis.github.io/tags/Kubernetes/"},{"name":"k8s","slug":"k8s","permalink":"http://sinlapis.github.io/tags/k8s/"},{"name":"docker","slug":"docker","permalink":"http://sinlapis.github.io/tags/docker/"},{"name":"k3s","slug":"k3s","permalink":"http://sinlapis.github.io/tags/k3s/"}]},{"title":"microk8s部署多节点k8s集群","slug":"microk8s部署多节点k8s集群","date":"2019-12-31T02:14:42.000Z","updated":"2021-03-03T02:50:12.463Z","comments":true,"path":"2019/12/31/microk8s部署多节点k8s集群/","link":"","permalink":"http://sinlapis.github.io/2019/12/31/microk8s部署多节点k8s集群/","excerpt":"","text":"microk8s部署多节点Kubernetes集群为了增加工作量，想上一个k8s。microk8s安装简单还支持多节点，就选它了。 准备和安装snap没有换源一说，只能设置代理。 先设置systemd editor的默认编辑器为vim vim /etc/profile 加入以下内容 export SYSTEMD_EDITOR=\"/usr/bin/vim\" 使设置生效 source /etc/profile 配置snapd systemctl edit snapd 加入以下内容 [Service] Environment=\"http_proxy=http://127.0.0.1:1080\" Environment=\"https_proxy=http://127.0.0.1:1080\" 配置生效 systemctl daemon-reload systemctl restart snapd 安装microk8s snap install microk8s --classic 查看组件状态 > microk8s.status microk8s is running addons: cilium: disabled dashboard: disabled dns: disabled fluentd: disabled gpu: disabled helm: disabled ingress: disabled istio: disabled jaeger: disabled juju: disabled knative: disabled kubeflow: disabled linkerd: disabled metallb: disabled metrics-server: disabled prometheus: disabled rbac: disabled registry: disabled storage: disabled 构建多节点集群在一台机器上执行 microk8s.add-node 会出现以下内容 Join node with: microk8s.join ip-172-31-20-243:25000/DDOkUupkmaBezNnMheTBqFYHLWINGDbf 复制join指令到其它已经安装了microk8s的机器上执行。 查看集群内节点 > microk8s.kubectl get no 10.22.254.79 Ready 27s v1.15.3 ip-172-31-20-243 Ready 53s v1.15.3","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"http://sinlapis.github.io/categories/Kubernetes/"}],"tags":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"http://sinlapis.github.io/tags/Kubernetes/"},{"name":"k8s","slug":"k8s","permalink":"http://sinlapis.github.io/tags/k8s/"},{"name":"docker","slug":"docker","permalink":"http://sinlapis.github.io/tags/docker/"},{"name":"microk8s","slug":"microk8s","permalink":"http://sinlapis.github.io/tags/microk8s/"}]},{"title":"kotlin+puppeteer写爬虫","slug":"kotlin-puppeteer写爬虫","date":"2019-12-11T09:00:58.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2019/12/11/kotlin-puppeteer写爬虫/","link":"","permalink":"http://sinlapis.github.io/2019/12/11/kotlin-puppeteer写爬虫/","excerpt":"","text":"kotlin + puppeteer写爬虫环境搞的很郁闷，这个代码倒是简单解决了，多亏了一位日本老哥。 主要参考：バックグラウンドで使うpuppeteer with Kotlin 环境准备build.gradle中添加： dependencies { implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core-js:1.1.1' } 让kotlin使用async/await接口有变动，参考中代码部分失效。 import kotlin.coroutines.* import kotlin.js.Promise suspend fun &lt;T> Promise&lt;T>.await(): T = suspendCoroutine { cont -> then({ cont.resume(it) }, { cont.resumeWithException(it) }) } fun &lt;T> async(x: suspend () -> T): Promise&lt;T> { return Promise { resolve, reject -> x.startCoroutine(object : Continuation&lt;T> { override val context = EmptyCoroutineContext override fun resumeWith(result: Result&lt;T>) { if (result.isSuccess) resolve(result.getOrNull()!!) else reject(result.exceptionOrNull()!!) } }) } } 封装puppeteer接口import kotlin.js.Promise @Suppress(\"FunctionName\") @JsModule(\"puppeteer\") external object Puppeteer { class Page { fun goto(url: String, options: dynamic): Promise&lt;dynamic> fun waitFor(element: String, options: dynamic): Promise&lt;dynamic> fun waitFor(num: Int): Promise&lt;dynamic> fun content(): Promise&lt;dynamic> fun click(selector: dynamic): Promise&lt;dynamic> fun close(): Promise&lt;dynamic> fun evaluate(pageFunction: Function&lt;dynamic>): Promise&lt;dynamic> } class Browser { fun newPage(): Promise&lt;Page> fun close(): Promise&lt;dynamic> fun wsEndpoint(): String } fun launch(options: dynamic): Promise&lt;Browser> } 爬虫代码fun main() { async { val browser = Puppeteer.launch(object {}.also { it: dynamic -> it.devtools = true it.args = arrayOf(\"--no-sandbox\", \"--disable-setuid-sandbox\") it.headless = true }).await() try { val page = browser.newPage().await() page.goto(\"http://www.baidu.com\", object {}.also { it: dynamic -> it.timeout = 10 * 1000 }).await() page.waitFor(1000).await() val content = page.content().await() println(content.toString()) } finally { browser.close().await() } } } 注意it.headless = true为开启Chrome的Headless模式，需要显示界面调试置为false即可。","categories":[{"name":"杂项","slug":"杂项","permalink":"http://sinlapis.github.io/categories/杂项/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"http://sinlapis.github.io/tags/kotlin/"},{"name":"爬虫","slug":"爬虫","permalink":"http://sinlapis.github.io/tags/爬虫/"},{"name":"puppeteer","slug":"puppeteer","permalink":"http://sinlapis.github.io/tags/puppeteer/"}]},{"title":"kotlin+nodejs+idea+gradle项目构建","slug":"kotlin-nodejs-idea-gradle项目构建","date":"2019-12-11T07:21:40.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2019/12/11/kotlin-nodejs-idea-gradle项目构建/","link":"","permalink":"http://sinlapis.github.io/2019/12/11/kotlin-nodejs-idea-gradle项目构建/","excerpt":"","text":"kotlin + nodejs + idea + gradle项目构建kotlin转nodejs的插件只能用gradle，maven虽然也有但是不会用。这玩意我居然搞了一天才看到”Hello, JavaScript!”，人老了。 主要参考：基于 Node.js 环境的 KotlinJs 工程的完美搭建。 创建项目现在nodejs已经是IDEA中自带插件了，不再需要手动安装。直接创建项目，选gradle -&gt; kotlin(JavaScript)。 之后需要等IDEA将项目配置完毕。 配置build.gradlegroup 'org.ndp' version '1' buildscript { ext.kotlin_version = '1.3.60' repositories { mavenCentral() } dependencies { classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\" } } apply plugin: 'kotlin2js' buildscript { repositories { maven { url \"https://dl.bintray.com/kotlin/kotlin-eap\" } } dependencies { classpath \"org.jetbrains.kotlin:kotlin-frontend-plugin:0.0.45\" } } apply plugin: 'org.jetbrains.kotlin.frontend' repositories { mavenCentral() } dependencies { compile \"org.jetbrains.kotlin:kotlin-stdlib-js:$kotlin_version\" } compileKotlin2Js { kotlinOptions.moduleKind = \"commonjs\" kotlinOptions.sourceMap = true kotlinOptions.metaInfo = true } kotlinFrontend { npm { devDependency \"karma\" // development dependency } } 之后需要静待gradle配置好，时间比较长。 不要在compileKotlin2Js中设置输出目录，会导致Error: Cannot find module &#39;kotlin&#39;。 编写Kotlin在src/main/kotlin/下新建kt文件： fun main(args: Array&lt;String>) { println(\"Hello JavaScript!\") } 点击main旁边的运行即可看到结果。","categories":[{"name":"杂项","slug":"杂项","permalink":"http://sinlapis.github.io/categories/杂项/"}],"tags":[{"name":"idea","slug":"idea","permalink":"http://sinlapis.github.io/tags/idea/"},{"name":"gradle","slug":"gradle","permalink":"http://sinlapis.github.io/tags/gradle/"},{"name":"nodejs","slug":"nodejs","permalink":"http://sinlapis.github.io/tags/nodejs/"},{"name":"kotlin","slug":"kotlin","permalink":"http://sinlapis.github.io/tags/kotlin/"}]},{"title":"maven的kotlin项目打包以及添加kotlin依赖","slug":"maven的kotlin项目打包以及添加kotlin依赖","date":"2019-12-02T08:09:38.000Z","updated":"2021-03-03T02:50:12.463Z","comments":true,"path":"2019/12/02/maven的kotlin项目打包以及添加kotlin依赖/","link":"","permalink":"http://sinlapis.github.io/2019/12/02/maven的kotlin项目打包以及添加kotlin依赖/","excerpt":"","text":"maven的kotlin项目打包以及添加kotlin依赖准备了一个纯jre的docker镜像，想运行kotlin的jar包，结果找了一圈还是在官网找到了解决办法。 不包含kotlin依赖在pom.xml中build -&gt; plugins中添加 &lt;plugin> &lt;groupId>org.apache.maven.plugins&lt;/groupId> &lt;artifactId>maven-jar-plugin&lt;/artifactId> &lt;version>2.6&lt;/version> &lt;configuration> &lt;archive> &lt;manifest> &lt;addClasspath>true&lt;/addClasspath> &lt;mainClass>${main.class}&lt;/mainClass> &lt;/manifest> &lt;/archive> &lt;/configuration> &lt;/plugin> 包含kotlin依赖在pom.xml中build -&gt; plugins中添加 &lt;plugin> &lt;groupId>org.apache.maven.plugins&lt;/groupId> &lt;artifactId>maven-assembly-plugin&lt;/artifactId> &lt;version>2.6&lt;/version> &lt;executions> &lt;execution> &lt;id>make-assembly&lt;/id> &lt;phase>package&lt;/phase> &lt;goals> &lt;goal>single&lt;/goal> &lt;/goals> &lt;configuration> &lt;archive> &lt;manifest> &lt;mainClass>${main.class}&lt;/mainClass> &lt;/manifest> &lt;/archive> &lt;descriptorRefs> &lt;descriptorRef>jar-with-dependencies&lt;/descriptorRef> &lt;/descriptorRefs> &lt;/configuration> &lt;/execution> &lt;/executions> &lt;/plugin>","categories":[{"name":"杂项","slug":"杂项","permalink":"http://sinlapis.github.io/categories/杂项/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"http://sinlapis.github.io/tags/kotlin/"},{"name":"maven","slug":"maven","permalink":"http://sinlapis.github.io/tags/maven/"}]},{"title":"React0x00","slug":"React0x00","date":"2019-10-28T08:31:07.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2019/10/28/React0x00/","link":"","permalink":"http://sinlapis.github.io/2019/10/28/React0x00/","excerpt":"","text":"Hello, world!创建项目直接使用Webstorm，选择React App。然后执行： react-scripts eject 清空src中的文件，重新建立文件index.js，即React入口， 输入： import React from 'react' import ReactDOM from 'react-dom' ReactDOM.render( &lt;h1>Hello, world!&lt;/h1>, document.getElementById('root') ); render的第一个参数为jsx，可以理解为React的元素，可以作为js变量的值。 import React from 'react' import ReactDOM from 'react-dom' const ele = &lt;h1>Hello, world!&lt;/h1>; ReactDOM.render( ele, document.getElementById('root') ); 创建组件箭头函数import React from 'react' import ReactDOM from 'react-dom' const Ele = (props) => { return &lt;h1>Hello, {props.title}!&lt;/h1> }; ReactDOM.render( &lt;Ele title=\"React\" />, document.querySelector('#root') ); 类import React from 'react' import ReactDOM from 'react-dom' class Ele extends React.Component { render() { return ( &lt;div> &lt;h1>class app&lt;/h1> &lt;p>{this.props.title}&lt;/p> &lt;/div> ) } } ReactDOM.render( &lt;Ele title=\"arg\"/>, document.querySelector('#root') ); 组件嵌套import React from 'react' import ReactDOM from 'react-dom' const Title = () => &lt;h1>app title&lt;/h1>; class Ele extends React.Component { render() { return ( &lt;div> &lt;Title /> &lt;p>{this.props.title}&lt;/p> &lt;/div> ) } } ReactDOM.render( &lt;Ele title=\"test arg\"/>, document.querySelector('#root') ); 组件样式使用jsconst Title = () => &lt;h1 style={{color: '#0099ff'}}>app title&lt;/h1>; 使用class.blue-title { color: #0099ff; } import './index.css' const Title = () => &lt;h1 className=\"blue-title\">app title&lt;/h1>; 使用第三方库classnames安装。 npm i -D classnames .blue-title { color: #0099ff; } .red-title { color: #ff6666; } .bg { background-color: antiquewhite; } import './index.css' import classNames from 'classnames' const Title = () => &lt;h1 className={classNames('bg', {'blue-title': true, 'red-title': false})}>app title&lt;/h1>;","categories":[{"name":"React","slug":"React","permalink":"http://sinlapis.github.io/categories/React/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://sinlapis.github.io/tags/前端/"},{"name":"React","slug":"React","permalink":"http://sinlapis.github.io/tags/React/"}]},{"title":"less基础","slug":"less基础","date":"2019-10-23T02:23:38.000Z","updated":"2021-03-03T02:50:12.463Z","comments":true,"path":"2019/10/23/less基础/","link":"","permalink":"http://sinlapis.github.io/2019/10/23/less基础/","excerpt":"","text":"less基础再摸一个less。 编译使用node.js中less编译。 npm i -D less lessc test.less test.css 注释//不会出现在css文件中，/* */会。 变量支持选择器、属性和属性值。选择器和属性在引用时要使用{}，但一般只使用值作为变量。 @mainColor: aliceblue; @attr: color; @selector: body; @{selector} { @{attr}: @mainColor; } less中变量的作用域是块级，并且会延迟加载，即会在块执行完毕后才看变量值。 嵌套less可以实现类似html中的嵌套。 &lt;!DOCTYPE html> &lt;html lang=\"zh\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>&lt;%= htmlWebpackPlugin.options.title %>&lt;/title> &lt;/head> &lt;body> &lt;div id=\"root\"> outer &lt;h1>test word.&lt;/h1> &lt;h1 class=\"green\">hello, world!&lt;/h1> &lt;/div> &lt;/body> &lt;/html> @mainColor: aliceblue; body { color: @mainColor; h1 { color: coral; } .green { color: aqua; } } 设置元素状态时需要修正嵌套级别。 @mainColor: aliceblue; body { color: @mainColor; h1 { color: coral; } .green { color: aqua; &amp;:hover { color: #66cccc; } } } 混合可以理解为less的方法？ 可以省去大段重复css代码。 &lt;!DOCTYPE html> &lt;html lang=\"zh\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>&lt;%= htmlWebpackPlugin.options.title %>&lt;/title> &lt;/head> &lt;body> &lt;div id=\"root\"> outer &lt;h1 id=\"text1\">test word.&lt;/h1> &lt;h1 id=\"text2\">hello, world!&lt;/h1> &lt;/div> &lt;/body> &lt;/html> @mainColor: aliceblue; .textHover { color: aqua; &amp;:hover { color: #66cccc; } } body { color: @mainColor; h1 { color: coral; } #text1, #text2 { .textHover; } } 混合的css会输出到编译后的css文件里，会有重复，可以使用如下的方式来避免。 @mainColor: aliceblue; .textHover() { color: aqua; &amp;:hover { color: #66cccc; } } body { color: @mainColor; h1 { color: coral; } #text1, #text2 { .textHover; } } 混合可以带有参数。 @mainColor: aliceblue; .textHover(@origin, @hover) { color: @origin; &amp;:hover { color: @hover; } } body { color: @mainColor; h1 { color: coral; } #text1 { .textHover(aqua, #44cccc); } #text2 { .textHover(pink, #dda0ba) } } 混合中参数可以有默认值。 @mainColor: aliceblue; .textHover(@origin: aqua, @hover: #44cccc) { color: @origin; &amp;:hover { color: @hover; } } body { color: @mainColor; h1 { color: coral; } #text1 { .textHover; } #text2 { .textHover(pink, #dda0ba) } } 参数有默认值时可以指定部分参数。","categories":[{"name":"less","slug":"less","permalink":"http://sinlapis.github.io/categories/less/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://sinlapis.github.io/tags/前端/"},{"name":"less","slug":"less","permalink":"http://sinlapis.github.io/tags/less/"},{"name":"css","slug":"css","permalink":"http://sinlapis.github.io/tags/css/"}]},{"title":"Webpack配置","slug":"Webpack配置","date":"2019-10-22T01:34:40.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2019/10/22/Webpack配置/","link":"","permalink":"http://sinlapis.github.io/2019/10/22/Webpack配置/","excerpt":"","text":"Webpack配置Kotlin看不动了，摸鱼学学前端。 先安装node.js和npm，此处略。 初始化初始化package描述文件，在项目路径中生成package.json文件。 npm init 或者使用npm init --yes省去中间配置步骤。 安装Webpacknpm i webpack webpack-cli -D –save-dev(-D)参数意思是把模块版本信息保存到devDependencies（开发环境依赖）中，即package.json的devDependencies字段中 配置build启动脚本在package.json中，对scripts添加build字段： { \"scripts\": { \"build\": \"webpack --mode production\", \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" } } 此外在项目目录中新建文件夹src作为源码目录，在src中新建文件index.js作为程序入口，内容随便写点。 此时可以测试能否build成功： npm run build 项目目录中会出现一个dist文件夹，里面有一个main.js，即转换生成的js文件。 使用webpack.config.js可以使用webpack.config.js来自定义build的入口和出口。该文件可以使用node.js的模块。 const path = require(\"path\"); module.exports = { entry: './src/home.js', output: { path: path.resolve(__dirname, \"dist\"), filename: 'output.js' } } require是node.js引入模块的方法。此处引入的path是用于处理操作系统中文件路径的模块。path.resolve()方法将路径转换为绝对路径。__dirname为当前执行文件所在目录的完整目录名。 如果需要有多个入口和多个出口，可以如下配置： const path = require(\"path\"); module.exports = { entry: { main: './src/home.js', about: './src/about.js' }, output: { path: path.resolve(__dirname, \"dist\"), filename: '[name].js' } }; output可以省略，生成的文件名使用entry中对应的key值。[name]是由webpack自动填充的字段。还可以使用[hash]、[chunkHash]来生成hash值。 webpack.config.js的位置也是可配置的，需要修改package.json - scripts - build字段 { \"scripts\": { \"build\": \"webpack --mode production --config scripts/webpack.config.js\", \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" } } 此时webpack的当前路径变为./scripts/，因此还需要修改webpack.config.js。 const path = require(\"path\"); const dist = path.join(__dirname, '..', 'dist'); module.exports = { entry: { main: './src/home.js', about: './src/about.js' }, output: { path: dist, filename: '[name].js' } }; 或者 const path = require(\"path\"); module.exports = { entry: { main: './src/home.js', about: './src/about.js' }, output: { path: path.resolve(process.cwd(), \"dist\"), filename: '[name].js' } }; process.cwd()为获得当前执行node命令时候的文件夹目录名。 自动生成html如果生成js使用了hash值作为文件名，那么对应的html也需要自动生成。安装插件html-webpack-plugin。 npm i -D html-webpack-plugin 在webpack.config.js中加入插件： const path = require(\"path\"); // 引入模块 const HtmlWebpackPlugin =require(\"html-webpack-plugin\"); const dist = path.join(__dirname, '..', 'dist'); module.exports = { entry: { main: './src/home.js', }, output: { path: dist, filename: '[name].[chunkHash:8].js' }, // 引入插件 plugins: [ new HtmlWebpackPlugin() ] }; 进行npm run build，在dist中生成了index.html，其中使用的js文件是打包的js文件。 html模版使用html模版则需要在项目目录中建立public文件夹，在其中建立home.html，如下： &lt;!DOCTYPE html> &lt;html lang=\"zh\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>自动生成模版&lt;/title> &lt;/head> &lt;body> &lt;div id=\"root\">&lt;/div> &lt;/body> &lt;/html> 修改webpack.config.js，为插件添加配置： const path = require(\"path\"); const HtmlWebpackPlugin =require(\"html-webpack-plugin\"); const dist = path.join(__dirname, '..', 'dist'); module.exports = { entry: { main: './src/home.js', }, output: { path: dist, filename: '[name].[chunkHash:8].js' }, plugins: [ new HtmlWebpackPlugin({ title: \"模版测试\", template: \"public/home.html\" }) ] }; 可以使用模版语法来定制生成的html。 &lt;!DOCTYPE html> &lt;html lang=\"zh\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>&lt;%= htmlWebpackPlugin.options.title %>&lt;/title> &lt;/head> &lt;body> &lt;div id=\"root\">&lt;/div> &lt;/body> &lt;/html> 再次打包则生成的html如下： &lt;!DOCTYPE html> &lt;html lang=\"zh\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>模版测试&lt;/title> &lt;/head> &lt;body> &lt;div id=\"root\">&lt;/div> &lt;script type=\"text/javascript\" src=\"main.299861a9.js\">&lt;/script>&lt;/body> &lt;/html> css安装style-loader和css-loader。style-loader用于插入css到js里。css-loader用于处理css。 npm i -D style-loader css-loader 修改webpack.config.js，添加loader： const path = require(\"path\"); const HtmlWebpackPlugin =require(\"html-webpack-plugin\"); const dist = path.join(__dirname, '..', 'dist'); module.exports = { entry: { main: './src/home.js', }, output: { path: dist, filename: '[name].[chunkHash:8].js' }, module: { rules: [ { test: /\\.css$/, use: [ 'style-loader', 'css-loader' ] } ] }, plugins: [ new HtmlWebpackPlugin({ title: \"模版测试\", template: \"public/home.html\" }) ] }; loader的执行顺序从后向前。 在js文件中引入css。 import './main.css'; console.log(\"home\"); 此时进行打包，css会进入js并在执行的时候生效。 如果希望提取css到单独文件，则需要安装mini-css-extract-plugin插件。 npm i -D mini-css-extract-plugin 修改webpack.config.js，加入该插件的配置，修改位置已标出。 const path = require(\"path\"); const HtmlWebpackPlugin = require(\"html-webpack-plugin\"); // [1] const MiniCssExtractPlugin = require(\"mini-css-extract-plugin\"); const dist = path.join(__dirname, '..', 'dist'); module.exports = { entry: { main: './src/home.js', }, output: { path: dist, filename: '[name].[chunkHash:8].js' }, module: { rules: [ { test: /\\.css$/, // [2] use: [ MiniCssExtractPlugin.loader, 'css-loader' ] } ] }, plugins: [ new HtmlWebpackPlugin({ title: \"模版测试\", template: \"public/home.html\" }), // [3] new MiniCssExtractPlugin({ filename: '[name].css' }) ] }; 进行打包时css文件会单独到处，并在html中引入。 构建导出目录结构修改webpack.config.js，直接在导出部分添加路径即可。 const path = require(\"path\"); const HtmlWebpackPlugin = require(\"html-webpack-plugin\"); const MiniCssExtractPlugin = require(\"mini-css-extract-plugin\"); const dist = path.join(__dirname, '..', 'dist'); module.exports = { entry: { main: './src/home.js', }, output: { path: dist, // [1] filename: 'js/[name].[chunkHash:8].js' }, module: { rules: [ { test: /\\.css$/, use: [ MiniCssExtractPlugin.loader, 'css-loader' ] } ] }, plugins: [ new HtmlWebpackPlugin({ title: \"模版测试\", template: \"public/home.html\" }), new MiniCssExtractPlugin({ // [2] filename: 'css/[name].[chunkHash:8].css' }) ] }; 配置开发服务器安装插件webpack-dev-server。 npm i -D webpack-dev-server 修改package.json，添加dev命令。 { \"name\": \"test-react-2\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"build\": \"webpack --mode production --config scripts/webpack.config.js\", \"dev\": \"webpack-dev-server --mode development --config scripts/webpack.config.js\", \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" }, \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": { \"css-loader\": \"^3.2.0\", \"html-webpack-plugin\": \"^3.2.0\", \"mini-css-extract-plugin\": \"^0.8.0\", \"style-loader\": \"^1.0.0\", \"webpack\": \"^4.41.2\", \"webpack-cli\": \"^3.3.9\" } } 修改webpack.config.js，可以配置端口号等。 const path = require(\"path\"); const HtmlWebpackPlugin = require(\"html-webpack-plugin\"); const MiniCssExtractPlugin = require(\"mini-css-extract-plugin\"); const dist = path.join(__dirname, '..', 'dist'); module.exports = { entry: { main: './src/home.js', }, output: { path: dist, filename: 'js/[name].[chunkHash:8].js' }, module: { rules: [ { test: /\\.css$/, use: [ MiniCssExtractPlugin.loader, 'css-loader' ] } ] }, plugins: [ new HtmlWebpackPlugin({ title: \"模版测试\", template: \"public/home.html\" }), new MiniCssExtractPlugin({ filename: 'css/[name].[chunkHash:8].css' }) ], // [1] devServer: { port: 3000, open: true } }; 配置css预处理器安装less和less-loader。 npm i -D less less-loader 修改webpack.config.js，添加less文件规则。 const path = require(\"path\"); const HtmlWebpackPlugin = require(\"html-webpack-plugin\"); const MiniCssExtractPlugin = require(\"mini-css-extract-plugin\"); const dist = path.join(__dirname, '..', 'dist'); module.exports = { entry: { main: './src/home.js', }, output: { path: dist, filename: 'js/[name].[chunkHash:8].js' }, module: { rules: [ { test: /\\.css$/, use: [ MiniCssExtractPlugin.loader, 'css-loader' ] }, // [1] { test: /\\.less$/, use: [ MiniCssExtractPlugin.loader, 'css-loader', 'less-loader' ] } ] }, plugins: [ new HtmlWebpackPlugin({ title: \"模版测试\", template: \"public/home.html\" }), new MiniCssExtractPlugin({ filename: 'css/[name].[chunkHash:8].css' }) ], devServer: { port: 3000, open: true } }; 添加一个less文件并引入。 body { color: aliceblue; } import './main.css' // [1] import './test.less' console.log(\"home\"); 图片处理安装file-loader。 npm i -D file-loader 在webpack.config.js中配置规则。 const path = require(\"path\"); const HtmlWebpackPlugin = require(\"html-webpack-plugin\"); const MiniCssExtractPlugin = require(\"mini-css-extract-plugin\"); const dist = path.join(__dirname, '..', 'dist'); module.exports = { entry: { main: './src/home.js', }, output: { path: dist, filename: 'js/[name].[chunkHash:8].js' }, module: { rules: [ { test: /\\.css$/, use: [MiniCssExtractPlugin.loader, 'css-loader'] }, { test: /\\.less$/, use: [MiniCssExtractPlugin.loader, 'css-loader', 'less-loader'] }, // [1] { test: /\\.(png|jpe?g|gif|jfif)$/i, use: [ { loader: 'file-loader', }, ], options: { name: '[path][name].[ext]', } }, ] }, plugins: [ new HtmlWebpackPlugin({ title: \"模版测试\", template: \"public/home.html\" }), new MiniCssExtractPlugin({ filename: 'css/[name].[chunkHash:8].css' }) ], devServer: { port: 3000, open: true } }; 字体处理同样使用file-loader。在webpack.config.js中添加配置。 const path = require(\"path\"); const HtmlWebpackPlugin = require(\"html-webpack-plugin\"); const MiniCssExtractPlugin = require(\"mini-css-extract-plugin\"); const dist = path.join(__dirname, '..', 'dist'); module.exports = { entry: { main: './src/home.js', }, output: { path: dist, filename: 'js/[name].[chunkHash:8].js' }, module: { rules: [ { test: /\\.css$/, use: [MiniCssExtractPlugin.loader, 'css-loader'] }, { test: /\\.less$/, use: [MiniCssExtractPlugin.loader, 'css-loader', 'less-loader'] }, { test: /\\.(png|jpe?g|gif|jfif)$/i, loader: 'file-loader', options: { name: 'static/images/[name].[ext]', publicPath: '/' } }, // [1] { test: /\\.(eot|ttf|woff|woff2)(\\?v=\\d+\\.\\d+\\.\\d+)?$/, loader: 'file-loader', options: { name: 'static/fonts/[name].[ext]', publicPath: '/' } }, ] }, plugins: [ new HtmlWebpackPlugin({ title: \"模版测试\", template: \"public/home.html\" }), new MiniCssExtractPlugin({ filename: 'static/css/[name].[chunkHash:8].css' }) ], devServer: { port: 3000, open: true } }; 修改less。 @mainColor: aliceblue; .textHover(@origin: aqua, @hover: #44cccc) { color: @origin; &amp;:hover { color: @hover; } } // [1] @font-face { font-family: FFXIV_Lodestone_SSF; src: url(\"assets/fonts/FFXIV_Lodestone_SSF.woff\") format('woff'); } body { color: @mainColor; h1 { color: coral; } #text1 { .textHover; } #text2 { .textHover(pink, #dda0ba); } // [2] #text3 { font-family: FFXIV_Lodestone_SSF, serif; } } 配置babelbabel可以把ES2015及更新版本的js转换为向前兼容的js，也支持转换jsx。 安装babel-loader。 npm i -D babel-loader @babel/core @babel/preset-env 在webpack.config.js中添加规则。 const path = require(\"path\"); const HtmlWebpackPlugin = require(\"html-webpack-plugin\"); const MiniCssExtractPlugin = require(\"mini-css-extract-plugin\"); const dist = path.join(__dirname, '..', 'dist'); module.exports = { entry: { main: './src/home.js', }, output: { path: dist, filename: 'js/[name].[chunkHash:8].js' }, module: { rules: [ { test: /\\.css$/, use: [MiniCssExtractPlugin.loader, 'css-loader'] }, { test: /\\.less$/, use: [MiniCssExtractPlugin.loader, 'css-loader', 'less-loader'] }, { test: /\\.(png|jpe?g|gif|jfif)$/i, loader: 'file-loader', options: { name: 'static/images/[name].[ext]', publicPath: '/' } }, { test: /\\.(eot|ttf|woff|woff2)(\\?v=\\d+\\.\\d+\\.\\d+)?$/, loader: 'file-loader', options: { name: 'static/fonts/[name].[ext]', publicPath: '/' } }, // [1] { test: /\\.m?js$/, exclude: /(node_modules|bower_components)/, use: { loader: 'babel-loader', options: { presets: ['@babel/preset-env'] } } } ] }, plugins: [ new HtmlWebpackPlugin({ title: \"模版测试\", template: \"public/home.html\" }), new MiniCssExtractPlugin({ filename: 'static/css/[name].[chunkHash:8].css' }) ], devServer: { port: 3000, open: true } };","categories":[{"name":"Webpack","slug":"Webpack","permalink":"http://sinlapis.github.io/categories/Webpack/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://sinlapis.github.io/tags/前端/"},{"name":"Webpack","slug":"Webpack","permalink":"http://sinlapis.github.io/tags/Webpack/"}]},{"title":"SQL基础教程笔记0x01","slug":"SQL基础教程笔记0x01","date":"2019-09-08T01:18:25.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2019/09/08/SQL基础教程笔记0x01/","link":"","permalink":"http://sinlapis.github.io/2019/09/08/SQL基础教程笔记0x01/","excerpt":"","text":"集合运算表的加减法union 对表进行并集操作。可以使用union all使结果包含重复行。 select product_id, product_name from product union select product_id, product_name from product_2; product_id product_name 0001 T恤 0002 打孔器 0003 运动T恤 0004 菜刀 0005 高压锅 0006 叉子 0007 擦菜板 0008 圆珠笔 0009 手套 0010 水壶 注意：作为union的运算对象的记录的列数必须相同，列的类型必须一致；order by只能在最后使用一次。 intersect 对表进行交集操作。MySQL不支持该操作。 /* postgreSQL */ select public.product.product_id, public.product.product_name from public.product intersect select public.product_2.product_id, public.product_2.product_name from public.product_2; product_id product_name 0001 T恤 0002 打孔器 0003 运动T恤 /* MySQL用exists模拟 */ select product_id, product_name from product as p where exists( select product_id from product_2 as p2 where p.product_id = p2.product_id ); except 对表进行差集操作，注意该操作不满足交换律。 /* postgreSQL */ select public.product.product_id, public.product.product_name from public.product except select public.product_2.product_id, public.product_2.product_name from public.product_2 product_id product_name 0004 菜刀 0005 高压锅 0006 叉子 0007 擦菜板 0008 圆珠笔 /* MySQL用not exists模拟 */ select product_id, product_name from product as p where not exists( select product_id from product_2 as p2 where p.product_id = p2.product_id ); product_id product_name 0004 菜刀 0005 高压锅 0008 圆珠笔 0006 叉子 0007 擦菜板 联结内联结 以一张表中的列为桥梁，将其他表中满足同样条件的列汇集到同一结果之中。 select sp.shop_id, sp.shop_name, sp.product_id, p.product_name, p.sale_price from public.shop_product as sp inner join public.product as p on sp.product_id = p.product_id shop_id shop_name product_id product_name sale_price 000D 福冈 0001 T恤 1000 000A 东京 0001 T恤 1000 000B 名古屋 0002 打孔器 500 000A 东京 0002 打孔器 500 000C 大阪 0003 运动T恤 4000 000B 名古屋 0003 运动T恤 4000 000A 东京 0003 运动T恤 4000 000C 大阪 0004 菜刀 3000 000B 名古屋 0004 菜刀 3000 000C 大阪 0006 叉子 500 000B 名古屋 0006 叉子 500 000C 大阪 0007 擦菜板 880 000B 名古屋 0007 擦菜板 880 外联结 和内联结基本相同，但是会选择主表的全部信息（见下面示例）。 select sp.shop_id, sp.shop_name, sp.product_id, p.product_name, p.sale_price from public.shop_product as sp right outer join public.product as p on sp.product_id = p.product_id shop_id shop_name product_id product_name sale_price 000D 福冈 0001 T恤 1000 000A 东京 0001 T恤 1000 000B 名古屋 0002 打孔器 500 000A 东京 0002 打孔器 500 000C 大阪 0003 运动T恤 4000 000B 名古屋 0003 运动T恤 4000 000A 东京 0003 运动T恤 4000 000C 大阪 0004 菜刀 3000 000B 名古屋 0004 菜刀 3000 NULL NULL NULL 高压锅 6800 000C 大阪 0006 叉子 500 000B 名古屋 0006 叉子 500 000C 大阪 0007 擦菜板 880 000B 名古屋 0007 擦菜板 880 NULL NULL NULL 圆珠笔 100 有两条记录另一张表上没有。 select sp.shop_id, sp.shop_name, sp.product_id, p.product_name, p.sale_price from public.shop_product as sp left join public.product as p on sp.product_id = p.product_id shop_id shop_name product_id product_name sale_price 000D 福冈 0001 T恤 1000 000A 东京 0001 T恤 1000 000B 名古屋 0002 打孔器 500 000A 东京 0002 打孔器 500 000C 大阪 0003 运动T恤 4000 000B 名古屋 0003 运动T恤 4000 000A 东京 0003 运动T恤 4000 000C 大阪 0004 菜刀 3000 000B 名古屋 0004 菜刀 3000 000C 大阪 0006 叉子 500 000B 名古屋 0006 叉子 500 000C 大阪 0007 擦菜板 880 000B 名古屋 0007 擦菜板 880","categories":[{"name":"SQL","slug":"SQL","permalink":"http://sinlapis.github.io/categories/SQL/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://sinlapis.github.io/tags/SQL/"}]},{"title":"SQL基础教程笔记0x00","slug":"SQL基础教程笔记0x00","date":"2019-09-07T02:05:05.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2019/09/07/SQL基础教程笔记0x00/","link":"","permalink":"http://sinlapis.github.io/2019/09/07/SQL基础教程笔记0x00/","excerpt":"","text":"查询基础逻辑运算符含有NULL时的真值 SQL中的逻辑运算是三值逻辑，即包括真、假、不确定。 聚合与排序为聚合结果指定条件having子句 having子句用于对集合指定条件过滤。having子句位于group by子句后面。 select `product_type`, count(*) from shop group by `product_type` having count(*) = 2; having子句中能够使用的要素有：常数、聚合函数、group by子句中指定的列名（即聚合键）。 复杂查询视图视图的创建create view shop_sum (`product_type`, `cnt_product`) as select `product_type`, count(*) from shop group by `product_type`; 限制 定义视图时不能使用order by。 对视图更新是有条件的： select子句中未使用distinct。 from子句中只有一张表。 未使用group by子句。 未使用having子句。 子查询 子查询就是将用来定义视图的select子句直接用于from子句中。 select `product_type`, `cnt_product` from ( select `product_type`, count(*) as `cnt_product` from `shop` group by `product_type` ) as `product_sum`; 标量子查询 标量子查询必须而且只能返回1行1列的结果。 /* where子句中无法使用聚合函数，可以使用标量子查询代替。*/ select `product_id`, `product_name`, `sale_price` from `shop` where sale_price > ( select avg(sale_price) from `shop` ); 关联子查询 在普通子查询中添加where子句，使其变为标量子查询。 select `product_id`, `product_name`, `sale_price` from `shop` as `s1` where sale_price > ( select avg(sale_price) from `shop` as `s2` where `s1`.`product_type` = `s2`.`product_type` group by `product_type` ) ; 函数、谓词、case表达式谓词like %代表0字符及以上的任意字符串，_代表任意一个字符。 /* pg */ select * from test.like_sample.like_test where strcol like 'abc%'; select * from test.like_sample.like_test where strcol like 'abc__'; between 范围查询，包括两个边界。 select * from `shop` where sale_price between 100 and 1000; is null、is not null 判断是否为null。 in or的简便写法。 select `product_name`, `purchase_price` from `shop` where putchase_price in (320, 500, 5000); 使用子查询作为in的参数select `product_name`, `sale_price` from `shop` where `product_id` in ( select `product_id` from `all_shops` where `shop_id` = '000c' ); exists 判断是否存在满足条件的某种记录，存在则返回真，不存在则返回假。 select `product_name`, `sale_price` from `product` as p where exists ( select * from shop_product as sp where sp.shop_id = '000c' and sp.product_id = p.product_id ); case表达式 满足when子句就执行对应的then子句，否则到下一个when子句，直到没有when子句后执行else子句。 select sum( case when `product_type` = 'A' then `sale_price` else 0 end ) as `sum_price_clothes`, sum( case when `product_type` = 'b' then `sale_price` else 0 end ) as `sum_price_kitchen`, sum( case when `product_type` = 'C' then `sale_price` else 0 end ) as `sum_price_office` from `product`;","categories":[{"name":"SQL","slug":"SQL","permalink":"http://sinlapis.github.io/categories/SQL/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://sinlapis.github.io/tags/SQL/"}]},{"title":"MySQL技术内幕笔记0x04","slug":"MySQL技术内幕笔记0x04","date":"2019-09-06T01:53:55.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2019/09/06/MySQL技术内幕笔记0x04/","link":"","permalink":"http://sinlapis.github.io/2019/09/06/MySQL技术内幕笔记0x04/","excerpt":"","text":"事务事务简介特性（ACID） 原子性（Atomicity）：指整个数据库事务是不可分割的工作单位。只有使事务中所有的数据库操作都执行成功，才算整个事务成功。事务中任何一个SQL语句执行失败，已经执行成功的SQL语句也必须撤销，数据库状态应该退回事务前的状态。 一致性（Consistency）：指事务将数据库从一种状态转变为下一种一致的状态。在事务开始之前和事务结束之后，数据库的完整性约束没有被破坏。 隔离性（Isolation）：事务的隔离性要求每个读写事务的对象对其他事务的操作对象能互相分离，即该事务提交前对其他事务都不可见，通常使用锁来实现。 持久性（Durability）：事务一旦提交，其结果就是永久性的。即使发生宕机等故障，数据库也能将数据恢复。 分类扁平事务 是事务中最简单的一种，但在实际生产环境中可能是使用最为频繁的事务。在扁平事务，所有操作都处于同一层次，其由begin work开始，由commit work或rollback work结束，其间的操作是原子的，要么都执行，要么都回滚。 带保存点的扁平事务 除了支持扁平事务支持的操作外，允许在事务执行过程中回滚到同一事务中较早的一个状态。这是因为某些事务可能在执行过程中出现错误并不会导致所有的操作都无效，放弃整个事务不合乎要求，开销也太大。 保存点用来通知系统应该记住事务当前的状态，以便之后发生错误时，事务能够回到保存点当时的状态。 保存点在事务内部是递增的，不会因为回滚而出现覆盖。 保存点是易失的，即当发生系统崩溃后进行恢复时，事务需要从开始处重新执行，不能从最近的一个保存点继续。 链事务 在提交一个事务时，释放不需要的数据对象，将必要的上下文隐式地传给下一个要开始的事务。提交事务的操作和开始下一个事务的操作将合并为一个原子操作，这意味着下一个事务将看到上一个事务的结果。 链事务与带保存点的事务不同的是，带保存点的扁平事务能回滚到任意正确的保存点，而链事务中的回滚仅限于当前事务。此外，链事务在执行commit后即释放了当前事务所持有的锁，而带保存点的扁平事务不影响迄今为止所持有的锁。 嵌套事务 是一个层次结构框架，由一个顶层事务控制各个层次的事务。顶层事务之下嵌套的事务称为子事务，其控制每一个局部变换。 分布式事务 通常是一个在分布式环境下运行的扁平事务，因此需要根据数据所在位置访问网络中的不同节点。 事务的实现 redo log用来保证事务的持久性，undo log用来保证事务的一致性。 redo通常是物理日志，记录的是页的物理修改操作，用于对页进行重做操作。undo是逻辑日志，根据每行记录进行记录，用于对事务进行回滚。 当事务提交时，必须先将该事务的所有日志写入到redo日志文件进行持久化，待事务的提交成功后才算完成。 undo存放在数据库内部的一个特殊段中，称为undo段，位于共享表空间内。 事务的隔离级别 未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据。 提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)。 可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读。 串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞。 原文链接 分布式事务 XA是一种分布式事务的标准，多数数据库都实现了XA接口。 XA事务由一个或多个资源管理器、一个事务管理器以及一个应用程序组成。 资源管理器：提供访问事务资源的方法。通常一个数据库就是一个资源管理器。 事务管理器：协调参与全局事务中的各个事务。需要和参与全局事务的所有资源管理器进行通信。 应用程序：定义事务的边界，指定全局事务中的操作。 分布式事务使用两段式提交。在第一阶段，所有参与全局事务的节点都开始准备，告诉事务管理器它们准备好提交了。在第二阶段，事务管理器告诉资源管理器执行rollback还是commit。如果任何一个节点显示不能提交，在所有节点都被告知需要回滚。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://sinlapis.github.io/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://sinlapis.github.io/tags/MySQL/"},{"name":"InnoDB","slug":"InnoDB","permalink":"http://sinlapis.github.io/tags/InnoDB/"},{"name":"事务","slug":"事务","permalink":"http://sinlapis.github.io/tags/事务/"}]},{"title":"剑指Offer面试题-正则表达式匹配","slug":"剑指Offer面试题-正则表达式匹配","date":"2019-09-05T08:06:06.000Z","updated":"2021-03-03T02:50:12.463Z","comments":true,"path":"2019/09/05/剑指Offer面试题-正则表达式匹配/","link":"","permalink":"http://sinlapis.github.io/2019/09/05/剑指Offer面试题-正则表达式匹配/","excerpt":"","text":"正则表达式匹配请实现一个函数用来匹配包括.和*的正则表达式。模式中的字符.表示任意一个字符，而*表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串aaa与模式a.a和ab*ac*a匹配，但是与aa.a和ab*a均不匹配 public class Q19 { public boolean match(char[] str, char[] pattern) { if (pattern == null || str == null) return false; return subMatch(str, 0, pattern, 0); } private boolean subMatch(char[] str, int strIndex, char[] pattern, int patternIndex) { // [1] if (strIndex >= str.length) { return patternIndex >= pattern.length || (patternIndex == pattern.length - 2 &amp;&amp; pattern[patternIndex + 1] == '*'); } if (patternIndex >= pattern.length) return false; // 匹配单个字符 if (patternIndex == pattern.length - 1 || pattern[patternIndex + 1] != '*') { if (pattern[patternIndex] == '.' || str[strIndex] == pattern[patternIndex]) { return subMatch(str, strIndex + 1, pattern, patternIndex + 1); } return false; } // 匹配带* if (pattern[patternIndex] != '.' &amp;&amp; str[strIndex] != pattern[patternIndex]) { return subMatch(str, strIndex, pattern, patternIndex + 2); } //[2] if (subMatch(str, strIndex, pattern, patternIndex + 2)) return true; //[3] while (strIndex &lt; str.length) { if (str[strIndex++] != pattern[patternIndex] &amp;&amp; pattern[patternIndex] != '.') { break; } if (subMatch(str, strIndex, pattern, patternIndex + 2)) return true; } return false; } public static void main(String[] args) { Q19 s = new Q19(); String str = \"bcbbabab\"; String pattern = \".*a*a\"; s.match(str.toCharArray(), pattern.toCharArray()); } } 思路：使用递归。首先是退出条件，如果str和pattern都用完退出返回true，如果仅是pattern用完则返回false。注意[1]处有另一种退出返回true的情况，就是str用完，pattern剩余一个字符和*，此时按匹配0个可以返回true。然后是匹配单个字符，比较简单。最后是匹配带*，注意[2]先进行一次匹配0个，[3]进入循环的条件为str没有用完。","categories":[{"name":"算法","slug":"算法","permalink":"http://sinlapis.github.io/categories/算法/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sinlapis.github.io/tags/剑指Offer/"},{"name":"字符串","slug":"字符串","permalink":"http://sinlapis.github.io/tags/字符串/"}]},{"title":"MySQL技术内幕笔记0x03","slug":"MySQL技术内幕笔记0x03","date":"2019-09-05T01:06:50.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2019/09/05/MySQL技术内幕笔记0x03/","link":"","permalink":"http://sinlapis.github.io/2019/09/05/MySQL技术内幕笔记0x03/","excerpt":"","text":"锁锁简介 锁是数据库区别于文件系统的一个关键特性。数据库系统使用锁是为了支持对共享资源进行并发访问，提供数据的完整性和一致性。 lock与latch latch一般成为闩锁（轻量级锁），因为其要求锁定的时间必须非常短。若持续时间长，则应用的性能会非常差。其目的是保证并发线程操作临界资源的正确性，并且通常没有死锁检测机制。在InnoDB中，latch又可以分为mutex（互斥锁）和rwlock（读写锁）。 lock的对象是是事务，用来锁定的是数据库中的对象，如表、页、行。一般lock的对象仅在事务commit或rollback后进行释放（不同事务隔离级别释放的时间可能不同）。此外，lock是有死锁机制的。 InnoDB存储引擎中的锁锁的类型 InnoDB实现了如下两种标准的行级锁： 共享锁（S Lock），允许事务读一行数据。 排他锁（X Lock），允许事务删除或更新一行数据。 InnoDB支持多粒度锁定，这种锁定允许事务在行级锁与表级锁同时存在。为了支持在不同粒度上进行加锁操作，InnoDB支持一种额外的锁方式，称之为意向锁。意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度上进行加锁。InnoDB支持两种意向锁： 意向共享锁（IS Lock），事务想要夺得一张表中某几行的共享锁。 意向排他锁（IX Lock），事务想要获得一张表中某几行的排他锁。 意向锁不会阻塞除全表扫描以外的任何请求。表级意向锁之间互相兼容，IS与S兼容，S与S兼容，其他情况都不兼容。 一致性非锁定读 一致性非锁定读是指InnoDB通过行的多版本控制的方式来读取当前数据库中行的数据。如果读取的行正在执行delete或update操作，这时读取操作不会因此去等待行锁释放，而是去读取行的快照数据。该操作实现是通过undo段来完成的，而undo用来在事务中回滚数据，因此快照数据本身是没有额外开销的。此外，读取快照数据是不需要上锁的，因为没有事务需要对历史数据进行修改。由此，非锁定读机制极大地提高了数据库的并发性。 一致性锁定读 InnoDB对于select语句支持两种一致性锁定读操作，一种是select ... for update，对读取的行记录加一个X锁，其他事务不能对已锁定的行加上任何锁。另一种是select ... lock in share mode，对读取的行记录加一个S锁，其他事务可以向被锁定的行加S锁，但是如果加X锁则会被阻塞。 锁的算法行锁的3种算法 Record Lock：单个行记录上锁。总是会去锁住索引记录，如果表在建立时没有设置索引，那么InnoDB会使用隐式的主键来进行锁定。 Gap Lock：间隙锁，锁定一个范围，但不包含记录本身。 Next-Key Lock：Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身。InnoDB对于行的查询都是采用这种锁定算法。其设计的目的是为了解决幻象问题。 当查询的索引含有唯一属性时，InnoDB会对Next-Key Lock进行优化，将其降级为Record Lock，即仅锁住记录，从而提高并发性。 解决幻象问题 幻象问题是指，在同一事务下，连续执行两次相同的SQL语句可能得到不同的结果，第二次SQL语句可能会返回之前不存在的的行。 锁问题脏读 脏数据是指事务对缓冲池中行记录的修改，并且还没有被提交。 脏读是指在不同事务下，当前事务可以读到其他事务未提交的数据，即脏数据。 不可重复读 不可重复读是指，在同一个事务中多次读取同一数据集合，但是存在两次结果不一致的情况。 不可重复读和脏读的区别是，脏读得到的是未提交的数据，而不可重复读得到的是已经提交的数据，但是其违反了数据库事务一致性的要求。 不可重复读的问题是可以接受的，因为其读到的是已经提交的数据，本身不会带来很大问题。 丢失更新 丢失更新是指有些事务的更新操作被另一个事务的更新操作所覆盖，从而导致数据的不一致，例如： 事务t1将行记录r更新为v1，但是t1没有提交 事务t2将行记录r更新为v2，但是t2没有提交 t1提交 t2提交 要避免丢失更新发生，需要让事务在这种情况下的操作变成串行化。在1.和2.中分别加上一个X锁，据此，2.需要等待1.和3.结束才能执行。 死锁 死锁是指两个及以上的事务在执行过程中，因竞争锁资源而造成的一种互相等待的现象。 解决死锁最简单的方式是不要有等待，让任何等待都转化为回滚，并且事务重新开始。但是这种方式可能导致并发性能下降，而这所带来的问题更为严重，因为很难被发现并且浪费资源。 解决死锁的一种方法是超时，即当两个事务互相等待时，当一个等待时间超过设置的某一阈值时，其中一个事务进行回滚，另一个等待事务就能继续进行。 当前数据库普遍采用等待图的方法进行死锁检测，这是一种更为主动的检测方法，主要包括锁的信息链表和事务的等待链表，以及两者构造的图，如果这张图中存在回路，就代表存在死锁。检测算法通常采用深度优先算法实现。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://sinlapis.github.io/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://sinlapis.github.io/tags/MySQL/"},{"name":"InnoDB","slug":"InnoDB","permalink":"http://sinlapis.github.io/tags/InnoDB/"},{"name":"锁","slug":"锁","permalink":"http://sinlapis.github.io/tags/锁/"}]},{"title":"剑指Offer面试题-删除链表节点","slug":"剑指Offer面试题-删除链表节点","date":"2019-09-04T08:21:23.000Z","updated":"2021-03-03T02:50:12.463Z","comments":true,"path":"2019/09/04/剑指Offer面试题-删除链表节点/","link":"","permalink":"http://sinlapis.github.io/2019/09/04/剑指Offer面试题-删除链表节点/","excerpt":"","text":"删除链表节点在O(1)时间内删除链表节点给定单向链表的头指针和一个节点指针，定义一个函数在O(1)时间内删除该节点。 class Node { int value; Node next; public Node(int value) { this.value = value; } } class Solution { public Node solute(Node head, Node p) { if (p.next != null) { p.value = p.next.value; p.next = p.next.next; return head; } else if (head == p) { return null; } else { Node next = head; while (next.next != p) { next = next.next; } next.next = null; return head; } } } 思路：把要删除的节点的下一个节点的值覆盖到当前节点上，再删除下一个节点。注意需要判断要删除节点是否为尾节点，以及链表中是否只有一个节点。 删除排序链表中重复的节点在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5 class Node { int value; Node next; public Node(int value) { this.value = value; } } class Solution { public Node solute(Node head) { if (head == null) return null; boolean deleteHead = false; if (head.next != null &amp;&amp; head.value == head.next.value) deleteHead = true; Node last = head; Node next = head.next; int lastValue = head.value; while (next != null) { if (next.value == lastValue) { last.next = next.next; } else { lastValue = next.value; if (next.next == null || next.next.value != lastValue) { last = last.next; } else { last.next = next.next; } } next = next.next; } if (deleteHead) { while (true) { if (head.next == null || head.value != head.next.value) return head.next; head = head.next; } } return head; } } 思路：如要删除头节点最后处理（头指针向下到第一个值不同的节点），中间节点保存上一个值，如果重复则next直接向下，如果next的值发生变动则进行预判，相同则直接向下并更新上一个值，否则last向下。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://sinlapis.github.io/categories/数据结构/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sinlapis.github.io/tags/剑指Offer/"},{"name":"链表","slug":"链表","permalink":"http://sinlapis.github.io/tags/链表/"}]},{"title":"剑指Offer面试题-打印从1到最大的n位数","slug":"剑指Offer面试题-打印从1到最大的n位数","date":"2019-09-04T07:45:18.000Z","updated":"2021-03-03T02:50:12.463Z","comments":true,"path":"2019/09/04/剑指Offer面试题-打印从1到最大的n位数/","link":"","permalink":"http://sinlapis.github.io/2019/09/04/剑指Offer面试题-打印从1到最大的n位数/","excerpt":"","text":"打印从1到最大的n位数输入数字n，按顺序打印从1到最大的n位数十进制数。 class Solution { StringBuilder num = new StringBuilder(); int lastCount = 1; public Solution() { num.append('1'); } public void check() { boolean c = true; for (int i = num.length() - 1; i >= 0; i--) { if (c) { if (num.charAt(i) == '9') num.setCharAt(i, '0'); else { num.setCharAt(i, (char) (num.charAt(i) + 1)); c = false; } } else break; } if (c) num.insert(0, '1'); } public void increase() { lastCount++; if (lastCount >= 10) { lastCount = 0; check(); } else { num.setCharAt(num.length() - 1, (char) (num.charAt(num.length() - 1) + 1)); } } public int getSize() { return num.length(); } public void print() { System.out.println(num.toString()); } public static void solute(int n) { if (n &lt;= 0) return; Solution solution = new Solution(); while (solution.getSize() &lt;= n) { solution.print(); solution.increase(); } } } 思路：使用书中第一种解法。使用StringBuilder更加方便。","categories":[{"name":"算法","slug":"算法","permalink":"http://sinlapis.github.io/categories/算法/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sinlapis.github.io/tags/剑指Offer/"},{"name":"大数","slug":"大数","permalink":"http://sinlapis.github.io/tags/大数/"}]},{"title":"剑指Offer面试题-数值的整数次方","slug":"剑指Offer面试题-数值的整数次方","date":"2019-09-02T08:39:01.000Z","updated":"2021-03-03T02:50:12.463Z","comments":true,"path":"2019/09/02/剑指Offer面试题-数值的整数次方/","link":"","permalink":"http://sinlapis.github.io/2019/09/02/剑指Offer面试题-数值的整数次方/","excerpt":"","text":"数值的整数次方给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。保证base和exponent不同时为0。 class Solution { private double unsignedPower(double base, int exponent) { if (exponent == 0) return 1; if (exponent == 1) return base; double result = unsignedPower(base, exponent >> 1); result *= result; if (exponent &amp; 1 == 1) result *= base; return result; } public double Power(double base, int exponent) { if (base == 0.0) return 0.0; if (exponent == 0) return 1.0; int exp = Math.abs(exponent); double result = unsignedPower(base, exp); if (exponent &lt; 0) result = 1 / result; return result; } } 思路：求a^n，先求a^(n/2)，然后平方，依次递归。注意指数为负数、0以及底数为0.0的情况。","categories":[{"name":"算法","slug":"算法","permalink":"http://sinlapis.github.io/categories/算法/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sinlapis.github.io/tags/剑指Offer/"},{"name":"数学","slug":"数学","permalink":"http://sinlapis.github.io/tags/数学/"}]},{"title":"剑指Offer面试题-剪绳子","slug":"剑指Offer面试题-剪绳子","date":"2019-09-02T08:14:20.000Z","updated":"2021-03-03T02:50:12.463Z","comments":true,"path":"2019/09/02/剑指Offer面试题-剪绳子/","link":"","permalink":"http://sinlapis.github.io/2019/09/02/剑指Offer面试题-剪绳子/","excerpt":"","text":"剪绳子一根长度为n的绳子，请把绳子剪成m段（n &gt; 1且m &gt; 1），每段绳子的长度记为k[0], k[1], ..., k[m]。请问k[0] * k[1] * , ..., * k[m]的可能最大乘积是多少？ class Solution { public int maxMulti(int n) { if (n &lt; 2) return 0; if (n &lt; 4) return n - 1; int[] back = new int[n + 1]{0, 1, 2, 3}; int max = 0; for (int i = 4; i &lt;= n; i++) { max = 0; for (int j = 1; j &lt;= i / 2; j++) { int temp = back[j] * back[i - j]; if (temp > max) max= temp; } back[i] = max; } return back[n]; } } 思路：使用动态规划，记录长度为i时乘积最大值。注意在取[0, 3]时分情况，因为题目要求至少剪一刀，所以在n为[0, 3]时的返回值和记录初始化时的[0, 3]不同。","categories":[{"name":"算法","slug":"算法","permalink":"http://sinlapis.github.io/categories/算法/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sinlapis.github.io/tags/剑指Offer/"},{"name":"动态规划","slug":"动态规划","permalink":"http://sinlapis.github.io/tags/动态规划/"}]},{"title":"剑指Offer面试题-机器人的运动范围","slug":"剑指Offer面试题-机器人的运动范围","date":"2019-09-02T07:28:27.000Z","updated":"2021-03-03T02:50:12.463Z","comments":true,"path":"2019/09/02/剑指Offer面试题-机器人的运动范围/","link":"","permalink":"http://sinlapis.github.io/2019/09/02/剑指Offer面试题-机器人的运动范围/","excerpt":"","text":"机器人的运动范围地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ class Point { int x; int y; public Point(int x, int y) { this.x = x; this.y = y; } } class Solution { private int addSingle(int n) { int result = 0; while (n > 0) { result += n % 10; n /= 10; } return result; } private boolean check(int x, int y, int k, boolean[][] visited) { if ( x &lt; 0 || y &lt; 0 || x >= visited.length || y >= visited[0].length || visited[x][y] ) return false; // [1] return addSingle(x) + addSingle(y) &lt;= k; } public int movingCount(int threshold, int rows, int cols) { if (threshold &lt; 0 || rows== 0 || cols == 0) return 0; if (threshold == 0) return 1; // 初始化访问标记矩阵 boolean[][] visited = new boolean[rows][cols]; for (boolean[] lb: visited) { lb = new boolean[cols]; for (boolean b: lb) { b = false; } } // BFS Queue&lt;Point> queue = new LinkedList&lt;>(); queue.add(new Point(0, 0)); Point current; int result = 1; visited[0][0] = true; while (!queue.isEmpty()) { current = queue.poll(); if (check(current.x - 1, current.y, threshold, visited)) { queue.add(new Point(current.x - 1, current.y)); visited[current.x - 1][current.y] = true; result++; } if (check(current.x + 1, current.y, threshold, visited)) { queue.add(new Point(current.x + 1, current.y)); visited[current.x + 1][current.y] = true; result++; } if (check(current.x, current.y - 1, threshold, visited)) { queue.add(new Point(current.x, current.y - 1)); visited[current.x][current.y - 1] = true; result++; } if (check(current.x, current.y + 1, threshold, visited)) { queue.add(new Point(current.x, current.y + 1)); visited[current.x][current.y + 1] = true; result++; } } return result; } } 思路：没有使用书上的解法，使用BFS，用队列实现。注意[1]处边界条件。","categories":[{"name":"算法","slug":"算法","permalink":"http://sinlapis.github.io/categories/算法/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sinlapis.github.io/tags/剑指Offer/"},{"name":"BFS","slug":"BFS","permalink":"http://sinlapis.github.io/tags/BFS/"}]},{"title":"MySQL技术内幕笔记0x02","slug":"MySQL技术内幕笔记0x02","date":"2019-09-02T02:24:49.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2019/09/02/MySQL技术内幕笔记0x02/","link":"","permalink":"http://sinlapis.github.io/2019/09/02/MySQL技术内幕笔记0x02/","excerpt":"","text":"索引和算法B+树 B+树是一种平衡查找树。在B+树中，所有记录节点都是按键值的大小顺序存放在同一层的叶子节点上，由各叶子节点指针进行连接。如果用户从最左边的叶子节点开始遍历，可以得到所有键值的顺序排序。 插入操作 Leaf Page未满，Index Page未满：直接插入即可。 Leaf Page已满，Index Page未满：需要拆分Leaf Page，将中间节点放入Index Page中，小于中间节点的记录放左边节点，大于或等于中间节点的记录放右边节点。 Leaf Page已满，Index Page已满：需要拆分Leaf Page和Index Page。拆分Leaf Page同上；拆分Index Page时，小于中间节点的索引放左边，大于中间节点的索引放右边，中间节点放入上一层Index Page。 删除操作 B+树使用填充因子来控制树的删除变化，50%是填充因子可设置的最小值。 叶子节点和中间节点都不小于填充因子：直接删除，如果该节点还是Index Page的节点，用该节点的右节点代替。 叶子节点小于填充因子，中间节点不小于填充因子：合并叶子节点和它的兄弟节点，同时更新Index Page。 叶子节点和中间节点都小于填充因子：合并叶子节点和它的兄弟节点，更新Index Page，然后合并中间节点和它的父节点、兄弟节点。 B+树索引 B+树索引的本质是B+树在数据库中的实现。但是B+树索引在数据库中具有高扇出性的特点。因此在数据库中，B+树的高度一般都在2~4层。 扇入：指直接调用该模块的上级模块的个数。扇入大表示模块的复用程序高。 扇出：是指该模块直接调用的下级模块的个数。在此处表示向下查询次数较少。 聚集索引 聚集索引就是按照每张表的主键构造一棵B+树，同时叶子节点中存放的即为整张表的行记录数据，也将聚集索引的叶子节点称为数据页。聚集索引的这个特性决定了索引组织表中数据也是索引的一部分。 每张表有且只有一个聚集索引。在多数情况下，查询优化器倾向于采用聚集索引，因为聚集索引能够在B+树索引的叶子节点上直接找到数据。此外，由于定义了数据的逻辑顺序，聚集索引能够特别快地访问针对范围值的查询，查询优化器能够快速发现某一段范围的数据页需要扫描。对于主键的排序查找和范围查找速度非常快。 聚集索引的存储并不是物理上连续的，而是逻辑上连续的。 辅助索引 辅助索引中，叶子节点并不包含行记录的全部数据。叶子节点除了包含键值以外，每个叶子节点中的索引行还包含了一个书签，该书签用来告知InnoDB存储引擎与索引相对应行数据的位置。 Cardinality值 当某个字段可取值范围很小（例如性别、地区、类型等），称为低选择性，对该字段添加B+树索引是完全没有必要的。相反，如果某个字段的取值范围很广，几乎没有重复，即属于高选择性，则此时选择B+树索引是最合适的。 Cardinality值非常关键，表示索引中不重复记录数量的预估值。在实际应用中，Cardinality / n_rows_in_table应尽可能地接近1。 B+树索引的使用联合索引 联合索引是指对表上的多个列进行索引。以(a, b)为例，首先对于单列a来说，联合索引也是可以使用的，但是单独对b的查询不能使用。如果是需要对多个键进行排序，由于联合索引已经对后面的键进行了排序处理，此时使用联合索引可以减少一次排序操作。 覆盖索引 覆盖索引是指从辅助索引中就可以得到查询记录，而不需要查询聚集索引中的记录。辅助索引不包含整行记录的所有信息，因此其大小要远小于聚集索引，因此可以减少大量的IO操作。例如针对一些统计问题，例如count，如果表中有辅助索引，那么没有必要去查询聚集索引。 哈希算法自适应哈希索引 InnoDB存储引擎使用哈希算法来对字典进行查找，其冲突机制采用链表方式，哈希函数采用出发散列方式。 自适应哈希索引采用上述方式实现。自适应哈希索引经哈希函数银蛇到一个哈希表中，因此对于字典类型的查找非常快速。 全文检索倒排索引 全文检索通常使用倒排索引来实现。它在辅助表中存储了单词与单词自身在一个或多个文档中所在的位置之间的映射。有两种表现形式： inverted file index，{单词，单词所在的文档ID} full inverted index，{单词，(单词所在文档ID，在文档中的具体位置)} InnoDB全文检索 InnoDB存储引擎采用full inverted index 的方式实现全文检索。为了提高检索性能，共有6张辅助表，有一个全文检索索引缓存。全文检索索引缓存是一个红黑树结构，在插入数据已经更新到了对应的表时，辅助表的数据可能还没有更新，其更新数据还在全文索引缓存中。当对全文检索进行查询时，首先会将在全文索引缓存中的数据合并到辅助表中，然后在进行查询。 限制 每张表只能有一个全文索引。 由多页组合而成的全文索引列必须使用相同的字符集与排序规则。 不支持没有单词界定符的语言，例如中文、日语等。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://sinlapis.github.io/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://sinlapis.github.io/tags/MySQL/"},{"name":"InnoDB","slug":"InnoDB","permalink":"http://sinlapis.github.io/tags/InnoDB/"},{"name":"索引","slug":"索引","permalink":"http://sinlapis.github.io/tags/索引/"}]},{"title":"MySQL技术内幕笔记0x01","slug":"MySQL技术内幕笔记0x01","date":"2019-09-02T00:40:34.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2019/09/02/MySQL技术内幕笔记0x01/","link":"","permalink":"http://sinlapis.github.io/2019/09/02/MySQL技术内幕笔记0x01/","excerpt":"","text":"表（二）视图 在MySQL数据库中，视图是一个命名的虚表，它由一个SQL查询来定义，可以当作表使用。与持久表不同的是，视图中的入局没有实际的物理存储。 视图的作用 视图的主要用途之一是被用作一个抽象装置，特别是对于一些应用程序，程序本身不需要关心基表的结构，只需要按照视图的定义来取数据或更新数据，因此，视图同时在一定程度上起到一个安全层的作用。 用户可以对某些视图进行更新操作，一般称可以进行更新操作的视图为可更新视图。如果加上with check option选项，MySQL数据库会对更新视图插入的数据进行检查，对于不满足视图定义条件的插入会抛出一个异常，不允许视图中数据更新。 分区表 分区的过程是将一个表或索引分解为多个更小、更可管理的部分。就访问数据库而言，从逻辑上讲，只有一个表或一个索引，但是在物理上这个表或索引可能由数十个物理分区组成。每个分区都是独立的对象，可以独自处理，也可以作为一个更大的对象的一部分进行处理。 水平分区是指将同一表中不同行的记录分配到不同的物理文件中，垂直分区是指将同一表中不同列的记录分配到不同的物理文件中。MySQL数据库支持的分区类型为水平分区，不支持垂直分区。 局部分区索引是指一个分区中既存放了数据又存放了索引。与之相对的是全局分区，数据存放在各个分区中，但是所有数据的索引放在一个对象中。MySQL的分区是局部分区索引。 分区主要用于数据库高可用性的管理。 不论创建何种类型的分区，如果表中存在主键或唯一索引时，分区列必须是唯一索引的一个组成部分。如果建表时没有指定主键，唯一索引，可以指定任何一个列为分区列。 分区类型range分区 基于属于一个给定连续区间的列值对行数据进行分区。 create table t ( id int )engine=innodb partition by range(id) ( partition p0 values less than (10), partition p1 values less than (20) ); list分区 同range分区，只是list分区面向的是离散值。如果插入的值不在分区定义中，MySQL数据库会抛出异常。 create table t ( a int, b int )engine=innodb partition by list(b) ( partition p0 values in (1, 3, 5, 7, 9), partition p1 values in (0, 2, 4, 6, 8) ); hash分区 根据用户自定义的表达式的返回值来进行分区，返回值不能为负数。此外还需要指定分区数量。 create table t ( a int, b datetime )engine=innodb partition by hash (year(b)) partitions 4; key分区 使用MySQL数据库提供的函数进行分区。 create table t ( a int, b datetime )engine=innodb partition by key(b) partitions 4; columns分区 可以直接使用非整型的数据进行分区，分区根据类型直接比较而得。支持的类型有所有整数类型（int、smallint、tinyint、bigint），日期类型（date、datetime），字符串类型（char、varchar、binary、varbinary）。 create table t ( a int, b datetime )engine=innodb partition by range columns(b) ( partition p0 values less than('2009-01-01'), partition p1 values less than('2010-01-01') ); 子分区 子分区是在分区的基础上再进行分区，有时也称这种分区为复合分区。MySQL数据库允许在range和list分区上再进行hash或key分区。 create table ts ( a int, b date )engine=innodb partition by range(year(b)) subpartition by hash(to_days(b)) subpartitions 2 ( partition p0 values less than (1990), partition p1 values less than (2000), partition p2 values less than maxvalue ); 分区中的null值 MySQL数据库总是认为null值小于任何一个非null值。 对于range分区，如果向分区列插入了null值，则MySQL数据库会将该值放入最左边的分区。 在list分区中使用null值，必须显式指定在哪个分区放入null值，否则会报错。 hash和key分区的任何分区函数都会将含有null值的记录都返回0。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://sinlapis.github.io/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://sinlapis.github.io/tags/MySQL/"},{"name":"InnoDB","slug":"InnoDB","permalink":"http://sinlapis.github.io/tags/InnoDB/"},{"name":"表","slug":"表","permalink":"http://sinlapis.github.io/tags/表/"},{"name":"视图","slug":"视图","permalink":"http://sinlapis.github.io/tags/视图/"}]},{"title":"尝试使用GitHub-Actions自动部署Hexo","slug":"尝试使用GitHub-Actions自动部署Hexo","date":"2019-08-28T02:20:19.000Z","updated":"2021-03-03T02:50:12.463Z","comments":true,"path":"2019/08/28/尝试使用GitHub-Actions自动部署Hexo/","link":"","permalink":"http://sinlapis.github.io/2019/08/28/尝试使用GitHub-Actions自动部署Hexo/","excerpt":"","text":"尝试使用GitHub Actions自动部署Hexo参考链接。 生成ssh部署公私钥 ssh-keygen 为Page仓库添加公钥： Github：在仓库/Settings/Deploy keys中添加，授予写权限 Coding：在仓库/设置/部署公钥中添加，授予写权限 为源码仓库添加私钥： Github：在仓库/Settings/Secrets中添加，注意记录名称。这个功能可以放一些隐私内容，包括私钥、token、密码等等。 编写workflow，文件位置.github/workflows/deploy.yml name: Node CI on: [push] jobs: build: runs-on: ubuntu-latest strategy: matrix: node-version: [10.x] steps: - uses: actions/checkout@v1 - name: Use Node.js 10.x uses: actions/setup-node@v1 with: node-version: '10.x' - name: env prepare env: ACTIONS_PRI: ${{secrets.ACTIONS_PRI}} run: | mkdir -p ~/.ssh/ echo \"$ACTIONS_PRI\" > ~/.ssh/id_rsa chmod 600 ~/.ssh/id_rsa ssh-keyscan github.com >> ~/.ssh/known_hosts ssh-keyscan git.coding.net >> ~/.ssh/known_hosts git config --global user.name 'SinLapis' git config --global user.email 'stradust0001@gmail.com' npm i -g hexo-cli npm install hexo-renderer-jade hexo-renderer-stylus --save npm i - name: gen run: | hexo g -d 多部署注意把域名加入~/.ssh/known_hosts，否则会部署失败。","categories":[{"name":"博客","slug":"博客","permalink":"http://sinlapis.github.io/categories/博客/"}],"tags":[{"name":"CI/CD","slug":"CI-CD","permalink":"http://sinlapis.github.io/tags/CI-CD/"},{"name":"GitHub","slug":"GitHub","permalink":"http://sinlapis.github.io/tags/GitHub/"},{"name":"Hexo","slug":"Hexo","permalink":"http://sinlapis.github.io/tags/Hexo/"}]},{"title":"MySQL技术内幕笔记0x00","slug":"MySQL技术内幕笔记0x00","date":"2019-08-28T02:13:09.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2019/08/28/MySQL技术内幕笔记0x00/","link":"","permalink":"http://sinlapis.github.io/2019/08/28/MySQL技术内幕笔记0x00/","excerpt":"","text":"表（一）索引组织表 在InnoDB存储引擎中，表都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表。如果在创建表时没有显式地指定主键，则InnoDB会按以下方式选择或创建主键： 首先判断表中是否有非空的唯一索引，如果有则该列为主键。该方式选择的根据是定义索引的顺序，而不是建表时列的顺序。 否则，InnoDB存储引擎会自动创建一个6字节大小的指针。 InnoDB逻辑存储结构 从InnoDB存储引擎的逻辑存储结构看，所有数据都被逻辑地存放在一个空间中，称之为表空间。表空间又由段、区、页组成。 表空间可以看作是InnoDB存储引擎逻辑结构的最高层 ，所有数据都存放在表空间中。 常见的段有数据段、索引段、回滚段等。数据段即为B+树的叶子节点，索引段为B+树的非叶子节点。 区是由连续页组成的空间，在任何情况下每个区的大小都为1MB。为了保证区中页的连续性，InnoDB存储引擎一次从磁盘中申请4~5个区。在默认情况下，InnoDB存储引擎页大小为16KB，即一个区中一共有64个连续的页。 页是InnoDB磁盘管理的最小单位。 约束数据完整性 关系性数据库和文件系统的一个不同点是，关系数据库本身能保证存储数据的完整性，不需要应用程序的控制，而文件系统一般需要在程序端进行控制。 一般来说，数据完整性有以下三种形式： 实体完整性保证表中有一个主键，可以通过定义Primary Key或Unique Key约束或者定义一个触发器来保证实体的完整性。 域完整性保证数据每列的值满足特定的条件，可以选择合适的数据类型确保一个入局值满足特定条件，使用外键约束，编写触发器，或者考虑DEFAULT约束。 参照完整性保证两张表之间的关系。可以使用外键以强制参照完整性，也可以使用触发器。 InnoDB存储引擎提供了以下几种约束：primary key、unique key、foreign key、default、not null 约束的创建 约束的创建有两种方式： 表建立时就进行约束定义 利用alter table命令来进行创建约束 对于主键约束而言，其默认约束名为primary。对于unique key约束而言，默认约束名和列名一样，也可以人为指定名字。 约束和索引的区别 当用户创建了一个唯一索引就创建了一个唯一的约束。约束偏向于一个逻辑概念，用来保证数据完整性，而索引是一个数据结构，既有逻辑上的概念，在数据库中还代表着物理存储方式。 对错误数据的约束 在某些魔神设置下，MySQL数据库允许非法的或者不正确的数据插入或更新，又或者可以在数据库内部将其转化为一个合法的值。 触发器约束 触发器的作用是在执行insert、delete、update命令之前或之后自动调用SQL命令或存储过程。最多可以为一个表建立6个触发器，即分别为insert、update、delete的before和after各定义一个。当前MySQL数据库只支持for each row的 触发方式，即按每行记录进行触发。 通过触发器，用户可以实现MySQL数据库本身并不支持的一些特性。 create table user_cash ( user_id int not null , cash int unsigned not null ); insert into `user_cash`(`user_id`, `cash`) value(1, 1000); # 非正常行为 update `user_cash` set `cash` = `cash` - (-20) where `user_id` = 1; # 添加触发器和错误日志 create table `user_cash_err_log` ( user_id int not null , old_cash int unsigned not null , new_cash int unsigned not null , user varchar(30), time datetime ); create trigger tgr_user_cash_update before update on `user_cash` for each row begin if new.`cash` - old.`cash` > 0 then insert into `user_cash_err_log` select old.`user_id`, old.`cash`, new.`cash`, USER(), NOW(); set new.`cash` = old.`cash`; end if; end; # 再次尝试非正常行为 update `user_cash` set `cash` = `cash` - (-20) where `user_id` = 1; select * from user_cash_err_log; # 1 1020 1040 root@localhost 2019-08-29 10:06:27 select * from user_cash; # 1 1020 外键约束 一般称被引用表为父表，引用的表称为子表。外键定义时的on delete和on update表示在对父表进行delete和update操作时，对子表所做的操作。 可定义的子表操包括cascade、set null、no action、restrict。cascade（级联）表示当父级发生delete或update操作时，对相应的子表中的数据也进行delete或update操作。set null表示父表发生delete或update操作时，相应的子表中的数据被更新为null值，但是子表中相对应的列必须允许为null值。no action和restrict在MySQL中等价，都表示父表发生delete或update操作时抛出错误，不允许这类操作发生。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://sinlapis.github.io/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://sinlapis.github.io/tags/MySQL/"},{"name":"InnoDB","slug":"InnoDB","permalink":"http://sinlapis.github.io/tags/InnoDB/"},{"name":"表","slug":"表","permalink":"http://sinlapis.github.io/tags/表/"}]},{"title":"剑指Offer面试题-矩阵中的路径","slug":"剑指Offer面试题-矩阵中的路径","date":"2019-08-27T02:29:36.000Z","updated":"2021-03-03T02:50:12.463Z","comments":true,"path":"2019/08/27/剑指Offer面试题-矩阵中的路径/","link":"","permalink":"http://sinlapis.github.io/2019/08/27/剑指Offer面试题-矩阵中的路径/","excerpt":"","text":"矩阵中的路径请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串”bccced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 class Point { int x; int y; public boolean[] visited = {false, false, false, false}; public Point(int x, int y) { this.x = x; this.y = y; } @Override public boolean equals(Object obj) { try { return x == ((Point) obj).x &amp;&amp; y == ((Point) obj).y; } catch (ClassCastException ce) { return super.equals(obj); } } } public class Solution { private void resetMB(boolean[][] mb) { for (boolean[] bs : mb) { for (boolean b : bs) { b = false; } } } public boolean hasPath(char[] matrix, int rows, int cols, char[] str) { int firstRow = 0, firstCol = 0; char[][] mc = new char[rows][cols]; boolean[][] mb = new boolean[rows][cols]; resetMB(mb); for (int i = 0; i &lt; rows; i++) { mc[i] = new char[cols]; for (int j = 0; j &lt; cols; j++) { mc[i][j] = matrix[i * cols + j]; } } while (true) { // 先定位第一个字符 outer: for (; firstRow &lt; rows; firstCol = 0, firstRow++) { //[1] for (; firstCol &lt; cols; firstCol++) { if (matrix[firstRow * cols + firstCol] == str[0]) break outer; } } if (firstRow >= rows) return false; Stack&lt;Point> route = new Stack&lt;>(); route.push(new Point(firstRow, firstCol)); int strIndex = 1; if (strIndex >= str.length) return true; //[2] resetMB(mb); mb[firstRow][firstCol] = true; // 在定位周围找下一个字符 while (!route.isEmpty()) { Point current = route.peek(); int visitOri = -1; if ( current.x - 1 >= 0 &amp;&amp; !current.visited[0] &amp;&amp; !mb[current.x - 1][current.y] &amp;&amp; mc[current.x - 1][current.y] == str[strIndex] ) { //0 route.push(new Point(current.x - 1, current.y)); route.peek().visited[1] = true; visitOri = 0; mb[current.x - 1][current.y] = true; strIndex++; } else if ( current.x + 1 &lt; rows &amp;&amp; !current.visited[1] &amp;&amp; !mb[current.x + 1][current.y] &amp;&amp; mc[current.x + 1][current.y] == str[strIndex] ) { //1 route.push(new Point(current.x + 1, current.y)); route.peek().visited[0] = true; visitOri = 1; mb[current.x + 1][current.y] = true; strIndex++; } else if ( current.y - 1 >= 0 &amp;&amp; !current.visited[2] &amp;&amp; !mb[current.x][current.y - 1] &amp;&amp; mc[current.x][current.y - 1] == str[strIndex] ) { //2 route.push(new Point(current.x, current.y - 1)); route.peek().visited[3] = true; visitOri = 2; mb[current.x][current.y - 1] = true; strIndex++; } else if ( current.y + 1 &lt; cols &amp;&amp; !current.visited[3] &amp;&amp; !mb[current.x][current.y + 1] &amp;&amp; mc[current.x][current.y + 1] == str[strIndex] ) { //3 route.push(new Point(current.x, current.y + 1)); route.peek().visited[2] = true; visitOri = 3; mb[current.x][current.y + 1] = true; strIndex++; } else { Point p = route.pop(); mb[p.x][p.y] = false; strIndex--; } if (strIndex >= str.length) return true; if (visitOri >= 0) current.visited[visitOri] = true; } if (firstCol >= cols - 1) { //[1] firstCol = 0; firstRow++; } else { firstCol++; } } } } 思路：先找开始位置，然后在周围找下一个。要保存两种状态，一是当前已经选择的位置（由boolean二维数组保存），二是回溯失败的状态（由Point对象保存）。注意：如果要找下一个初始位置，[1]处要对初始坐标进行处理，包括移动到下一个坐标和一行循环完成置列号为0（因为要保存之前的状态，所以不能在循环列时置0）；[2]处防止不需要进入循环时要返回true的情况。","categories":[{"name":"算法","slug":"算法","permalink":"http://sinlapis.github.io/categories/算法/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sinlapis.github.io/tags/剑指Offer/"},{"name":"回溯法","slug":"回溯法","permalink":"http://sinlapis.github.io/tags/回溯法/"}]},{"title":"HeadFirst设计模式笔记0x00","slug":"HeadFirst设计模式笔记0x00","date":"2019-08-27T01:45:45.000Z","updated":"2021-03-03T02:50:12.455Z","comments":true,"path":"2019/08/27/HeadFirst设计模式笔记0x00/","link":"","permalink":"http://sinlapis.github.io/2019/08/27/HeadFirst设计模式笔记0x00/","excerpt":"","text":"观察者模式 观察者模式定义对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。 松耦合 当两个对象之间松耦合，它们依然可以交互，但是互相不关心对方的实现。换句话说，它们各自可以独立复用，在保证交互接口不变的条件下可以修改各自的实现。 观察者模式实现了主题和观察者之间松耦合的对象设计。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://sinlapis.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://sinlapis.github.io/tags/设计模式/"},{"name":"观察者模式","slug":"观察者模式","permalink":"http://sinlapis.github.io/tags/观察者模式/"}]},{"title":"Java8实战笔记0x0b","slug":"Java8实战笔记0x0b","date":"2019-08-25T03:06:04.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2019/08/25/Java8实战笔记0x0b/","link":"","permalink":"http://sinlapis.github.io/2019/08/25/Java8实战笔记0x0b/","excerpt":"","text":"面向对象和函数式编程的混合：Java 8和Scala的比较Java 与 Scala的混合编程参考。使用Maven生成项目，pom.xml文件如下： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;groupId>org.bigmt&lt;/groupId> &lt;artifactId>mjns&lt;/artifactId> &lt;version>1.0-SNAPSHOT&lt;/version> &lt;properties> &lt;project.build.sourceEncoding>UTF-8&lt;/project.build.sourceEncoding> &lt;java.version>11&lt;/java.version> &lt;maven.compiler.source>11&lt;/maven.compiler.source> &lt;maven.compiler.target>${maven.compiler.source}&lt;/maven.compiler.target> &lt;/properties> &lt;dependencies> &lt;dependency> &lt;groupId>org.scala-lang&lt;/groupId> &lt;artifactId>scala-library&lt;/artifactId> &lt;version>2.13.0&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.scala-lang&lt;/groupId> &lt;artifactId>scala-compiler&lt;/artifactId> &lt;version>2.13.0&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.scala-lang&lt;/groupId> &lt;artifactId>scala-reflect&lt;/artifactId> &lt;version>2.13.0&lt;/version> &lt;/dependency> &lt;/dependencies> &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>org.apache.maven.plugins&lt;/groupId> &lt;artifactId>maven-compiler-plugin&lt;/artifactId> &lt;version>3.8.0&lt;/version> &lt;configuration> &lt;release>11&lt;/release> &lt;/configuration> &lt;/plugin> &lt;plugin> &lt;groupId>org.scala-tools&lt;/groupId> &lt;artifactId>maven-scala-plugin&lt;/artifactId> &lt;version>2.15.2&lt;/version> &lt;executions> &lt;execution> &lt;goals> &lt;goal>compile&lt;/goal> &lt;goal>testCompile&lt;/goal> &lt;/goals> &lt;/execution> &lt;/executions> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/project> // Main.java package org.bigmt.mjns; public class Main { public static void main(String[] args) { ScalaMain scalaMain = new ScalaMain(); scalaMain.entry(); } } // ScalaMain.scala package org.bigmt.mjns class ScalaMain { def entry(): Unit = { var n: Int = 2 while (n &lt;= 6) { println(s\"Hello ${n} bottles of beer\") n += 1 } } } Scala简介你好，啤酒// Scala 2 to 6 foreach {n => println(s\"Hello ${n} bottles of beer\")} // Java IntStream.rangeClosed(2, 6) .forEach(n -> System.out.println(\"Hello \" + n + \" bottles of beer\")); 基础数据结构创建集合// Scala val authorsToAge = Map(\"Raoul\" -> 23, \"Mario\" -> 40, \"Alan\" ->53) val authors = List(\"Raoul\", \"Mario\", \"Alan\") val numbers = Set(1, 1, 2, 3, 5, 8) 不可变 Scala中不可变的集合是持久化的，更新一个Scala集合会生成一个新的集合，这个新的集合和之前版本的集合共享大部分内容，最终的结果是数据尽可能地实现了持久化。 // Scala val numbers = Set(2, 5, 3) val newNumbers = numbers + 8 println(numbers) println(newNumbers) /* Output: Set(2, 5, 3) Set(2, 5, 3, 8) */ 使用集合// Scala val fileLine = List(\"test\", \"test for scala\", \"no vac\", \"yeeeeeeees man\") val linesLongUpper = fileLine.par.filter(_.length() > 10).map(_.toUpperCase()) println(linesLongUpper) /* Output List(TEST FOR SCALA, YEEEEEEEES MAN) */","categories":[{"name":"Scala","slug":"Scala","permalink":"http://sinlapis.github.io/categories/Scala/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://sinlapis.github.io/tags/笔记/"},{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"},{"name":"Scala","slug":"Scala","permalink":"http://sinlapis.github.io/tags/Scala/"}]},{"title":"剑指Offer面试题-旋转数组的最小数字","slug":"剑指Offer面试题-旋转数组的最小数字","date":"2019-08-24T09:14:46.000Z","updated":"2021-03-03T02:50:12.463Z","comments":true,"path":"2019/08/24/剑指Offer面试题-旋转数组的最小数字/","link":"","permalink":"http://sinlapis.github.io/2019/08/24/剑指Offer面试题-旋转数组的最小数字/","excerpt":"","text":"旋转数组的最小数字快速排序public class Q11_0 { public void quickSort(int[] arr, int start, int end) { if (start > end) return; int i = start, j = end; int t = arr[i]; while (i &lt; j) { while (i &lt; j &amp;&amp; t &lt;= arr[j]) j--; if (i &lt; j) { arr[i] = arr[j]; i++; } while (i &lt; j &amp;&amp; t > arr[i]) i++; if (i &lt; j) { arr[j] = arr[i]; j--; } } arr[i] = t; quickSort(arr, start, i - 1); quickSort(arr, j + 1, end); } } 旋转数组的最小数字public class Q11 { public int minNumberInRotateArray(int[] array) { if (array == null || array.length == 0) return 0; int left = 0, right = array.length - 1; int mid; while (left &lt; right) { mid = left + right >> 1; if (array[left] &lt; array[right]) return array[left]; if (array[mid] > array[left]) left = mid + 1; else if (array[mid] &lt; array[left]) right = mid; else left++; } return array[right]; } } 思路：和书上略有不同，主要是处理相同数字上。如果arr[left]和arr[mid]相等，那么只移动left即可。此外，要比较arr[left]和arr[right]的大小，否则会越过最小值。","categories":[{"name":"算法","slug":"算法","permalink":"http://sinlapis.github.io/categories/算法/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sinlapis.github.io/tags/剑指Offer/"},{"name":"排序","slug":"排序","permalink":"http://sinlapis.github.io/tags/排序/"},{"name":"查找","slug":"查找","permalink":"http://sinlapis.github.io/tags/查找/"}]},{"title":"Java8实战笔记0x0a","slug":"Java8实战笔记0x0a","date":"2019-08-24T02:08:36.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2019/08/24/Java8实战笔记0x0a/","link":"","permalink":"http://sinlapis.github.io/2019/08/24/Java8实战笔记0x0a/","excerpt":"","text":"函数式编程的技巧无处不在的函数高阶函数 函数满足以下任一要求即可被称为告诫函数： 接受至少一个函数作为参数 返回结果是一个函数 Comparator&lt;Apple> c = comparing(Apple::getWeight); 科里化 科里化是指一个能将具有n个参数的函数转化为使用n个参数中部分参数的函数，该函数的返回值是另一个函数，参数为转化的函数未使用的参数，例如f(x, y) = (g(x))(y) // 摄氏度转华氏度 static DoubleUnaryOperator curriedConverter(double f, double b) { return (double x) -> x * f + b; } DoubleUnaryOperator convertCtoF = curriedConverter(9.0/5, 32); double c = convertCotF(25); 一个函数使用所有参数仅有部分被传递时，通常称这个函数是部分应用的。 延迟计算自定义延迟列表interface MyList&lt;T> { T head(); MyList&lt;T> tail(); default boolean isEmpty() { return true; } default public MyList&lt;T> filter(Predicate&lt;T> p) { return isEmpty() ? this : p.test(head()) ? new LazyList&lt;>(head(), () -> tail().filter(p)) : tail().filter(p); } } class MyLinkedList&lt;T> implements MyList&lt;T> { private final T head; private final MyList&lt;T> tail; public MyLinkedList(T head, MyList&lt;T> tail) { this.head = head; this.tail = tail; } @Override public T head() { return head; } @Override public MyList&lt;T> tail() { return tail; } @Override public boolean isEmpty() { return false; } } class Empty&lt;T> implements MyList&lt;T> { @Override public T head() { throw new UnsupportedOperationException(); } @Override public MyList&lt;T> tail() { throw new UnsupportedOperationException(); } } class LazyList&lt;T> implements MyList&lt;T> { final T head; final Supplier&lt;MyList&lt;T>> tail; public LazyList(T head, Supplier&lt;MyList&lt;T>> tail) { this.head = head; this.tail = tail; } @Override public T head() { return head; } @Override public MyList&lt;T> tail() { return tail.get(); } @Override public boolean isEmpty() { return false; } } public class Main { public static void test(Function&lt;String, List&lt;String>> findPrices) { long start = System.nanoTime(); System.out.println(findPrices.apply(\"Fallout New Vegas\")); long duration = (System.nanoTime() - start) / 1_000_000; System.out.println(\"Done in \" + duration + \" msecs\"); } public static MyList&lt;Integer> primes(MyList&lt;Integer> numbers) { return new LazyList&lt;>( numbers.head(), () -> primes( numbers.tail().filter(n -> n % numbers.head() != 0) ) ); } public static LazyList&lt;Integer> from(int n) { return new LazyList&lt;>(n, () -> from(n + 1)); } static &lt;T> void printAll(MyList&lt;T> list) { while (!list.isEmpty()) { System.out.println(list.head()); list = list.tail(); } } public static void main(String[] args) throws Exception { printAll(primes(from(2))); } } 没看懂 模式匹配 Java没有原生支持模式配配匹配，只能用if进行模拟。","categories":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/categories/Java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://sinlapis.github.io/tags/笔记/"},{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"},{"name":"函数式","slug":"函数式","permalink":"http://sinlapis.github.io/tags/函数式/"}]},{"title":"剑指Offer面试题-斐波那契数列","slug":"剑指Offer面试题-斐波那契数列","date":"2019-08-23T09:19:04.000Z","updated":"2021-03-03T02:50:12.463Z","comments":true,"path":"2019/08/23/剑指Offer面试题-斐波那契数列/","link":"","permalink":"http://sinlapis.github.io/2019/08/23/剑指Offer面试题-斐波那契数列/","excerpt":"","text":"斐波那契数列要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。 public class Q10 { public int Fibonacci(int n) { if (n &lt; 0) return -1; if (n &lt;= 1) return n; int current = 1, b1 = 1, b2 = 0; int i = 2; while (i &lt;= n) { current = b1 + b2; b2 = b1; b1 = current; i++; } return current; } } 思路：动态规划，需要前两个结果。 跳台阶一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 public class Q10_2 { public int JumpFloor(int target) { if (target < 2) return 1; if (target == 2) return 2; int b1 = 2, b2 = 1; int current = 1, i = 3; while (i","categories":[{"name":"算法","slug":"算法","permalink":"http://sinlapis.github.io/categories/算法/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sinlapis.github.io/tags/剑指Offer/"},{"name":"动态规划","slug":"动态规划","permalink":"http://sinlapis.github.io/tags/动态规划/"}]},{"title":"剑指Offer面试题-用两个栈实现队列","slug":"剑指Offer面试题-用两个栈实现队列","date":"2019-08-23T08:26:27.000Z","updated":"2021-03-03T02:50:12.463Z","comments":true,"path":"2019/08/23/剑指Offer面试题-用两个栈实现队列/","link":"","permalink":"http://sinlapis.github.io/2019/08/23/剑指Offer面试题-用两个栈实现队列/","excerpt":"","text":"用两个栈实现队列用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 public class Q9 { Stack&lt;Integer> stack1 = new Stack&lt;>(); Stack&lt;Integer> stack2 = new Stack&lt;>(); public void push(int node) { stack1.push(node); } private void fillStack2() { while (!stack1.empty()) { stack2.push(stack1.pop()); } } public int pop() { if (stack2.empty()) { fillStack2(); } return stack2.pop(); } } 思路：一个栈用来入队，另一个栈用来出队。如果出队的栈为空，需要把入队的栈的值导入出队的栈。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://sinlapis.github.io/categories/数据结构/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sinlapis.github.io/tags/剑指Offer/"},{"name":"栈","slug":"栈","permalink":"http://sinlapis.github.io/tags/栈/"},{"name":"队列","slug":"队列","permalink":"http://sinlapis.github.io/tags/队列/"}]},{"title":"剑指Offer面试题-二叉树的下一个结点","slug":"剑指Offer面试题-二叉树的下一个结点","date":"2019-08-23T07:37:35.000Z","updated":"2021-03-03T02:50:12.463Z","comments":true,"path":"2019/08/23/剑指Offer面试题-二叉树的下一个结点/","link":"","permalink":"http://sinlapis.github.io/2019/08/23/剑指Offer面试题-二叉树的下一个结点/","excerpt":"","text":"二叉树的下一个结点给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 class TreeLinkNode { int val; TreeLinkNode left = null; TreeLinkNode right = null; TreeLinkNode next = null; TreeLinkNode(int val) { this.val = val; } } public class Q8 { public TreeLinkNode GetNext(TreeLinkNode pNode) { if (pNode == null) return null; if (pNode.right != null) { TreeLinkNode l = pNode.right; while (l.left != null) { l = l.left; } return l; } TreeLinkNode t = pNode; while (t.next != null) { if (t.next.left == t) return t.next; t = t.next; } return null; } } 思路：分类讨论。如果给出节点有右孩子，从右孩子开始一直访问其左孩子，直到当前节点没有左孩子，返回当前节点。如果给出节点没有右孩子，那么如果它是其父节点的左孩子，则返回其父节点。如果不是其父节点的左孩子，则继续找父节点的父节点，直到当前节点是父节点的左孩子，返回当前节点的父节点。如果找到根节点，那么给出节点没有下一个节点。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://sinlapis.github.io/categories/数据结构/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sinlapis.github.io/tags/剑指Offer/"},{"name":"树","slug":"树","permalink":"http://sinlapis.github.io/tags/树/"}]},{"title":"剑指Offer面试题-重建二叉树","slug":"剑指Offer面试题-重建二叉树","date":"2019-08-22T08:37:49.000Z","updated":"2021-03-03T02:50:12.463Z","comments":true,"path":"2019/08/22/剑指Offer面试题-重建二叉树/","link":"","permalink":"http://sinlapis.github.io/2019/08/22/剑指Offer面试题-重建二叉树/","excerpt":"","text":"重建二叉树输入某二叉树的前序遍历和中序遍历的结果，重建该二叉树，返回二叉树的根节点。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。二叉树节点定义： class TreeNode { public int value; public TreeNode left; public TreeNode right; } public class Solution { private static void buildTree( int[] preOrder, int preStart, int[] inOrder, int inStart, int inEnd, TreeNode current ) { int index; for (index = inStart; index &lt;= inEnd; index++) { if (inOrder[index] == current.value) break; } int leftLength = index - inStart; int rightLength = inEnd - index; if (leftLength > 0) { TreeNode left = new TreeNode(preOrder[preStart + 1]); current.left = left; buildTree( preOrder, preStart + 1, inOrder, index - leftLength, index - 1, left ); } if (rightLength > 0) { TreeNode right = new TreeNode(preOrder[preStart + leftLength + 1]); current.right = right; buildTree( preOrder, preStart + leftLength + 1, inOrder, index + 1, index + rightLength, right ); } } public static TreeNode reConstructBinaryTree(int[] preOrder, int[] inOrder) { if (preOrder == null || preOrder.length == 0) return null; TreeNode root = new TreeNode(preOrder[0]); buildTree( preOrder, 0, inOrder, 0, inOrder.length - 1, root ); return root; } } 思路：前序遍历的第一个元素就是当前树的根节点，在中序遍历中找到当前节点的位置就能算出左右序列长度，从而进行递归。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://sinlapis.github.io/categories/数据结构/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sinlapis.github.io/tags/剑指Offer/"},{"name":"树","slug":"树","permalink":"http://sinlapis.github.io/tags/树/"}]},{"title":"剑指Offer面试题-从尾到头打印链表","slug":"剑指Offer面试题-从尾到头打印链表","date":"2019-08-22T07:58:56.000Z","updated":"2021-03-03T02:50:12.463Z","comments":true,"path":"2019/08/22/剑指Offer面试题-从尾到头打印链表/","link":"","permalink":"http://sinlapis.github.io/2019/08/22/剑指Offer面试题-从尾到头打印链表/","excerpt":"","text":"从尾到头打印链表输入一个链表的头节点，从尾到头反过来打印出每个节点的值。链表定义如下： class Node { public int value; public Node next; } class Node { public int value; public Node next; public Node(int value, Node next) { this.value = value; this.next = next; } } public class Q6 { public static void solution(Node head) { if (head != null) { if (head.next != null) solution(head.next); System.out.print(head.value + \" \"); } } } // Test class Q6Test{ private static final ByteArrayOutputStream outContent = new ByteArrayOutputStream(); private static final ByteArrayOutputStream errContent = new ByteArrayOutputStream(); private static final PrintStream originalOut = System.out; private static final PrintStream originalErr = System.err; @BeforeAll public static void setUpStreams() { System.setOut(new PrintStream(outContent)); System.setErr(new PrintStream(errContent)); } @AfterAll public static void restoreStreams() { System.setOut(originalOut); System.setErr(originalErr); } @Test void solution() { Node n1 = new Node(1, null); Node n2 = new Node(2, n1); Node n3 = new Node(3, n2); Node n4 = new Node(4, n3); Node n5 = new Node(5, n4); Q6.solution(n5); assertEquals(\"1 2 3 4 5 \", outContent.toString()); outContent.reset(); Q6.solution(n1); assertEquals(\"1 \", outContent.toString()); outContent.reset(); Q6.solution(null); assertEquals(\"\", outContent.toString()); } } 思路：使用栈达到先入后出的效果，同样可以使用递归。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://sinlapis.github.io/categories/数据结构/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sinlapis.github.io/tags/剑指Offer/"},{"name":"链表","slug":"链表","permalink":"http://sinlapis.github.io/tags/链表/"}]},{"title":"Java8实战笔记0x09","slug":"Java8实战笔记0x09","date":"2019-08-22T03:22:46.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2019/08/22/Java8实战笔记0x09/","link":"","permalink":"http://sinlapis.github.io/2019/08/22/Java8实战笔记0x09/","excerpt":"","text":"函数式思考实现和维护系统共享可变数据 如果一个方法既不修改它的内嵌类的状态，也不修改其他对象的状态，使用return返回所有的计算结果，那么称其为纯粹的或无副作用的。 副作用：是指函数效果已经超出了函数自身范畴，包括： 除了构造器内的初始化操作，对类中数据结构的任何修改，包括字段的赋值操作 抛出一个异常 进行输入/输出操作，比如向一个文件写数据 声明式编程 命令式编程：描述如何做的编程风格，适合经典的面向对象编程，因为它的特点是它的指令和计算机底层的词汇非常接近，比如赋值、条件分支以及循环。 声明式编程：描述要做什么的编程风格，由程序员来制定规则，给出希望实现的目标，让系统来决定如何实现这个目标。它带来的好处非常明显，用这种方式编写的代码更加接近问题陈述。 什么是函数式编程函数式Java编程 函数式的函数或方法都只能修改本地变量。除此之外，它引用的对象都应该是不可修改的对象。 函数式的函数或方法不应该抛出任何异常。取而代之，可以使用Optional&lt;T&gt;。 如果函数或方法调用的库函数如果有副作用，那么必须设法隐藏这些非函数式的行为，否则就不能调用这些方法。 引用透明性 引用透明性是指，如果一个函数只要传递同样的参数值，总是返回同样的结果，那么这个函数就是引用透明的。Random#nextInt就不是此类函数。在函数式编程中应该选择使用引用透明的函数。","categories":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/categories/Java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://sinlapis.github.io/tags/笔记/"},{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"},{"name":"函数式","slug":"函数式","permalink":"http://sinlapis.github.io/tags/函数式/"}]},{"title":"Java8实战笔记0x08","slug":"Java8实战笔记0x08","date":"2019-08-21T01:23:06.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2019/08/21/Java8实战笔记0x08/","link":"","permalink":"http://sinlapis.github.io/2019/08/21/Java8实战笔记0x08/","excerpt":"","text":"CompletableFuture：组合异步编程（二）对多个异步任务进行流水线操作class Shop { private Random random = new Random(); private String name; public Shop(String name) { this.name = name; } public String getName() { return name; } public static void delay() { try { Thread.sleep(1000L); } catch (InterruptedException e) { throw new RuntimeException(e); } } private double calculatePrice(String product) { delay(); return random.nextDouble() * product.charAt(0) + product.charAt(1); } // 同步方法 public String getPrice(String product) { double price = calculatePrice(product); Discount.Code code = Discount.Code.values()[random.nextInt(Discount.Code.values().length)]; return String.format(\"%s:%.2f:%s\", name, price, code); } } class Discount { public enum Code { NONE(0), SILVER(5), GOLD(10), PLATINUM(15), DIAMOND(20); private final int percentage; Code(int percentage) { this.percentage = percentage; } } public static String applyDiscount(Quote quote) { return quote.getShopName() + \" price is \" + Discount.apply(quote.getPrice(), quote.getDiscountCode()); } public static double apply(double price, Code code) { Shop.delay(); return price * (100 - code.percentage) / 100; } } class Quote { private final String shopName; private final double price; private final Discount.Code discountCode; public Quote(String shopName, double price, Discount.Code discountCode) { this.shopName = shopName; this.price = price; this.discountCode = discountCode; } public static Quote parse(String s) { String[] split = s.split(\":\"); String shopName = split[0]; double price = Double.parseDouble(split[1]); Discount.Code discountCode = Discount.Code.valueOf(split[2]); return new Quote(shopName, price, discountCode); } public String getShopName() { return shopName; } public double getPrice() { return price; } public Discount.Code getDiscountCode() { return discountCode; } } public class Main { private static final List&lt;Shop> shops = Arrays.asList( new Shop(\"BestPrice\"), new Shop(\"LetsSaveBig\"), new Shop(\"MyFavoriteShop\"), new Shop(\"BuyItAll\"), new Shop(\"Steam\"), new Shop(\"Epic\"), new Shop(\"GOG\"), new Shop(\"Taptap\"), new Shop(\"W\"), new Shop(\"V\"), new Shop(\"Z\"), new Shop(\"Y\"), new Shop(\"X\") ); private static final Executor executor = Executors.newFixedThreadPool( Math.min(shops.size(), 100), r -> { Thread t = new Thread(r); t.setDaemon(true); return t; }); public static List&lt;String> findPrices(String product) { return shops.stream() .map(shop -> shop.getPrice(product)) .map(Quote::parse) .map(Discount::applyDiscount) .collect(Collectors.toList()); } public static List&lt;String> findPricesByFuture(String product) { List&lt;CompletableFuture&lt;String>> priceFuture = shops.stream() .map(shop -> CompletableFuture.supplyAsync(() -> shop.getPrice(product), executor)) .map(future -> future.thenApply(Quote::parse)) .map(future -> future.thenCompose(quote -> CompletableFuture.supplyAsync( () -> Discount.applyDiscount(quote), executor ))) .collect(Collectors.toList()); return priceFuture.stream() .map(CompletableFuture::join) .collect(Collectors.toList()); } public static void test(Function&lt;String, List&lt;String>> findPrices) { long start = System.nanoTime(); System.out.println(findPrices.apply(\"Fallout New Vegas\")); long duration = (System.nanoTime() - start) / 1_000_000; System.out.println(\"Done in \" + duration + \" msecs\"); } public static void main(String[] args) throws Exception { test(Main::findPrices); test(Main::findPricesByFuture); } } /* Output [BestPrice price is 130.6535, LetsSaveBig price is 77.87200000000001, MyFavoriteShop price is 113.27, BuyItAll price is 152.532, Steam price is 113.49600000000001, Epic price is 115.32, GOG price is 106.46, Taptap price is 142.44299999999998, W price is 104.76, V price is 132.297, Z price is 136.6575, Y price is 99.2085, X price is 95.60700000000001] Done in 26058 msecs [BestPrice price is 126.36, LetsSaveBig price is 94.728, MyFavoriteShop price is 149.43, BuyItAll price is 107.01, Steam price is 83.936, Epic price is 153.5485, GOG price is 142.53300000000002, Taptap price is 99.2275, W price is 97.064, V price is 104.976, Z price is 87.40549999999999, Y price is 138.051, X price is 140.409] Done in 2007 msecs */ thenApply：支持可以采用同步操作的过程，不会带来太多延迟。在上面代码中，thenApply方法将Stream中的每个CompletableFuture&lt;String&gt;对象转换为对应的CompletableFuture&lt;Quote&gt;对象。 thenCompose：支持异步执行过程，允许对两个异步操作进行流水线，第一个操作完成时，将其结果作为参数传递给第二个操作。 将两个CompletableFuture对象整合起来，无论它们是否存在依赖 thenCombine：可以将两个完全不相干的CompletableFuture对象的结果整合起来。它接受名为BiFunction的第二参数，这个参数定义了当两个CompletableFuture对象完成计算后，结果如何合并。 Future&lt;Double> futurePriceInUSD = CompletableFuture.supplyAsync( () -> shop.getPrice(product) ).thenCombine(CompletableFuture.supplyAsync( () -> exchangeService.getRate(Money.EUR, Money.USD) ), (price, rate) -> price * rate); 相应CompletableFuture的completion事件 thenAccept：将CompletableFuture返回的结果作为参数，并定义如何处理该结果。一旦CompletableFuture计算得到结果，它就返回一个CompletableFuture&lt;Void&gt;。 CompletableFuture.allOf：是一个工厂方法，接收一个CompletableFuture构成的数组，数组中的所有CompletableFuture对象执行完成后，它返回一个CompletableFuture&lt;Void&gt;对象。 CompletableFuture.anyOf：是一个工厂方法，接收一个CompletableFuture构成的数组，返回第一个执行完毕的CompletableFuture对象的返回值构成的CompletableFuture&lt;Object&gt;。","categories":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/categories/Java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://sinlapis.github.io/tags/笔记/"},{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"},{"name":"并发","slug":"并发","permalink":"http://sinlapis.github.io/tags/并发/"}]},{"title":"剑指Offer面试题-二维数组中的查找","slug":"剑指Offer面试题-二维数组中的查找","date":"2019-08-20T09:11:20.000Z","updated":"2021-03-03T02:50:12.463Z","comments":true,"path":"2019/08/20/剑指Offer面试题-二维数组中的查找/","link":"","permalink":"http://sinlapis.github.io/2019/08/20/剑指Offer面试题-二维数组中的查找/","excerpt":"","text":"二维数组中的查找在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 public class Q4 { public static boolean solution(int[][] arr, int target) { if (arr == null || arr.length == 0 || arr[0] == null || arr[0]. length == 0) return false; if (arr[0][0] > target || arr[arr.length - 1][arr[0].length - 1] &lt; target) return false; int column = arr[0].length - 1, row = 0; while (column >= 0 &amp;&amp; row &lt; arr.length) { if (arr[row][column] == target) return true; else if (arr[row][column] > target) column--; else row++; } return false; } } // Test class Q4Test { @Test void solution() { int[][] arr = { {1, 2, 8, 9}, {2, 4, 9, 12}, {4, 7, 10, 13}, {6, 8, 11, 15} }; assertTrue(Q4.solution(arr, 7)); assertTrue(Q4.solution(arr, 11)); assertTrue(Q4.solution(arr, 4)); assertTrue(Q4.solution(arr, 1)); assertTrue(Q4.solution(arr, 15)); assertFalse(Q4.solution(arr, 0)); assertFalse(Q4.solution(arr, 20)); assertFalse(Q4.solution(arr, 3)); assertFalse(Q4.solution(null, 0)); assertFalse(Q4.solution(new int[0][0], 5)); assertFalse(Q4.solution(new int[1][0], 2)); } } 思路：从右上角开始，如图，由于9大于7，那么第四列所有的数都大于7，因此可以排除第四列。以此类推。如果当前值小于目标值，例如第二列的2小于7，那么2右面的所有数都小于7，因此可以排除第二行。","categories":[{"name":"算法","slug":"算法","permalink":"http://sinlapis.github.io/categories/算法/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"},{"name":"算法","slug":"算法","permalink":"http://sinlapis.github.io/tags/算法/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sinlapis.github.io/tags/剑指Offer/"},{"name":"数组","slug":"数组","permalink":"http://sinlapis.github.io/tags/数组/"}]},{"title":"剑指Offer面试题-数组中的重复数字","slug":"剑指Offer面试题-数组中的重复数字","date":"2019-08-19T07:20:05.000Z","updated":"2021-03-03T02:50:12.463Z","comments":true,"path":"2019/08/19/剑指Offer面试题-数组中的重复数字/","link":"","permalink":"http://sinlapis.github.io/2019/08/19/剑指Offer面试题-数组中的重复数字/","excerpt":"","text":"数组中的重复数字找出数组中重复的数字在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2, 3, 1, 0, 2, 5, 3}，那么对应的输出是第一个重复的数字2。 public class Q3 { public static int solution(int[] arr) { int i = 0; if (arr == null) return -1; for (int value : arr) { if (value &lt; 0 || value > arr.length - 1) return -1; } while (i &lt; arr.length) { if (arr[i] != i) { if (arr[i] == arr[arr[i]]) return arr[i]; int t = arr[i]; arr[i] = arr[arr[i]]; arr[t] = t; } else { i++; } } return -1; } } // Test class Q3Test { @Test void solution() { assertEquals(2, Q3.solution(new int[]{2, 3, 1, 0, 2, 5, 3})); assertEquals(-1, Q3.solution(new int[0])); assertEquals(-1, Q3.solution(null)); assertEquals(-1, Q3.solution(new int[]{0, 1, 2, 3})); assertEquals(-1, Q3.solution(new int[]{1, 2, 3})); } } 思路：从0号位开始，将值和下标对应起来，例如arr[0] == 2，那么就看arr[2]是不是2，是则2是其中一个重复数字，否则交换。如果当前位置下标和当前值相等就向后移动。 时间复杂度O(n)，空间复杂度O(1)。 不修改数组找出重复的数字在一个长度为n + 1的数组里的所有数字都在1到n的范围内。 数组中至少有一个数字是重复的，。请找出数组中任意一个重复的数字，但不修改数组。 例如，如果输入长度为8的数组{2, 3, 5, 4, 3, 2, 6, 7}，那么对应的输出是重复的数字2或3。 public class Q3_2 { public static int solution(int[] arr) { if (arr == null) return 0; int left = 1; int right = arr.length - 1; int big = 0, eq = 0, small = 0; int mid; while (left &lt; right) { mid = left + (right - left >> 1); for (int value : arr) { if (value >= left &amp;&amp; value &lt;= right) { if (value == mid) eq++; else if (value &lt; mid) small++; else big++; } } if (eq > 1) return mid; if (small > big) right = mid; else left = mid + 1; } return 0; } } // Test class Q3_2Test { @Test void solution() { int[] arr = {2, 3, 5, 4, 3, 2, 6, 7}; assertThat(Q3_2.solution(arr), anyOf(equalTo(2), equalTo(3))); assertArrayEquals(new int[]{2, 3, 5, 4, 3, 2, 6, 7}, arr); // 无重复 arr = new int[]{0, 1, 2}; assertEquals(Q3_2.solution(arr), 0); // null assertEquals(Q3_2.solution(null), 0); } } 思路：针对值范围进行二分查找。例如1-n，中间值为mid，先遍历数组，分别找出小于mid的个数small、等于mid的个数eq、大于mid的个数big。如果eq大于1，那说明为mid的元素有两个，即找到结果。否则，看small和big哪一个更大，则重复值在哪边。 时间复杂度O(nlogn)，空间复杂度O(1)","categories":[{"name":"算法","slug":"算法","permalink":"http://sinlapis.github.io/categories/算法/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"},{"name":"算法","slug":"算法","permalink":"http://sinlapis.github.io/tags/算法/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sinlapis.github.io/tags/剑指Offer/"},{"name":"数组","slug":"数组","permalink":"http://sinlapis.github.io/tags/数组/"}]},{"title":"Java8实战笔记0x07","slug":"Java8实战笔记0x07","date":"2019-08-19T01:48:25.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2019/08/19/Java8实战笔记0x07/","link":"","permalink":"http://sinlapis.github.io/2019/08/19/Java8实战笔记0x07/","excerpt":"","text":"CompletableFuture：组合异步编程（一）Future接口 Future接口是对将来某个时刻会发生的结果进行建模。它建模了一种异步计算，返回一个执行运算结果的引用，当运算结束后，这个引用被返回公文袋调用方。在Future中触发那些潜在耗时的操作把调用线程解放出来，让它能继续执行其他有价值的工作。 ExecutorService executor = Executors.newCachedThreadPool(); Future&lt;Double> future = executor.submit(new Callable&lt;Double> () { public Double call() { return doSomeLongComputation(); } }); doSomethingElse(); try { Double result = future.get(1, TimeUnit.SECONDS); } catch (ExecutionException ee) { ee.printStackTrace(); } catch (InterruptedException ie) { ie.printStackTrace(); } catch (TimeoutException te) { te.printStackTrace(); } Future接口的局限性 Future表达能力有限，某些异步计算用Future难以表达。 使用CompletableFuture构建异步应用将同步方法转换为异步方法class Shop { private Random random = new Random(47); public static void delay() { try { Thread.sleep(1000L); } catch (InterruptedException e) { throw new RuntimeException(e); } } private double calculatePrice(String product) { delay(); return random.nextDouble() * product.charAt(0) + product.charAt(1); } // 同步方法 public double getPrice(String product) { return calculatePrice(product); } // 异步方法 public Future&lt;Double> getPriceAsync(String product) { CompletableFuture&lt;Double> futurePrice = new CompletableFuture&lt;>(); new Thread(() -> futurePrice.complete(calculatePrice(product))).start(); return futurePrice; } } public class Main { public static void main(String[] args) throws Exception { Shop shop = new Shop(); long start = System.nanoTime(); Future&lt;Double> futurePrice = shop.getPriceAsync(\"my favorite product\"); long invocationTime = (System.nanoTime() - start) / 1_000_000; System.out.println(\"Invocation returned after \" + invocationTime + \" msecs\"); // 执行其它操作 Shop.delay(); try { double price = futurePrice.get(); System.out.printf(\"Price is %.2f%n\", price); } catch (Exception e) { throw new RuntimeException(e); } long retrievalTime = (System.nanoTime() - start) / 1_000_000; System.out.println(\"Price returned after \" + retrievalTime + \"msecs\"); } } 错误处理 如果异步方法发生错误，其异常会被限制在当前线程中，并且该线程最终会被杀死，而这会导致get方法永远阻塞。可以使用重载后的get方法，支持超时参数来防止永久阻塞，程序会得到TimeoutException。但是还是无法得知异步方法线程的错误原因，此时应该使用CompletableFuture的completeExceptionally方法将导致CompletableFuture内发生的问题抛出。 public Future&lt;Double> getPriceAsync(String product) { CompletableFuture&lt;Double> futurePrice = new CompletableFuture&lt;>(); new Thread(() -> { try { futurePrice.complete(calculatePrice(product)); } catch (Exception e) { futurePrice.completeExceptionally(e); } }).start(); return futurePrice; } 使用工厂方法创建CompletableFuture CompletableFuture.supplyAsync()是一个工厂方法，接受一个Supplier&lt;T&gt;参数，返回一个CompletableFuture对象。使用该方法创建的CompletableFuture与上面带有异常处理的代码是等价的。 public Future&lt;Double> geetPriceAsync(String product) { return CompletableFuture.supplyAsync(() -> calculatePrice(product)); } 免受阻塞class Shop { private Random random = new Random(); private String name; public Shop(String name) { this.name = name; } public String getName() { return name; } public static void delay() { try { Thread.sleep(1000L); } catch (InterruptedException e) { throw new RuntimeException(e); } } private double calculatePrice(String product) { delay(); return random.nextDouble() * product.charAt(0) + product.charAt(1); } // 同步方法 public double getPrice(String product) { return calculatePrice(product); } // 异步方法 public Future&lt;Double> getPriceAsync(String product) { CompletableFuture&lt;Double> futurePrice = new CompletableFuture&lt;>(); new Thread(() -> { try { futurePrice.complete(calculatePrice(product)); } catch (Exception e) { futurePrice.completeExceptionally(e); } }).start(); return futurePrice; } } public class Main { public static List&lt;String> findPrices(String product, List&lt;Shop> shops) { return shops.stream() .map(shop -> String.format(\"%s price is %.2f\", shop.getName(), shop.getPrice(product))) .collect(Collectors.toList()); } public static void main(String[] args) throws Exception { List&lt;Shop> shops = Arrays.asList( new Shop(\"BestPrice\"), new Shop(\"LetsSaveBig\"), new Shop(\"MyFavoriteShop\"), new Shop(\"BuyItAll\") ); long start = System.nanoTime(); System.out.println(findPrices(\"Fallout New Vegas\", shops)); long duration = (System.nanoTime() - start) / 1_000_000; System.out.println(\"Done in \" + duration + \" msecs\"); } } /* Output: [BestPrice price is 97.75, LetsSaveBig price is 118.44, MyFavoriteShop price is 98.66, BuyItAll price is 149.10] Done in 4013 msecs */ 使用并行流对请求进行并行操作public class Main { public static List&lt;String> findPrices(String product, List&lt;Shop> shops) { return shops.parallelStream() .map(shop -> String.format(\"%s price is %.2f\", shop.getName(), shop.getPrice(product))) .collect(Collectors.toList()); } public static void main(String[] args) throws Exception { List&lt;Shop> shops = Arrays.asList( new Shop(\"BestPrice\"), new Shop(\"LetsSaveBig\"), new Shop(\"MyFavoriteShop\"), new Shop(\"BuyItAll\") ); long start = System.nanoTime(); System.out.println(findPrices(\"Fallout New Vegas\", shops)); long duration = (System.nanoTime() - start) / 1_000_000; System.out.println(\"Done in \" + duration + \" msecs\"); } } /* Output: [BestPrice price is 163.63, LetsSaveBig price is 125.60, MyFavoriteShop price is 148.02, BuyItAll price is 118.71] Done in 1022 msecs */ 使用CompletableFuture发起异步请求public class Main { public static List&lt;String> findPrices(String product, List&lt;Shop> shops) { List&lt;CompletableFuture&lt;String>> priceFuture = shops.stream() .map(shop -> CompletableFuture.supplyAsync( () -> shop.getName() + \" price is \" + shop.getPrice(product) )) .collect(Collectors.toList()); return priceFuture.stream() .map(CompletableFuture::join) .collect(Collectors.toList()); } public static void main(String[] args) throws Exception { List&lt;Shop> shops = Arrays.asList( new Shop(\"BestPrice\"), new Shop(\"LetsSaveBig\"), new Shop(\"MyFavoriteShop\"), new Shop(\"BuyItAll\") ); long start = System.nanoTime(); System.out.println(findPrices(\"Fallout New Vegas\", shops)); long duration = (System.nanoTime() - start) / 1_000_000; System.out.println(\"Done in \" + duration + \" msecs\"); } } /* Output: [BestPrice price is 116.10675116625683, LetsSaveBig price is 159.1609417232611, MyFavoriteShop price is 166.64834055365026, BuyItAll price is 121.8279536327426] Done in 1044 msecs */ 此处执行时间远低于书中所述（2005 ms），比较接近并行流的性能。有待查证。和CPU逻辑处理器数量有关，运行环境是12核，因此当把商店数量改为13后，执行时间为2063 ms。 使用定制的执行器 可以使用线程池。线程池大小估算：T = N * U * (1 + W / C)，其中，T为线程池大小，N为CPU核数，U为期望的CPU利用率，W / C为等待时间与计算时间比率。 public class Main { private static final List&lt;Shop> shops = Arrays.asList( new Shop(\"BestPrice\"), new Shop(\"LetsSaveBig\"), new Shop(\"MyFavoriteShop\"), new Shop(\"BuyItAll\"), new Shop(\"Steam\"), new Shop(\"Epic\"), new Shop(\"GOG\"), new Shop(\"Taptap\"), new Shop(\"W\"), new Shop(\"V\"), new Shop(\"Z\"), new Shop(\"Y\"), new Shop(\"X\") ); private static final Executor executor = Executors.newFixedThreadPool( Math.min(shops.size(), 100), r -> { Thread t = new Thread(r); t.setDaemon(true); return t; }); public static List&lt;String> findPricesByFuture(String product) { List&lt;CompletableFuture&lt;String>> priceFuture = shops.stream() .map(shop -> CompletableFuture.supplyAsync( () -> shop.getName() + \" price is \" + shop.getPrice(product) )) .collect(Collectors.toList()); return priceFuture.stream() .map(CompletableFuture::join) .collect(Collectors.toList()); } public static List&lt;String> findPricesByFutureWithExec(String product) { List&lt;CompletableFuture&lt;String>> priceFuture = shops.stream() .map(shop -> CompletableFuture.supplyAsync( () -> shop.getName() + \" price is \" + shop.getPrice(product), executor )) .collect(Collectors.toList()); return priceFuture.stream() .map(CompletableFuture::join) .collect(Collectors.toList()); } public static void test(Function&lt;String, List&lt;String>> findPrices) { long start = System.nanoTime(); System.out.println(findPrices.apply(\"Fallout New Vegas\")); long duration = (System.nanoTime() - start) / 1_000_000; System.out.println(\"Done in \" + duration + \" msecs\"); } public static void main(String[] args) throws Exception { test(Main::findPricesByFuture); test(Main::findPricesByFutureWithExec); } } /* Output: [BestPrice price is 123.81188673960165, LetsSaveBig price is 134.2037700185142, MyFavoriteShop price is 108.25237001214239, BuyItAll price is 115.00922099155312, Steam price is 111.23106850193753, Epic price is 99.22328167208421, GOG price is 164.50758310616402, Taptap price is 121.17345205244206, W price is 123.06486848925549, V price is 138.86613263159464, Z price is 160.93733921008214, Y price is 150.61296275286742, X price is 151.1427293015105] Done in 2063 msecs [BestPrice price is 147.8957557234686, LetsSaveBig price is 115.91180890944013, MyFavoriteShop price is 145.9127196738407, BuyItAll price is 153.58049341481873, Steam price is 127.4807398778012, Epic price is 143.5858168683404, GOG price is 151.72178968386282, Taptap price is 140.27525423457325, W price is 142.2637869480202, V price is 115.3615656625179, Z price is 151.1027261194255, Y price is 121.78157514886323, X price is 150.22069837374056] Done in 1003 msecs */ 并行的方案选择 如果进行计算密集的操作，并且没有I/O，那么推荐使用Stream接口。反之，如果并行单元需要等待I/O操作，那么使用CompletableFuture灵活性更好，还可以根据需要设置线程数。而且，如果此时使用流，那么流的延迟特性会导致难以判断什么时候触发了等待。 流的延迟特性：Stream的操作由零个或多个中间操作和一个结束操作两部分组成。只有执行了结束操作，Stream定义的中间操作才会依次执行。","categories":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/categories/Java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://sinlapis.github.io/tags/笔记/"},{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"},{"name":"并发","slug":"并发","permalink":"http://sinlapis.github.io/tags/并发/"}]},{"title":"剑指Offer面试题-实现单例模式","slug":"剑指Offer面试题-实现单例模式","date":"2019-08-17T07:28:03.000Z","updated":"2021-03-03T02:50:12.463Z","comments":true,"path":"2019/08/17/剑指Offer面试题-实现单例模式/","link":"","permalink":"http://sinlapis.github.io/2019/08/17/剑指Offer面试题-实现单例模式/","excerpt":"","text":"实现单例模式懒汉式单例 懒汉式单例指第一次调用时才进行实例化。 双重检验锁class Singleton { private volatile static Singleton singleton = null; private Singleton() { } public static Singleton getSingleton() { if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; } } 构造函数应当设为private，获取单例函数应设为public static。 单例变量应当声明为volatile，禁止指令重排序。由于初始化实例singleton = new Singleton();不是原子操作，而是分为4个步骤： 申请内存空间 初始化默认值 执行构造器方法 连接引用和实例 其中3和4是可以重排序的。如果线程a执行顺序为1243，执行4后切换到线程b，此时单例变量不为空，线程b将获得一个没有初始化完成的对象。 synchronized上锁对象是Singleton.class。 synchronized代码块中还应该进行一次对实例的判空，因为如果线程a通过了第一个判空后，切换到线程b一直执行，直到创建单例再切回线程a，此时线程a已经不需要再创建单例了。 可见性由synchronized保证。 静态内部类class Singleton { private static Singleton singleton = null; private Singleton() { } private static class StaticSingleton { private static final Singleton SINGLETON = new Singleton(); } public static Singleton getSingleton() { return StaticSingleton.SINGLETON; } } 该方式是线程安全的，因为JVM在执行类的初始化阶段，会获得一个可以同步多个线程对同一个类的初始化的锁。假设线程a先进行了初始化，那么线程b一直等待初始化锁。线程a执行类初始化，即使发生了重排序，也不会影响线程a的初始化。线程a初始化完后，释放锁。线程b获得初始化锁，发现Singleton对象已经初始化完毕，释放锁，不进行初始化，获得Singleton对象。 上面的静态内部类式单例是不能防止反射攻击的，网上有些博客说是可以，我认为是错误的。攻击代码也是一般思路，也可能有优化空间。详见下面代码。 class Singleton { private static Singleton singleton = null; private Singleton() { } private static class StaticSingleton { private static final Singleton SINGLETON = new Singleton(); } public static Singleton getSingleton() { return StaticSingleton.SINGLETON; } } public class Main { public static void main(String[] args) throws IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException { // 保存初始单例 Singleton s = Singleton.getSingleton(); // 获取Singleton构造器，并创建一个新的实例 Constructor&lt;?> c = Singleton.class.getDeclaredConstructors()[0]; c.setAccessible(true); Singleton s2 = (Singleton)c.newInstance(); // 获取内部类的构造器，并创建一个实例（可能不需要此步骤，没有测试） Constructor&lt;?> in = Singleton.class.getDeclaredClasses()[0].getDeclaredConstructors()[0]; in.setAccessible(true); Object ins = in.newInstance(); // 获取单例成员变量 Field f = ins.getClass().getDeclaredFields()[0]; // 去除final修饰符（修改final成员通用方法） Field modifiersField = Field.class.getDeclaredField(\"modifiers\"); modifiersField.setAccessible(true); modifiersField.setInt(f, f.getModifiers() &amp; ~Modifier.FINAL); // 修改单例成员的值为新实例 f.setAccessible(true); f.set(ins, s2); // 比较 System.out.println(s.equals(Singleton.getSingleton()));; } } /* Output: WARNING: An illegal reflective access operation has occurred WARNING: Illegal reflective access by Main (file:./testJava/out/production/testJava/) to field java.lang.reflect.Field.modifiers WARNING: Please consider reporting this to the maintainers of Main WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations WARNING: All illegal access operations will be denied in a future release false */ 线程不安全class Singleton { private static Singleton singleton = null; private Singleton() { } public static Singleton getInstance() { if (singleton == null) { singleton = new Singleton(); } return singleton; } } 仅适用于单线程。 对象锁class Singleton { private static Singleton singleton = null; private Singleton() { } public static synchronized Singleton getInstance() { if (singleton == null) { singleton = new Singleton(); } return singleton; } } 线程安全，但是每次调用getInstance()时都会锁住对象，引起线程阻塞，效率较低。 饿汉式单例 指在类初始化时就已经实例化。 使用类实现public class Singleton { private static Singleton singleton = new Singleton(); private Singleton() { } public static Singleton getInstance() { return singleton; } } 线程安全，JVM会保证类只加载一次。 使用枚举实现public enum Singleton { INSTANCE; } 枚举实例只会初始化一次，因此可以保证是单例。 线程安全，同样JVM会保证枚举只加载一次。 枚举实现单例可以防止反射调用构造函数，枚举在反编译后是abstact class，无法实例化。并且在反射调用构造函数时会检查所调用的构造函数是否属于枚举类型的，若是则抛出异常。 枚举实现单例可以防止反序列化生成新的实例，因为枚举反序列化时则是通过java.lang.Enum的valueOf方法来根据名字查找枚举对象。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://sinlapis.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://sinlapis.github.io/tags/设计模式/"},{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://sinlapis.github.io/tags/剑指Offer/"},{"name":"单例模式","slug":"单例模式","permalink":"http://sinlapis.github.io/tags/单例模式/"}]},{"title":"Java8实战笔记0x06","slug":"Java8实战笔记0x06","date":"2019-08-17T02:48:10.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2019/08/17/Java8实战笔记0x06/","link":"","permalink":"http://sinlapis.github.io/2019/08/17/Java8实战笔记0x06/","excerpt":"","text":"用Optional取代null如何为缺失值建模class Person { private Car car; public Car getCar() { return car; } } class Car { private Insurance insurance; public Insurance getInsurance() { return insurance; } } class Insurance { private String name; public String getName() { return name; } } public class Main { public static String getCarInsuranceName(Person person) { return person.getCar().getInsurance().getName(); } } 一般情况下，如果Person没有Car，那么getCar()会设置为返回null，表示该值缺失。因此需要判断返回值是否为null来防止出现NullPointerException 采用防御式检查减少NullPointerException 深层质疑：会增加代码缩进层数，不具备扩展性，代码维护困难。 public static String getCarInsuranceName(Person person) { if (person != null) { Car car = person.getCar(); if (car != null) { Insurance insurance = car.getInsurance(); if (insurance != null) { return insurance.getName(); } } } return \"Unknown\"; } 过多的退出语句：退出点数量多，难以维护。 public static String getCarInsuranceName(Person person) { if (person == null) { return \"Unknown\"; } Car car = person.getCar(); if (car == null) { return \"Unknown\"; } Insurance insurance = car.getInsurance(); if (insurance == null) { return \"Unknown\"; } return insurance.getName(); } null带来的问题 错误之源：NullPointerException是目前Java程序开发中最典型的异常。 代码膨胀：需要深度嵌套null检查，可读性极差。 毫无意义：null自身没有任何语义，是以一种错误的方式对缺失值建模。 违反哲学：Java一直试图避免让程序员意识到指针的存在，但null指针例外。 类型缺失：null不属于任何类型，这意味着它可以被赋值给任何变量，而当这个变量传递给系统的其它部分时，将无法确定null变量最初是什么类型。 其他语言中null的替代品 Groovy：引入安全导航操作符，可以安全的访问可能为null的变量，避免抛出NullPointerException。 def carInsuranceName = person?.car?.insurance?.name Haskell：Maybe类型，本质上是optional值的封装。 Scala：Option[T]，要显式调用avaliable操作检查该变量是否有值，其实是变相的null检查。 Optional类简介 变量存在时，Optional类型只是对对象的简单封装。变量不存在时，缺失的值会被建模成一个“空”的Optional对象，由方法Optional.empty()返回。Optional.empty()方法是一个静态工厂方法，它返回Optional类的特定单一实例。 class Person { private Car car; public Optional&lt;Car> getCar() { return Optional.ofNullable(car); } } class Car { private Insurance insurance; public Optional&lt;Insurance> getInsurance() { return Optional.ofNullable(insurance); } } class Insurance { private String name; public String getName() { return name; } } Optional和null的重要语义区别是，Optional类清楚地表明允许发生变量缺失，null则不允许。在代码中，如果变量不能为null，那么也不需要为其添加null检查，因为null的检查只会掩盖问题，并未真正修复问题。 书中对应上面代码部分在声明成员变量时形如private Optional&lt;Car&gt; car，但此时IDEA报出警告&#39;Optional&#39; used as field or parameter type，参考StackOverFlow，Optional作为成员变量或者函数参数类型会导致不必要的包装和额外的解包逻辑，且无法序列化，因此只需在返回值处使用Optional。 应用Optional的几种模式创建Optional对象 声明一个空的Optional Optional&lt;Car> optCar = Optional.empty(); 依据一个非空值创建Optional Optional&lt;Car> optCar = Optional.of(car); 可接受null的Optional，如果传入null则获得空对象 Optional&lt;Car> optCar = Optional.ofNullable(car); 使用map从Optional对象中提取和转换值Optional&lt;Insurance> optInsurance = Optional.ofNullable(insurance); Optional&lt;String> name = optInsurance.map(Insurance::getName); 如果Optional包含一个值，那函数就将该值作为参数传递给map，对该值进行转换。如果Optional为空，就什么也不做。 使用flatMap链接Optional对象Optional&lt;Person> optPerson = Optional.of(person); //！Optional&lt;String> name = optPerson.map(Person::getCar) //！ .map(Car::getInsurance) //！ .map(Insurance::getName); 上面代码注释处无法通过编译。第一个map返回值类型是Optional&lt;Optional&lt;Car&gt;&gt;，而不是需要的Optional&lt;Car&gt;。 解决上述问题应该使用flatMap，flatMap方法接受一个函数作为参数，这个函数的返回值是另一个流。这个方法会应用到流的每一个元素，最终形成一个新的流。 // 与书中略有不同，详情见上 public static String getCarInsuranceName(Person person) { return Optional.ofNullable(person) .flatMap(Person::getCar) .flatMap(Car::getInsurance) .map(Insurance::getName) .orElse(\"Unknown\"); } 默认行为及解引用Optional对象 get()：如果变量存在则返回封装的变量值，否则抛出NoSuchElementException异常。不推荐使用。 orElse(T other)：如果变量存在则返回，否则返回传入的默认值。 orElseGet(Supplier&lt;? extends X&gt; other)：是orElse()的延迟调用版。传入的Supplier只有在变量不存在时调用。如果创建对象是耗时操作应该使用该方法。 orElseThrow(Supplier&lt;? extends x&gt; exceptionSupplier)：类似于get()，不过抛出的错误由传入的Supplier创建。 ifPresent(Consumer&lt;? extends T&gt; consumer)：在变量存在时执行传入的Consumer，否则就不进行任何操作。 两个Optional对象组合public Optional&lt;Insurance> safeFind(Person person, Car car) { return Optional.ofNullable(person) .flatMap( p -> Optional.ofNullable(car).map(c -> find(p, c)) ); } 首先，c -&gt; find(p, c)返回Insurance，而流的类型为Optional，因此不需要flatMap。之后p -&gt; Optional.ofNullable(car).map(c -&gt; find(p, c))得到的就是Optional&lt;Insurance&gt;，Optional.ofNullable(person)的流类型是Optional&lt;Person&gt;，因此需要flatMap。 使用filter剔除特定的值 filter方法接受一个谓词作为参数。如果Optional对象的值存在，并且它符合谓词条件，filter方法就返回其值；否则它就返回一个空的Optional对象。 public String getCarInsuranceName(Optional&lt;Person> person, int minAge) { return person.filter(p -> p.getAge() >= minAge) .flatMap(Person::getCar) .flatMap(Car::getInsurance) .map(Insurance::getName) .orElse(\"Unknown\"); } 使用Optional的实战示例用Optional封装可能为null的值// 原始代码 Object value = map.get(\"key\"); // if value != null ... // 使用Optional Optional&lt;Object> value = Optional.ofNullable(map.get(\"key\")); 异常与Optional对比// 将String转为Integer public static Optional&lt;Integer> stringToInt(String s) { try { return Optional.of(Integer.parseInt(s)); } catch (NumberFormatExcption e) { return Optional.empty(); } } // Java 9中添加了Stream.ofNullable，如果对象为null，则返回OptionalInt public OptionalInt stringToInt(String s) { return Stream.ofNullable(s) .filter(str -> str.matches(\"\\\\d+\")) .mapToInt(Integer::parseInt) .findAny(); }","categories":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/categories/Java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://sinlapis.github.io/tags/笔记/"},{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"}]},{"title":"Java8实战笔记0x05","slug":"Java8实战笔记0x05","date":"2019-08-15T12:58:23.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2019/08/15/Java8实战笔记0x05/","link":"","permalink":"http://sinlapis.github.io/2019/08/15/Java8实战笔记0x05/","excerpt":"","text":"默认方法 一旦类库设计者需要更新接口，向其中加入新的方法，继承该接口的代码就需要做出相应的修改。Java 8引入了新的解决方法，一是允许在接口中声明静态方法，二是引入默认方法，通过默认方法可以指定接口方法的默认实现，默认方法使用default修饰。 不断演进的API不同类型的兼容性 变更对Java程序的影响大体可以分成三种类型的兼容性： 二进制级的兼容性，表示现有的二进制执行文件能无缝持续链接（包括验证、准备和解析）和运行。例如向接口添加一个方法就是二进制级的兼容，如果添加方法不被调用，那么现有程序就不会出现错误。 源代码级的兼容性，表示引入变化之后，现有的程序依然能成功编译通过。例如向接口添加新的方法就不是源代码级的兼容，因为遗留代码没有实现新引入的方法，所以无法顺利通过编译。 函数行为的兼容性，表示变更发生之后，程序接受同样的输入能得到同样的结果。还是例如向接口添加新的方法，是函数行为兼容的，因为新的方法没有调用，或者被实现覆盖而没有影响其表现。 默认方法的使用模式可选方法 使用默认方法，可以为那些用户不会经常使用的，但是接口中包含的方法提供一个默认实现，这样实体类就无需在自己的实现中显示地提供一个空方法。 interface Iterator&lt;T> { boolean hasNext(); T next(); default void remove() { throw new UnsupportedOperationException(); } } 行为的多继承 类型的多继承：允许实现多个接口，而接口可以有默认实现，实质上实现了多继承。 用正交方法精简接口：分解实体类的不同功能点并设计接口，降低接口的重合度。 注意，继承不应该成为代码复用的万金油，例如继承一个100个方法的类就不是一个好选择，因为这会引入不必要的复杂性。可以使用代理模式有效的规避这类问题。 解决冲突的规则解决为题的三条规则 类中方法的优先级最高。类或父类中声明的方法的优先级高于任何声明为默认方法的优先级。 如果1.无法判断，那么子接口的优先级最高。函数签名相同时，优先选择拥有最具体实现的默认方法的接口，如果B继承了A，那么B比A更具体。 如果2.也无法判断，继承了多个接口的类必须通过显式覆盖和调用期望的方法。 注意，上图中D未覆盖hello()方法，但它实现了接口A，那么它拥有A的默认方法；此外，C实现了接口B，因此编译器会在接口A和接口B的hello()之间选择（而不是类D和接口B之间）。由于B 更加具体，所以会选择接口B的hello()方法。 冲突及如何显式地消除歧义 上图中，编译器将无法判断哪一个接口的实现更加具体，此时应该使用显式地声明来确定使用哪一个方法，或者覆盖它。 public class C implements B, A { void hello() { B.super.hello(); } } 菱形继承问题 上图中实际上只有一个方法可选，即接口A的默认方法。 此时接口B比接口A更加具体，因此使用接口B的hello()方法。 上面这种情况会出现冲突，需要显式指定方法。","categories":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/categories/Java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://sinlapis.github.io/tags/笔记/"},{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"}]},{"title":"jOOQ逆向生成Java代码","slug":"jOOQ逆向生成Java代码","date":"2019-08-15T03:32:24.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2019/08/15/jOOQ逆向生成Java代码/","link":"","permalink":"http://sinlapis.github.io/2019/08/15/jOOQ逆向生成Java代码/","excerpt":"","text":"jOOQ逆向生成Java代码引入要操作一下GeoIP库，打算接触一下ORM。又因为最近在看Stream，想找一种类似流水线的Java处理数据库相关的框架。jOOQ符合了我的需求。 官网文档连接 关于xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?> &lt;configuration xmlns=\"http://www.jooq.org/xsd/jooq-codegen-3.11.0.xsd\"> &lt;!-- Configure the database connection here --> &lt;jdbc> &lt;driver>com.mysql.jdbc.Driver&lt;/driver> &lt;url>jdbc:mysql://localhost:3306/library&lt;/url> &lt;user>root&lt;/user> &lt;password>&lt;/password> &lt;/jdbc> &lt;generator> &lt;!-- The default code generator. You can override this one, to generate your own code style. Supported generators: - org.jooq.codegen.JavaGenerator - org.jooq.codegen.ScalaGenerator Defaults to org.jooq.codegen.JavaGenerator --> &lt;name>org.jooq.codegen.JavaGenerator&lt;/name> &lt;database> &lt;!-- The database type. The format here is: org.jooq.meta.[database].[database]Database --> &lt;name>org.jooq.meta.mysql.MySQLDatabase&lt;/name> &lt;!-- The database schema (or in the absence of schema support, in your RDBMS this can be the owner, user, database name) to be generated --> &lt;inputSchema>library&lt;/inputSchema> &lt;!-- All elements that are generated from your schema (A Java regular expression. Use the pipe to separate several expressions) Watch out for case-sensitivity. Depending on your database, this might be important! --> &lt;includes>.*&lt;/includes> &lt;!-- All elements that are excluded from your schema (A Java regular expression. Use the pipe to separate several expressions). Excludes match before includes, i.e. excludes have a higher priority --> &lt;excludes>&lt;/excludes> &lt;/database> &lt;target> &lt;!-- The destination package of your generated classes (within the destination directory) --> &lt;packageName>test.generated&lt;/packageName> &lt;!-- The destination directory of your generated classes. Using Maven directory layout here --> &lt;directory>C:/workspace/MySQLTest/src/main/java&lt;/directory> &lt;/target> &lt;/generator> &lt;/configuration> 上面直接贴了官网样例。可能需要修改的有： 数据库连接jdbc 要生成Java代码对应的数据库名inputSchema 目标路径directory和目标包名packageName 生成步骤首先按官网文档所说，下载jooq-3.11.11.jar、jooq-codegen-3.11.11.jar、jooq-meta-3.11.11.jar以及mysql-connector-java-5.1.36.jar四个jar包到某个临时目录（例如D:\\temp），将上面的xml文件也放进该目录（命名为x.xml）。 java -classpath jooq-3.11.11.jar;jooq-meta-3.11.11.jar;jooq-codegen-3.11.11.jar;mysql-connector-java-5.1.36.jar;. org.jooq.codegen.GenerationTool x.xml 如果参考了官网的命令，注意去掉谜之换行以及MySQL驱动jar包名称后面的-bin。","categories":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"},{"name":"jOOQ","slug":"jOOQ","permalink":"http://sinlapis.github.io/tags/jOOQ/"}]},{"title":"Java8实战笔记0x04","slug":"Java8实战笔记0x04","date":"2019-08-12T13:05:45.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2019/08/12/Java8实战笔记0x04/","link":"","permalink":"http://sinlapis.github.io/2019/08/12/Java8实战笔记0x04/","excerpt":"","text":"重构、测试和调试为改善可读性和灵活性重构代码从匿名类到Lambda表达式的转换 将实现单一抽象方法的匿名类转换为Lambda表达式。 Runnable r1 = new Runnable() { public void run() { System.out.println(\"Hello\"); } }; Runnable r2 = () -> System.out.println(\"Hello\"); 转换时应当注意： 匿名类和Lambda表达式中的this和super的含义是不同的。在匿名类中，this代表的类是自身，但在Lambda中代表的是包含类（外部类）。 匿名类可以屏蔽包含类的变量，而Lambda表达式不能。 int a = 10; Runnable r1 = () -> { //! int a = 2; System.out.println(a); }; Runnable r2 = new Runnable() { int a = 2; //正确 System.out.println(a); }; 在涉及重载的上下文里，Lambda表达式将无法确定其类型，而匿名类则在初始化时确定了其类型。 interface Task { public void execute(); } public class Main { public static void test(Runnable runnable) { System.out.println(\"in runnable\"); runnable.run(); } public static void test(Task task) { System.out.println(\"in task\"); task.execute(); } public static void main(String[] args) { //! Main.test(() -> System.out.println(\"error\")); // 无法通过编译 // Error:(22, 13) java: 对test的引用不明确 // Main 中的方法 test(java.lang.Runnable) 和 Main 中的方法 test(Task) 都匹配 Main.test((Task) () -> System.out.println(\"right\")); // 使用强制转换，正确 } } 从Lambda表达式到方法引用的转换 为了改善代码的可读性，尽量使用方法引用，因为方法名往往能更直观地表达代码的意图。另外，还应该考虑使用静态辅助方法，比如comparing、maxBy。 从命令式的数据处理切换到Stream Stream API能更清晰地表达数据处理管道的意图。另外，通过短路和延迟载入以及利用多核，可以对Stream进行优化。但是这是一个困难的任务，因为要选择适当的流操作来还原控制流语句，例如break、continue以及return。 List&lt;String> dishName = new ArrayList&lt;>(); for (Dish dish: menu) { if (dish.getCalories() > 300) { dishNames.add(dish.getName()); } } menu.parallelStream() .filter(d -> d.getCalories() > 300) .map(Dish::getName) .collect(toList()); 使用Lambda重构面向对象的设计模式策略模式 策略模式代表了解决一类算法的通用解决方案，可以在运行时选择使用哪种方案。策略模式包含三部分内容： 一个代表某个算法的接口。 一个或多个该接口的具体实现，它们代表了算法的多种实现。 一个或多个使用策略对象的客户。 interface ValidationStrategy { boolean execute(String s); } class IsAllLowerCase implements ValidationStrategy { @Override public boolean execute(String s) { return s.matches(\"[a-z]+\"); } } class IsNumberic implements ValidationStrategy { @Override public boolean execute(String s) { return s.matches(\"\\\\d+\"); } } class Validator { private final ValidationStrategy strategy; public Validator(ValidationStrategy strategy) { this.strategy = strategy; } public boolean validate(String s) { return strategy.execute(s); } } public class Main { public static void main(String[] args) { Validator nv1 = new Validator(new IsNumberic()); boolean b1 = nv1.validate(\"aaa\"); Validator lv1 = new Validator(new IsAllLowerCase()); boolean b2 = lv1.validate(\"bbbb\"); Validator nv2 = new Validator((String s) -> s.matches(\"[a-z]+\")); b1 = nv2.validate(\"aaa\"); Validator lv2 = new Validator((String s) -> s.matches(\"\\\\d+\")); b2 = lv2.validate(\"bbb\"); } } 模版方法 如果需要采用某个算法的框架，同时又希望有一定的灵活度，能对它的某些部分进行改进，那么采用模版方法设计模式是比较通用的方案。 abstract class OnlineBanking { public void processCustomer(int id) { Custormer c = Database.getCustormerWithId(id); makeCustomerHappy(c); } abstract void makeCustomerHappy(Customer c); } 上面代码搭建的在线银行算法框架，不同的支行可以通过继承OnlineBanking来提供不同的服务。 class OnlineBanking { public void processCustomer(int id, Consumer&lt;Customer> makeCustomerHappy) { makeCustomerHappy.accept(c); } } //... new OnlineBanking().processCustomer(1337, (Customer c) -> System.out.println(\"Hello!\")); 观察者模式 观察者模式是，某些事件发生时（比如状态转变），如果一个对象（主题）需要自动地通知其他多个对象（观察者）。 // 观察者接口 interface Observer { void notify(String tweet); } // 不同的观察者 class NYTimes implements Observer { public void notify(String tweet) { if (tweet != null &amp;&amp; tweet.contains(\"money\")) { System.out.println(\"Breaking news in NY! \" + tweet); } } } class Guardian implements Observer { public void notify(String tweet) { if (tweet != null &amp;&amp; tweet.contains(\"queen\")) { System.out.println(\"Yet another news in London... \" + tweet); } } } class LeMonde implements Observer { public void notify(String tweet) { if (tweet != null &amp;&amp; tweet.contains(\"wine\")) { System.out.println(\"Today cheese, wine and news! \" + tweet); } } } // 主题接口 interface Subject { void registerObserver(Observer o); void notifyObservers(String tweet); } class Feed implements Subject { private final List&lt;Observer> observers = new ArrayList&lt;>(); public void registerObserver(Observer o) { this.observers.add(o); } public void notifyObservers(String tweet) { observers.forEach(o -> o.notify(tweet)); } } //... // 使用 Feed f = new Feed(); f.registerObserver(new NYTimes()); f.registerObserver(new Guardian()); f.registerObserver(new LeMonde()); f.notifyObservers(\"The queen said her favourite book is Java 8 in Action!\"); // 优化观察者声明和注册 f.registerObserver((String tweet) -> { if (tweet != null &amp;&amp; tweet.contains(\"money\")) { System.out.println(\"Breaking news in NY! \" + tweet); } }); //... 上面示例仅限简单的观察者模式。如果观察者的逻辑十分复杂，或者持有状态、定义了多个方法等等，此时应该继续使用类的方式。 责任链模式 责任链模式是一种创建处理对象序列的通用方案。一个处理对象可能需要在完成一些工作之后，将结果传递给另一个对象，这个对象接着做一些工作，再转交给下一个处理对象，以此类推。 // 处理抽象类 abstract class ProcessingObject&lt;T> { protected ProcessingObject&lt;T> successor; public void setSuccessor(ProcessingObject&lt;T> successor) { this.successor = successor; } public T handle(T input) { T r = handleWork(input); if (successor != null) { return successor.handle(r); } return r; } abstract protected T handleWork(T input); } // 处理类 class HeaderTextProcessing extends ProcessingObject&lt;String> { public String handleWord(String text) { return \"From Raoul, Mario and Alan: \" + text; } } class SpellCheckerProcessing extends ProcessingObject&lt;String> { public String handleWord(String text) { return text.replaceAll(\"labda\", \"lambda\"); } } // 使用 ProcessingObject&lt;String> p1 = new HeaderTextProcessing(); ProcessingObjct&lt;String> p2 = new SpellCheckerProcessing(); p1.setSuccessor(p2); String result = p1.handle(\"Aren't labdas really sexy?!!\"); System.out.println(result); // 使用Lambda优化处理对象实现和连接 UnaryOperator&lt;String> headerProcessing = (String text) -> \"From Raoul, Mario and Alan: \" + text; UnaryOperator&lt;String> spellCheckerProcessing = (String text) -> text.replaceAll(\"labda\", \"lambda\"); Function&lt;String, String> pipeline = headerProcessing.andThen(spellCheckerProcessing); String result = pipeline.apply(\"Aren't labdas really sexy?!!\"); 工厂模式 使用工厂模式，无需向客户端暴露实例化的逻辑就能完成对象的创建。 public class ProdectFactory { public static Product createProduct(String name) { switch(name) { case \"loan\": return new Loan(); case \"stock\": return new Stock(); case \"bond\": return new Bond(); default: throw new RuntimeException(\"No such product \" + name); } } } // ... // 使传统的工厂模式 Product p = ProductFactory.createProduct(\"loan\"); // 使用Lambda表达式优化工厂模式 final static Map&lt;String, Supplier&lt;Product>> map = new HashMap&lt;>(); static { map.put(\"load\", Loan::new); map.put(\"stock\", Stock::new); map.put(\"bond\", Bond::new); } public static Product createProduct(String name) { Supplier&lt;Product> p = map.get(name); if (p != null) return p.get(); throw new IllegalArgumentExcetption(\"No such product \" + name); } 测试 没有必要对Lambda表达式进行测试，更应该关注外围方法的的行为。 调试 方法引用的错误可以体现在栈跟踪中，而Lambda表达式由于没有名字，栈跟踪显示的错误会比较难以理解。此时应该使用日志调试，即在流水线中插入peek方法查看中间值。","categories":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/categories/Java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://sinlapis.github.io/tags/笔记/"},{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"}]},{"title":"Java8实战笔记0x03","slug":"Java8实战笔记0x03","date":"2019-08-08T12:08:34.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2019/08/08/Java8实战笔记0x03/","link":"","permalink":"http://sinlapis.github.io/2019/08/08/Java8实战笔记0x03/","excerpt":"","text":"并行数据处理与性能并行流将顺序流转换为并行流 可以把流转换成并行流，从而让前面的函数归约过程并行运行。对顺序流调用parallel()方法。 public static long parallelSum(long n) { return Stream.iterate(1L, i -> i + 1) .limit(n) .parallel() reduce(0L, Long::sum); } 对顺序流调用parallel()方法不意味着流本身有任何实际的变化。它内部实际上就是设了一个boolean标志，表示让调用parallel()方法之后进行的所有操作都并行执行。类似的，对并行流调用sequential()方法就可以把它变成顺序流。不过在一个流水线中，只有最后一个parallel()或者squential()方法生效，影响整个流水线。 高效使用并行流 首先应该进行测量。并行流并不总是比顺序流快。 留意装箱。自动装箱合拆箱操作会大大降低性能。可以使用原始类型流（IntStream、LongStream、DoubleStream）来避免这种操作。 有些操作本身在并行流上的性能就比顺序流差，特别是limit和findFirst等依赖于元素顺序的操作，它们在并行流上执行的代价非常大。 要考虑流的操作流水线的总计算成本。设N是要处理的元素总数，Q是一个元素通过流水线的大致处理成本，则N*Q就是这个对成本的一个粗略估计。Q值较高就意味着使用并行流时性能好的可能性比较大。 对于较小的数据量，选择并行流几乎不是一个好的决定。并行处理少数几个元素的好处还抵不上并行化造成的额外开销。 要考虑流背后的数据结构是否容易分解。例如ArrayList的拆分效率比LinkedList高得多，因为前者不用遍历就可以平均拆分，后者则必须遍历。 流自身的特点，以及流水线中的中间操作修改流的方式，都可能会改变分解过程的性能。例如一个流可以分成大小相同的两部分，这样每个部分都可以比较高效地并行处理，但筛选操作可能会丢弃的元素个数却无法预测，导致流的大小未知。 要考虑终端操作中合并步骤的代价。如果代价很大，那么组合每个子流产生的部分结果所付出的代价就可能会超过通过并行流得到的性能提升。 分支/合并框架 分支/合并框架的目的是以递归的方式将可以并行的任务拆分成更小的任务，然后将每个子任务的结果合并起来生成整体结果。它是ExecutorService接口的一个实现，它把子任务分配给线程池（称为ForkJoinPool）中的工作线程。 使用RecursiveTask 要把任务提交到线程池，必须创建RecursiveTask&lt;R&gt;的一个子类，其中R时并行化任务（以及所有子任务）产生的结果类型，或者如果任务不返回结果，则是RecursiveAction类型。要定义RecursiveTask只需要实现它唯一的抽象方法compute。这个方法同时定义了将任务拆分成子任务的逻辑，以及无法再久拆分或不方便再拆分时，生成单个子任务结果的逻辑。 class ForkJoinSumCalculator extends RecursiveTask&lt;Long> { private final long[] numbers; private final int start; private final int end; public static final long THRESHOLD = 10_000; public ForkJoinSumCalculator(long[] numbers, int start, int end) { this.numbers = numbers; this.start = start; this.end = end; } public ForkJoinSumCalculator(long[] numbers) { this(numbers, 0, numbers.length); } private long computeSequentially() { long sum = 0; for (int i = start; i &lt; end; i++) { sum += numbers[i]; } return sum; } @Override protected Long compute() { int length = end - start; if (length &lt;= THRESHOLD) { return computeSequentially(); } ForkJoinSumCalculator leftTask = new ForkJoinSumCalculator(numbers, start, start + (length >> 1)); leftTask.fork(); ForkJoinSumCalculator rightTask = new ForkJoinSumCalculator(numbers, start + (length >> 1), end); Long rightResult = rightTask.compute(); Long leftResult = leftTask.join(); return leftResult + rightResult; } public static long forkJoinSum(long n) { long[] numbers = LongStream.rangeClosed(1, n).toArray(); ForkJoinTask&lt;Long> task = new ForkJoinSumCalculator(numbers); return new ForkJoinPool().invoke(task); } } 使用分支/合并框架的最佳做法 对一个任务调用join方法会阻塞调用方，直到该任务做出结果。因此，有必要在两个子任务的计算都开始之后再调用它。否则会比原始的顺序算法更慢更复杂，因为每个子任务都必须等待另一个子任务完成才能启动。 不应该在RecursiveTask内部使用ForkJoinPool的invoke方法。相反，应该直接调用compute或fork方法，只有顺序代码才应该用invoke来启动并行计算。 对子任务调用fork方法可以把它排进ForkJoinPool。同时对左右两边的子任务调用fork的效率要比直接对其中一个调用compute低。直接调用compute可以为其中一个子任务重用同一线程，从而避免在线程池中多分配一个任务造成的开销。 调试使用分支/合并框架的并行计算可能有点棘手，特别是查看栈跟踪无法起作用，因为调用compute的线程并不是概念上的调用方。 和并行流一样，在多核处理器上使用分支/合并框架不一定比顺序执行快。分支/合并框架需要“预热”或者说要执行几遍才会被JIT编译器优化。 工作窃取 在理想情况下，划分并行任务时，应该让每个任务都用完全相同的时间完成，让所有的CPU内核都同样繁忙。但是实际上，每个子任务所花的时间可能天差地别，要么是因为划分策略效率低，要么是有不可预知的原因，例如磁盘访问慢，或是需要和外部服务进行协调执行。 分支/合并框架使用工作窃取来解决工作量不平衡的问题。在实际使用中，任务会被差不多地分配到ForkJoinPool中的所有线程上。每个线程都为分配给它的任务保存一个双向链式队列，每完成一个任务，就会从队列头上取出下一个任务开始执行。如果某个线程早早完成了分配给它的所有任务，也就是它的任务队列已经空了，而其它的线程还很忙。这时，该线程会随机选择一个别的线程，从其队尾“偷走”一个任务。这个过程一直继续下去，直到所有的任务都执行完毕，所有的队列都清空。这就是为什么要划成许多小任务而不是少数几个大任务，这有助于更好地在工作线程之间平衡负载。 Spliterator Spliterator，和Iterator一样用于遍历数据源中的元素，但它是为了并行执行而设计的。 // Spliterator接口定义 public interface Spliterator&lt;T> { boolean tryAdvance(Consumer&lt;? super T> action); Spliterator&lt;T> trySplit(); long estimateSize(); int characteristics(); } 拆分过程 将Stream拆分成多个部分的算法是一个递归过程，不断地对Spliterator调用trySplit直到它返回null。当所有的Spliterator都返回null则拆分终止。 Spliterator接口声明的最后一个抽象方法是characteristics，它将返回一个int，代表Spliterator本身特性集的编码。 特性 含义 ORDERED 元素有既定顺序（例如List），因此Spliterator在遍历和划分时也会遵守这一顺序 DISTINCT 对于任意一对遍历过的元素x和y，x.equals(y)返回false SORTED 遍历的元素按照一个预定义的顺序排序 SIZED 该Spliterator由一个已知大小的源建立（例如Set），因此estimatedSize()返回的是准确值 NONNULL 保证遍历的元素不会为null IMMUTABLE Spliterator的数据源不能被修改。这意味着在遍历时不能添加、删除或修改任何元素 CONCURRENT 该Spliterator的数据源可以被其他线程同时修改而无需同步 SUBSIZED 该Spliterator和所有从它拆分出来的Spliterator都是SIZED 实现自定义Spliteratorclass WordCounterSpliterator implements Spliterator&lt;Character> { private final String string; private int currentChar = 0; public WordCounterSpliterator(String string) { this.string = string; } @Override public boolean tryAdvance(Consumer&lt;? super Character> action) { action.accept(string.charAt(currentChar++)); return currentChar &lt; string.length(); } @Override public Spliterator&lt;Character> trySplit() { int currentSize = string.length() - currentChar; if (currentSize &lt; 10) { return null; } // 从中间开始，找下一个空白字符，然后拆分，以避免从单词中间拆开 for (int splitPos = (currentSize >> 1) + currentChar; splitPos &lt; string.length(); splitPos++) { if (Character.isWhitespace(string.charAt(splitPos))) { Spliterator&lt;Character> spliterator = new WordCounterSpliterator(string.substring(currentChar, splitPos)); currentChar = splitPos; return spliterator; } } return null; } @Override public long estimateSize() { return string.length() - currentChar; } @Override public int characteristics() { return ORDERED + SIZED + SUBSIZED + NONNULL + IMMUTABLE; } } class WordCounter { private final int counter; private final boolean lastSpace; public WordCounter(int counter, boolean lastSpace) { this.counter = counter; this.lastSpace = lastSpace; } // 遍历，见状态转换图 public WordCounter accumulate(Character c) { if (Character.isWhitespace(c)) { return lastSpace ? this : new WordCounter(counter, true); } else { return lastSpace ? new WordCounter(counter + 1, false) : this; } } // 归约方法，将两个WordCounter合并为一个 public WordCounter combine(WordCounter wordCounter) { return new WordCounter(counter + wordCounter.counter, wordCounter.lastSpace); } public int getCounter() { return counter; } } public class Main { private static int countWords(Stream&lt;Character> stream) { // 使用流归约 WordCounter wordCounter = stream.reduce( new WordCounter(0, true), WordCounter::accumulate, WordCounter::combine ); return wordCounter.getCounter(); } public static void main(String[] args) { final String SENTENCE = \" Nel mezzo del cammin di nostra vita mi ritrovai in una selva oscura\" + \" che la dritta via era smarrita \"; Spliterator&lt;Character> spliterator = new WordCounterSpliterator(SENTENCE); Stream&lt;Character> stream = StreamSupport.stream(spliterator, true); System.out.println(\"Found \" + Main.countWords(stream) + \" words\"); } } tryAdvance方法的行为类似于普通的Iterator，因为它会按顺序一个一个使用Spliterator中的元素，并且还有其他元素要遍历就返回true。在上面代码中，tryAdvance将当前位置的Character传给了Consumer，并让位置加一。作为参数传递的Consumer是一个Java内部类，在遍历流时将要处理的Character传给了一系列要对其执行的函数。这里传递给了accumulate()。 trySplit方法定义了拆分要遍历的数据结构的逻辑。首先要设定不再进一步拆分的下限，以避免生成太多的任务。拆分时，一旦找到合适的位置，就可以创建一个新的Spliterator来遍历从当前位置到拆分位置的子串。 estimatedSize是这个Spliterator解析的String的总长度和当前遍历位置的差。","categories":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/categories/Java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://sinlapis.github.io/tags/笔记/"},{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"}]},{"title":"Java8实战笔记0x02","slug":"Java8实战笔记0x02","date":"2019-08-05T12:40:09.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2019/08/05/Java8实战笔记0x02/","link":"","permalink":"http://sinlapis.github.io/2019/08/05/Java8实战笔记0x02/","excerpt":"","text":"用流收集数据归约和汇总查找流中的最大值和最小值 Collectors.maxBy和Collectors.minBy可以计算流中的最大或最小值。这两个收集器接收一个Comparator参数来比较流中的元素。 Comparator&lt;Dish> dishCaloriesComparator = Comparator.comparingInt(Dish::getCalories); Optional&lt;Dish> mostCalorieDish = menu.stream() .collect(Collectors.maxBy(DishCaloriesComparator)); 汇总 Collectors类专门为汇总提供了一个工厂方法Collectors.summingInt。它可接受一个把对象映射为求和所需int的函数，并返回一个收集器；该收集器在传递普通的collect方法后即执行所需要的汇总操作。类似的还有Collectors.summingLong和Collectors.summingDouble。 int totalCalories = menu.stream().collect(summingInt(Dish:getCalories)); Collectors.averagingInt，以及对应的Collectors.averagingLong和Collectors.averagingDouble可以计算数值的平均数。 double avgCalories = menu.stream().collect(averagingInt(Dish::getCalories)); summarizingInt工厂方法返回的收集器可以一次操作就得到流中元素的个数、所选值的总和、平均值、最大值、最小值。 IntSummaryStatistics menuStatistics = menu.stream().collect(summarizingInt(Dish::getCalories)); 连接字符串 joining工厂方法返回的收集器会把对流中每一个对象应用toString方法得到的所有字符串连接成一个字符串。 String shortMenu = menu.stream().map(Dish::getName).collect(joining()) joining在内部使用了StringBuilder来把生成的字符串逐个追加起来。此外，如果对象有toString()方法，那么可以省略map映射。 String shortMenu = menu.stream().collect(joining()); joining()还接受一个字符串作为分界符。 String shortMenu = menu.stream().map(Dish::getName).collect(joining(\", \")); 广义的归约汇总 reduce工厂方法则是所有归约情况的一般化，它需要三个参数：初始值、转换函数、累积函数（将两个项目累积成一个同类型的值）。 int totalCalories = menu.stream().collect(reducing(0, Dish::getCalories, Integer::sum)); 分组 可以使用Collectors.groupingBy工厂方法返回的收集器来实现元素分组。 Map&lt;Dish.Type, List&lt;Dish>> dishesByType = menu.stream(groupingBy(Dish::getType)); 在上面代码中，groupingBy方法接受一个分类函数，用于提取元素的类别从而对元素进行分组。分组的操作结果是一个Map，分组函数返回的值作为映射的键，流中所有具有这个分类值的项目的列表作为对应的映射值。如果没有现成的获取元素类别的函数，可以传入Lambda。 public enum ColaricLevel { DIET, NORMAL, FAT } Map&lt;CaloricLevel, List&lt;Dish>> dishesByCaloricLevel = menu.stream().collect( groupingBy(dish -> { if (dish.getCalories() &lt;= 400) return CaloricLevel.DIET; else if (dish.getCalories() &lt;= 700) return CaloricLevel.NORMAL; else return CaloricLevel.FAT; }) ); 多级分组 Collectors.groupingBy有双参数版本，第二个参数为collector类型。进行二级分组时，可以把一个内层groupingBy传递给外层groupingBy，并定义一个为流中项目分类的二级标准。 Map&lt;Dish.Type, Map&lt;CaloricLevel, List&lt;Dish>>> dishesByTypeCaloricLevel = menu.stream().collect( groupingBy(Dish::getType, groupingBy(dish -> { if (dish.getCalories() &lt;= 400) return CaloricLevel.DIET; else if (dish.getCalories() &lt;= 700) return CaloricLevel.NORMAL; else return CaloricLevel.FAT; })) ); 按子组收集数据 groupingBy的第二个参数也可以是其它collect。 // 分组求和 Map&lt;Dish.Type, Long> typesCount = menu.stream().collect(groupingBy(Dish::getType, counting())); // 找出分组最大值 Map&lt;Dish.Type, Optional&lt;Dish>> mostCaloricByType = menu.stream().collect(groupingBy( Dish::getType, maxBy(comparingInt(Dish::getCalories)) )); Collectors.collectingAndThen可以把收集器返回的结果转换为另一种类型。 Map&lt;Dish.Type, Dish> mostCaloricByType = menu.stream().collect(groupingBy( Dish::getType, collectingAndThen(maxBy(comparingInt(Dish::getCalories)), Optional::get) )); 分区 分区是分组的特殊情况：由一个谓词作为分类函数，它成为分区函数。分区函数返回一个布尔值，这意味着得到的分组Map的键类型是Boolean，于是它最多可以分为两组，true一组false一组。类似groupingBy可以进行多级分区。 Map&lt;Boolean, List&lt;Dish>> partitionedMenu = menu.stream().collect(partitioningBy(Dish::isVegetarian)); 收集器接口// Collector接口定义 public interface Collector&lt;T, A, R> { Supplier&lt;A> supplier(); BiConsumer&lt;A, T> accumulator(); Function&lt;A, R> finisher(); BinaryOperator&lt;A> combiner(); Set&lt;Characteristics> characteristics(); } 接口解析泛型 T是流中要收集的项目的泛型；A是累加器的类型，累加器是在收集过程中用于累积部分结果的对象；R是收集操作得到的对象（一般情况下是集合，但也有可能不是）。 方法 supplier方法：用于创建一个空的累加器实例，供数据收集过程使用 public Supplier&lt;List&lt;T>> suplier() { return () -> new ArrayList&lt;T>; } // 或者传递构造函数引用 public Supplier&lt;List&lt;T>> suplier() { return ArrayList::new; } accumulator方法：返回执行归约操作的函数。当遍历到流中第n个元素时，这个函数执行时会有两个参数，保存归约结果的累加器（已收集了流中的n - 1个项目），以及第n个元素本身。该函数将返回void，因为是累加器的原位更新，即函数的执行改变了它的内部状态以体现遍历的元素的效果。 public BiConsumer&lt;List&lt;T>, T> accumulator() { return (list, item) -> list.add(item); } // 或者传递构造函数引用 public BiConsumer&lt;List&lt;T>, T> accumulator() { return List::add; } finisher方法：在遍历完流后，finisher方法必须返回累积过程的最后要调用的一个函数，以便将累加器对象转换为整个集合操作的最终结果。如果不需要进行转换，可以返回Function.identity()，该函数直接返回对象本身，即return t -&gt; t;。 public Function&lt;List&lt;T>, List&lt;T>> finisher() { return Function.identity(); } combiner方法：返回一个供归约操作使用的函数，它定义了对流的各个子部分进行并行处理时，各个子部分归约所得到的累加器要如何合并。 public BinaryOperator&lt;List&lt;T>> combiner() { return (list1, list2) -> { list1.addAll(list2); return list1; } } 并行归约流程 原始流会以递归方式拆分为子流，直到定义流是否需要进一步拆分的一个条件为非。 对所有的子流并行处理，即对每个子流应用归约算法。 使用收集器combiner方法返回的函数，将所有的部分结果两两合并。 characteristics方法：返回一个不可变的Characteristics集合，它定义了收集器的行为，尤其是关于流是否可以并行归约，以及可以使用哪些优化的提示。Characteristics是一个包含三个项目的枚举： UNORDERED：归约结果不受流中项目的遍历和累积顺序的影响 CONCURRENT：accumulator函数可以从多个线程同时调用，且该收集器可以并行归约流。如果收集器没有标为UNORDERED，那它仅在用于无序数据源才可以并行归约。 IDENTITY_FINISH：这表明完成器方法返回的函数是一个恒等函数，可以跳过。这种情况下，类累加器对象将会直接用作归约过程的最终结果。这也就意味着，将累加器A不加检查地转换为结果R是安全的。 进行自定义收集而不实现接口 collector的一个重载版本可以接受三个参数，supplier、accumulator、combiner。 List&lt;Dish> dishes = menuStream.collect( ArrayList::new, List::add, List::addAll );","categories":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/categories/Java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://sinlapis.github.io/tags/笔记/"},{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"}]},{"title":"Java编程思想笔记0x17","slug":"Java编程思想笔记0x17","date":"2019-08-02T01:39:46.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2019/08/02/Java编程思想笔记0x17/","link":"","permalink":"http://sinlapis.github.io/2019/08/02/Java编程思想笔记0x17/","excerpt":"","text":"并发（四）死锁 任务之间相互等待的连续循环，没有哪个线程能够继续执行，即死锁。 死锁发生的条件： 互斥条件。任务使用的资源中至少有一个是不能共享的。 允许持有资源等待。至少有一个任务必须持有一个资源并且正在等待获取一个当前被别的任务持有的资源。 资源不能被抢占，任务必须把资源释放当作普通事件。 循环等待。一个任务等待其他任务所持有的资源，后者又在等待另一个任务所持有的资源，这样一直下去，直到有一个任务在等待第一个任务所持有的资源，使得所有任务都被锁住。 部分类库的构件CountDownLatch CountDownLatch用来同步一个或多个任务，强制它们等待由其他任务执行的一组操作完成。 可以向CountDownLatch对象设置一个初始计数值，任何在这个对象上调用wait()的方法都将阻塞，直至这个计数值到达0。其他任务结束其工作时，可以在该对象上调用countDown()来减小这个计数值。CountDownLatch设计为只触发一次，计数值不能被重置。 调用countDown()的任务在产生这个调用时并没有被阻塞，只有对await()的调用会被阻塞，直至计数值到达0。 class TaskPortion implements Runnable { private static int counter = 0; private final int id = counter++; private static Random random = new Random(47); private final CountDownLatch latch; public TaskPortion(CountDownLatch latch) { this.latch = latch; } @Override public void run() { try { doWork(); latch.countDown(); } catch (InterruptedException e) { e.printStackTrace(); } } public void doWork() throws InterruptedException { TimeUnit.MILLISECONDS.sleep(random.nextInt(2000)); System.out.println(this + \"completed\"); } @Override public String toString() { return String.format(\"%1$-3d \", id); } } class WaitingTask implements Runnable { private static int counter = 0; private final int id = counter++; private final CountDownLatch latch; public WaitingTask(CountDownLatch latch) { this.latch = latch; } @Override public void run() { try { latch.await(); System.out.println(\"Latch barrier passed for \" + this); } catch (InterruptedException e) { System.out.println(this + \" interrupted\"); } } @Override public String toString() { return String.format(\"WaitingTask %1$-3d\", id); } } public class Main { static final int SIZE = 100; public static void main(String[] args) throws Exception { ExecutorService exec = Executors.newCachedThreadPool(); CountDownLatch latch = new CountDownLatch(SIZE); for (int i = 0; i &lt; 10; i++) exec.execute(new WaitingTask(latch)); for (int i = 0; i &lt; SIZE; i++) exec.execute(new TaskPortion(latch)); System.out.println(\"Launched all tasks\"); exec.shutdown(); } } CyclicBarrier 一组任务并行执行工作，然后在进行下一个步骤之前等待，直至所有任务都完成。它使得所有的并行任务都将在栅栏处列队，因此可以一致地向前移动，非常像CountDownLatch，只是CountDownLatch是只触发一次的事件，而CyclicBarrier可以多次重用。 class Horse implements Runnable { private static int counter = 0; private final int id = counter++; private int strides = 0; private static Random random = new Random(47); private static CyclicBarrier cyclicBarrier; public Horse(CyclicBarrier cyclicBarrier) { Horse.cyclicBarrier = cyclicBarrier; } public synchronized int getStrides() { return strides; } @Override public void run() { try { while (!Thread.interrupted()) { synchronized (this) { strides += random.nextInt(3); } cyclicBarrier.await(); } } catch (InterruptedException e) { e.printStackTrace(); } catch (BrokenBarrierException e) { throw new RuntimeException(e); } } @Override public String toString() { return \"Horse \" + id + \" \"; } public String tracks() { return \"*\".repeat(Math.max(0, getStrides())) + id; } } public class Main { private static final int FINISH_LINE = 75; private List&lt;Horse> horseList = new ArrayList&lt;>(); private ExecutorService exec = Executors.newCachedThreadPool(); private Main(int nHorses, final int pause) { CyclicBarrier cyclicBarrie = new CyclicBarrier(nHorses, () -> { System.out.println(\"=\".repeat(FINISH_LINE)); for (Horse horse : horseList) System.out.println(horse.tracks()); for (Horse horse : horseList) if (horse.getStrides() >= FINISH_LINE) { System.out.println(horse + \"won!\"); exec.shutdownNow(); return; } try { TimeUnit.MILLISECONDS.sleep(pause); } catch (InterruptedException e) { System.out.println(\"barrier action sleep\"); } }); for (int i = 0; i &lt; nHorses; i++ ) { Horse horse = new Horse(cyclicBarrie); horseList.add(horse); exec.execute(horse); } } public static void main(String[] args) throws Exception { int nHorses = 7; int pause = 200; new Main(nHorses, pause); } } 可以向CyclicBarrier提供一个“栅栏动作”，一个Runnable，当计数值到达0时自动执行。这是与CountDownLatch的另一个区别。 DelayQueue 一个无界的BlockingQueue，用于放置实现了Delayed接口的对象，其中的对象只能在其到期时才能从队列中取走。这种队列是有序的，即队头对象的延迟到期的时间最长。如果没有任何延迟到期，那么就不会有任何头元素，并且poll()将返回null。 延迟到期时间略带误导，指设定的到期时间减去当前时间，因此DelayQueue中元素排列是按设定时间从小到大排列。 class DelayedTask implements Runnable, Delayed { private static int counter = 0; private final int id = counter++; private final int delta; private final long trigger; protected static List&lt;DelayedTask> sequence = new ArrayList&lt;>(); public DelayedTask(int delta) { this.delta = delta; trigger = System.nanoTime() + TimeUnit.NANOSECONDS.convert(this.delta, TimeUnit.MILLISECONDS); sequence.add(this); } @Override public long getDelay(TimeUnit unit) { return unit.convert(trigger - System.nanoTime(), TimeUnit.NANOSECONDS); } @Override public int compareTo(Delayed arg) { DelayedTask that = (DelayedTask) arg; return Long.compare(trigger, that.trigger); } @Override public void run() { System.out.println(this + \" \"); } @Override public String toString() { return String.format(\"[%1$-4d]\", delta) + \" Task \" + id; } public String summary() { return \"(\" + id + \": \" + delta + \")\"; } public static class EndSentinel extends DelayedTask { private ExecutorService exec; public EndSentinel(int delay, ExecutorService e) { super(delay); exec = e; } @Override public void run() { for (DelayedTask pt: sequence) { System.out.println(pt.summary() + \" \"); } System.out.println(this + \" Calling shutdownNow()\"); exec.shutdownNow(); } } } class DelayedTaskConsumer implements Runnable { private DelayQueue&lt;DelayedTask> q; public DelayedTaskConsumer(DelayQueue&lt;DelayedTask> q) { this.q = q; } @Override public void run() { try { while (!Thread.interrupted()) q.take().run(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"Finished DelayedTaskConsumer\"); } } public class Main { public static void main(String[] args) throws Exception { Random random = new Random(47); ExecutorService exec = Executors.newCachedThreadPool(); DelayQueue&lt;DelayedTask> queue = new DelayQueue&lt;>(); for (int i = 0; i &lt; 20; i++) queue.put(new DelayedTask(random.nextInt(5000))); queue.add(new DelayedTask.EndSentinel(5000, exec)); exec.execute(new DelayedTaskConsumer(queue)); } } Delayed接口有一个方法名为getDelay()，它可以用来告知延迟到期有多长时间，或者到场时间之前已经到期。比起BlockingQueue，DelayQueue#take()会在没有元素或者没有元素到期时阻塞。 PriorityBlockingQueue 与上面DelayQueue类似，只不过优先级是人为指定。 class PriorizedTask implements Runnable, Comparable&lt;PriorizedTask> { private Random random = new Random(47); private static int counter = 0; private final int id = counter++; private final int priority; protected static List&lt;PriorizedTask> sequence = new ArrayList&lt;>(); public PriorizedTask(int priority) { this.priority = priority; sequence.add(this); } @Override public int compareTo(PriorizedTask o) { return Integer.compare(priority, o.priority); } @Override public void run() { try { TimeUnit.MILLISECONDS.sleep(random.nextInt(250)); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(this); } @Override public String toString() { return String.format(\"[%1$-3d]\", priority) + \" Task \" + id; } public String summary() { return \"(\" + id + \": \" + priority + \")\"; } public static class EndSentinel extends PriorizedTask { private ExecutorService exec; public EndSentinel(ExecutorService exec) { super(-1); this.exec = exec; } @Override public void run() { int count = 0; for (PriorizedTask pt: sequence) { System.out.println(pt.summary()); if (++count % 5 == 0) System.out.println(); } System.out.println(this + \" Calling shutdownNow()\"); exec.shutdownNow(); } } } class PrioritizedTaskProducer implements Runnable { private Random random = new Random(47); private Queue&lt;Runnable> queue; private ExecutorService exec; public PrioritizedTaskProducer(Queue&lt;Runnable> queue, ExecutorService exec) { this.queue = queue; this.exec = exec; } @Override public void run() { for (int i = 0; i &lt;20; i++) { queue.add(new PriorizedTask(random.nextInt(10))); Thread.yield(); } try { for (int i = 0; i &lt; 10; i++) { TimeUnit.MILLISECONDS.sleep(250); queue.add(new PriorizedTask(10)); } for (int i = 0; i &lt; 10; i++) { queue.add(new PriorizedTask(i)); } queue.add(new PriorizedTask.EndSentinel(exec)); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"Finished PrioritizedTaskProducer\"); } } class PrioritizedTaskConsumer implements Runnable { private PriorityBlockingQueue&lt;Runnable> q; public PrioritizedTaskConsumer(PriorityBlockingQueue&lt;Runnable> q) { this.q = q; } @Override public void run() { try { while (!Thread.interrupted()) { q.take().run(); } } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"Finished PrioritizedTaskConsumer\"); } } public class Main { public static void main(String[] args) throws Exception { ExecutorService exec = Executors.newCachedThreadPool(); PriorityBlockingQueue&lt;Runnable> queue = new PriorityBlockingQueue&lt;>(); exec.execute(new PrioritizedTaskProducer(queue, exec)); exec.execute(new PrioritizedTaskConsumer(queue)); } } ScheduledExecutorService ScheduledThreadPoolExecutor提供schedule()（运行一次任务）和scheduleAtFixedRate()（可以设定初次延迟和再次运行间隔时间）来自动调度Runnable对象。 Semaphorepublic class Main { private static final int COUNT = 40; private static Executor executor = Executors.newFixedThreadPool(COUNT); private static Semaphore semaphore = new Semaphore(10); public static void main(String[] args) { for (int i = 0; i &lt; COUNT; i++) { executor.execute(new Main.Task()); } } static class Task implements Runnable { @Override public void run() { try { semaphore.acquire(); // 使用资源 semaphore.release(); } catch (InterruptedException e) { e.printStackTrace(); } } } } Exchanger 可以让两个线程（只能是两个）交换一个对象。先调用exchange()的线程阻塞，直到另一个线程也调用exchange()。 class Producer&lt;T> extends Thread { private List&lt;T> list = new ArrayList&lt;>(); private Exchanger&lt;List&lt;T>> exchanger; private Supplier&lt;T> supplier; public Producer(Exchanger&lt;List&lt;T>> exchanger, Supplier&lt;T> supplier) { super(); this.exchanger = exchanger; this.supplier = supplier; } @Override public void run() { list.clear(); for (int i = 0; i &lt; 5; i++) { list.add(supplier.get()); } try { list = exchanger.exchange(list); } catch (InterruptedException e) { e.printStackTrace(); } } } class Consumer&lt;T> extends Thread { private List&lt;T> list = new ArrayList&lt;>(); private Exchanger&lt;List&lt;T>> exchanger; public Consumer(Exchanger&lt;List&lt;T>> exchanger) { super(); this.exchanger = exchanger; } @Override public void run() { try { list = exchanger.exchange(list); } catch (InterruptedException e) { e.printStackTrace(); } System.out.print(\"From Producer: \"); System.out.print(list); } } public class Main { public static void main(String[] args) { Exchanger&lt;List&lt;Integer>> exchanger = new Exchanger&lt;>(); Random random = new Random(47); new Consumer&lt;>(exchanger).start(); new Producer&lt;>(exchanger, () -> random.nextInt(100)).start(); } }","categories":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/categories/Java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://sinlapis.github.io/tags/笔记/"},{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"}]},{"title":"Java编程思想笔记0x16","slug":"Java编程思想笔记0x16","date":"2019-07-30T12:24:33.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2019/07/30/Java编程思想笔记0x16/","link":"","permalink":"http://sinlapis.github.io/2019/07/30/Java编程思想笔记0x16/","excerpt":"","text":"并发（三）线程之间的协作wait()与notifyAll() wait()会将任务挂起，并且只有notify()和notifyAll()发生时，即表示发生了某些感兴趣的食物，这个任务才会被唤醒并去检查所产生的变化。因此，wait()提供了一种在任务之间对活动同步对方式。 与sleep()的区别： 在wait()期间对象锁时释放的 可以通过notify()、notifyAll()，或者令时间到期，从wait()中恢复执行 调用sleep()、yield()时锁并不会释放。 wait()、notify()、notifyAll()是基类Object的一部分，而不是Thread的一部分。 wait()、notify()、notifyAll()可以并且只能同步控制方法或者同步控制块中调用，如果在非同步部分调用会得到IllegalMonitorStateException异常，即调用这些方法必须拥有（或者）对象的锁。 错失信号// T1 synchronized(sharedMonitor) { shareMonitor.notify(); } // T2 while (trye) { synchronized(shareMonitor) { sharedMonitor.wait(); } } 在上面代码中，如果先执行了T1中的notify()后执行T2中的wait()，此时T2已经错失了T1发来的信号，从而产生了死锁。T2的改进方法见下面代码。 synchronized (sharedMonitor) { while (someCondition) sharedMonitor.wait(); } 此时如果T1先执行，由于条件改变，T2就不会进入wait()。此外，这种方式还能防止被错误唤醒，如果被错误唤醒但还满足等待条件时会继续进入wait()。 notifyAll()因某个特定锁而被调用时，只有等待这个锁的任务才会被唤醒。 使用wait()和notifyAll()进行线程协作class Meal { private final int orderNum; public Meal(int orderNum) { this.orderNum = orderNum; } @Override public String toString() { return \"Meal \" + orderNum; } } class WaitPerson implements Runnable { private Restaurant restaurant; public WaitPerson(Restaurant restaurant) { this.restaurant = restaurant; } @Override public void run() { try { while (!Thread.interrupted()) { synchronized (this) { while (restaurant.meal == null) wait(); } System.out.println(\"Waitperson got \" + restaurant.meal); synchronized (restaurant.chef) { restaurant.meal = null; restaurant.chef.notifyAll(); } } } catch (InterruptedException e) { System.out.println(\"WaitPerson interrupted\"); } } } class Chef implements Runnable { private Restaurant restaurant; private int count = 0; public Chef(Restaurant restaurant) { this.restaurant = restaurant; } @Override public void run() { try { while (!Thread.interrupted()) { synchronized (this) { while (restaurant.meal != null) wait(); } if (++count == 10) { System.out.println(\"Out of food, closing\"); restaurant.exec.shutdownNow(); } System.out.println(\"Order up!\"); synchronized (restaurant.waitPerson) { restaurant.meal = new Meal(count); restaurant.waitPerson.notifyAll(); } TimeUnit.MILLISECONDS.sleep(100); } } catch (InterruptedException e) { System.out.println(\"Chef interrupted\"); } } } class Restaurant { public Meal meal; ExecutorService exec = Executors.newCachedThreadPool(); WaitPerson waitPerson = new WaitPerson(this); Chef chef = new Chef(this); public Restaurant() { exec.execute(chef); try { TimeUnit.SECONDS.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } exec.execute(waitPerson); } } public class Main { public static void main(String[] args) throws InterruptedException { new Restaurant(); } } 上面代码使用wait()和notifyAll()的主要原因是减少资源竞争，从而降低CPU资源使用。实际上单生产者单消费者在不考虑资源使用的情况下，是没有必要加锁的。 上面代码中只有一个任务，理论上可以调用notify()而不是notifyAll()。但是，在更复杂的情况下，可能会有多个任务在某个特定的对象锁上等待，因此无法知道哪个任务应该被唤醒。因此，调用notifyAll()要更安全一些，这样可以唤醒等待这个锁的所有任务，而每个任务都必须决定这个通知是否与自己相关。（因为获取对象锁之后，线程的行为并不确定，因此应当使用notifyAll()来唤醒所有线程，每个线程来检查自己是否应当被唤醒。） 使用显式的Lock对象和Condition对象 可以使用显式的操作来进行同步与协作。使用互斥并允许任务挂起的基本类时Condition，可以通过在Condition上调用await()来挂起一个任务。当外部条件发生变化，意味着某个任务应该继续执行时，可以通过调用signal()来通知这个任务，从而唤醒一个任务，或者调用signalAll()来唤醒所有在这个Condition上被其自身挂起的任务。 class Car { private Lock lock = new ReentrantLock(); private Condition condition = lock.newCondition(); private boolean waxOn = false; public void waxed() { lock.lock(); try { waxOn = true; condition.signalAll(); } finally { lock.unlock(); } } public void buffed() { lock.lock(); try { waxOn = false; condition.signalAll(); } finally { lock.unlock(); } } public void waitForWaxing() throws InterruptedException { lock.lock(); try { while (!waxOn) condition.await(); } finally { lock.unlock(); } } public void waitForBuffing() throws InterruptedException { lock.lock(); try { while (waxOn) condition.await(); } finally { lock.unlock(); } } } class WaxOn implements Runnable { private Car car; public WaxOn(Car car) { this.car = car; } @Override public void run() { try { while (!Thread.interrupted()) { System.out.println(\"Wax on\"); TimeUnit.MILLISECONDS.sleep(200); car.waxed(); car.waitForBuffing(); } } catch (InterruptedException e) { System.out.println(\"Exiting via interrupt\"); } System.out.println(\"Exiting Wax On task\"); } } class WaxOff implements Runnable { private Car car; public WaxOff(Car car) { this.car = car; } @Override public void run() { try { while (!Thread.interrupted()) { car.waitForWaxing(); System.out.println(\"Wax Off!\"); TimeUnit.MILLISECONDS.sleep(200); car.buffed(); } } catch (InterruptedException e) { System.out.println(\"Exiting via interrupt\"); } System.out.println(\"Exiting Wax Off task\"); } } public class Main { public static void main(String[] args) throws InterruptedException { Car car = new Car(); ExecutorService exec = Executors.newCachedThreadPool(); exec.execute(new WaxOff(car)); exec.execute(new WaxOn(car)); TimeUnit.SECONDS.sleep(5); exec.shutdownNow(); } } 单个Lock将产生一个Condition对象，这个对象用可以管理任务之间的通信。但是，Condition对象不含任何有关处理状态的信息，因此需要额外的变量来负责表示处理状态的信息，如上面代码中的waxOn。 生产者-消费者队列 同步队列时更高级别的抽象，同样可以解决任务协作问题，同步队列在任何时刻都只允许一个任务插入或移除元素。在java.util.concurrent.BlockingQueue接口中提供了这种队列。其实现LinkedBlockingQueue是一个无界队列，ArrayBlockingQueue则有固定尺寸。 class Toast { public enum Status {DRY, BUTTERED, JAMMED} private Status status = Status.DRY; private final int id; public Toast(int idn) { id = idn; } public void butter() { status = Status.BUTTERED; } public void jam() { status = Status.JAMMED; } public Status getStatus() { return status; } public int getId() { return id; } public String toString() { return \"Toast \" + id + \": \" + status; } } class ToastQueue extends LinkedBlockingQueue&lt;Toast> { } class Toaster implements Runnable { private ToastQueue toasts; private int count = 0; private Random random = new Random(47); public Toaster(ToastQueue toasts) { this.toasts = toasts; } @Override public void run() { try { while (!Thread.interrupted()) { TimeUnit.MILLISECONDS.sleep(100 + random.nextInt(500)); Toast t = new Toast(count++); System.out.println(t); toasts.put(t); } } catch (InterruptedException e) { System.out.println(\"Toaster interrupted\"); } System.out.println(\"Toaster off \"); } } class Butterer implements Runnable { private ToastQueue dryQueue, butteredQueue; public Butterer(ToastQueue dryQueue, ToastQueue butteredQueue) { this.dryQueue = dryQueue; this.butteredQueue = butteredQueue; } @Override public void run() { try { while (!Thread.interrupted()) { Toast t = dryQueue.take(); t.butter(); System.out.println(t); butteredQueue.put(t); } } catch (InterruptedException e) { System.out.println(\"Butterer interrupted\"); } System.out.println(\"Butterer off\"); } } class Jammer implements Runnable { private ToastQueue butterQueue, finishedQueue; public Jammer(ToastQueue butterQueue, ToastQueue finishedQueue) { this.butterQueue = butterQueue; this.finishedQueue = finishedQueue; } @Override public void run() { try { while (!Thread.interrupted()) { Toast t = butterQueue.take(); t.jam(); System.out.println(t); finishedQueue.put(t); } } catch (InterruptedException e) { System.out.println(\"Jammer interrupted\"); } System.out.println(\"Jammer off\"); } } class Eater implements Runnable { private ToastQueue finishedQueue; private int count = 0; public Eater(ToastQueue finishedQueue) { this.finishedQueue = finishedQueue; } @Override public void run() { try { while (!Thread.interrupted()) { Toast t = finishedQueue.take(); if (t.getId() != count++ || t.getStatus() != Toast.Status.JAMMED) { System.out.println(\">>>>>Error: \" + t); System.exit(1); } else System.out.println(\"Chomp! \" + t); } } catch (InterruptedException e) { System.out.println(\"Eater interrupted\"); } System.out.println(\"Eater off\"); } } public class Main { public static void main(String[] args) throws InterruptedException { ToastQueue dryQueue = new ToastQueue(), butteredQueue = new ToastQueue(), finishedQueue = new ToastQueue(); ExecutorService exec = Executors.newCachedThreadPool(); exec.execute(new Toaster(dryQueue)); exec.execute(new Butterer(dryQueue, butteredQueue)); exec.execute(new Jammer(butteredQueue, finishedQueue)); exec.execute(new Eater(finishedQueue)); TimeUnit.SECONDS.sleep(5); exec.shutdownNow(); } } 任务间使用管道进行输入输出 以管道的形式在线程间进行输入输出也很有用，在Java中对应为PipedWriter类（允许任务向管道写）和PipedReader类（允许不同任务从同一个管道中读）。 class Sender implements Runnable { private Random random = new Random(47); private PipedWriter out = new PipedWriter(); public PipedWriter getOut() { return out; } @Override public void run() { try { while (true) { for (char c = 'A'; c &lt;= 'z'; c++) { out.write(c); TimeUnit.MILLISECONDS.sleep(500); } } } catch (IOException e) { System.out.println(e + \" Sender write exception\"); } catch (InterruptedException e) { System.out.println(e + \" Sender sleep interrupted\"); } } } class Receiver implements Runnable { private PipedReader in; public Receiver(Sender sender) throws IOException { in = new PipedReader(sender.getOut()); } @Override public void run() { try { while (true) { System.out.println(\"Read: \" + (char) in.read() + \", \"); } } catch (IOException e) { System.out.println(e + \" Receiver read exception\"); } } } public class Main { public static void main(String[] args) throws InterruptedException, IOException { Sender sender = new Sender(); Receiver receiver = new Receiver(sender); ExecutorService exec = Executors.newCachedThreadPool(); exec.execute(sender); exec.execute(receiver); TimeUnit.SECONDS.sleep(4); exec.shutdownNow(); } }","categories":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/categories/Java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://sinlapis.github.io/tags/笔记/"},{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"}]},{"title":"2020-tplink提前批面经","slug":"2020-tplink提前批面经","date":"2019-07-30T08:27:55.000Z","updated":"2021-03-03T02:50:12.455Z","comments":true,"path":"2019/07/30/2020-tplink提前批面经/","link":"","permalink":"http://sinlapis.github.io/2019/07/30/2020-tplink提前批面经/","excerpt":"","text":"2020 tplink提前批面经 应聘岗位：IT软件工程师 状态：一面过，二面没去 一面 自我介绍 介绍项目（Docker、DNS相关） 项目简介 介绍Docker Docker和虚拟机的区别，相比虚拟机的优点 Docker和lxc的区别 DNS解析流程 Java String和StringBuffer的区别，什么时候用哪个 Java如何避免内存溢出（没明白）-&gt; 讲下gc","categories":[{"name":"面经","slug":"面经","permalink":"http://sinlapis.github.io/categories/面经/"}],"tags":[{"name":"面经","slug":"面经","permalink":"http://sinlapis.github.io/tags/面经/"}]},{"title":"2020中兴提前批面经","slug":"2020中兴提前批面经","date":"2019-07-30T08:04:47.000Z","updated":"2021-03-03T02:50:12.455Z","comments":true,"path":"2019/07/30/2020中兴提前批面经/","link":"","permalink":"http://sinlapis.github.io/2019/07/30/2020中兴提前批面经/","excerpt":"","text":"2020中兴提前批面经 应聘岗位：软件开发工程师 状态：等待通知 专业面 自我介绍 介绍项目（Docker、DNS相关） 项目简介（目的、实现技术） 系统架构 Docker和虚拟机的区别 如何监控Docker容器状态 Docker容器内进程和普通进程的区别 Docker的优缺点 DNS解析流程 Java和Go的区别 数据库相关 关系型和非关系型的区别 解释事务 解释递归（手撕递归的代码） 没问Java，佛了 关于Go（以后再也不说我会Go了，再也不！） Go的引用类型有哪些 Go的指针运算有哪些 数组和切片的区别 HR面 自我介绍 应聘时选择企业考虑的因素 希望在哪个城市工作，为什么 讲一个在做项目时印象深刻的事 自己的优缺点 额外问题 部门leader(?)电话面 介绍项目 职业规划，三年后的目标 期望薪资和原因 期望工作城市 是否接触过手机软件开发，介绍项目内容和项目去向 假设你是项目负责人，如何着手完全没有接触过相关领域的项目 接上，给定该项目的功能点，设想其服务段和客户端架构 如果当前的项目毫无进展或者遇到重大问题，而第二天是项目的重要节点该怎么办 空闲时间做什么","categories":[{"name":"面经","slug":"面经","permalink":"http://sinlapis.github.io/categories/面经/"}],"tags":[{"name":"面经","slug":"面经","permalink":"http://sinlapis.github.io/tags/面经/"}]},{"title":"Java8实战笔记0x01","slug":"Java8实战笔记0x01","date":"2019-07-30T06:22:58.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2019/07/30/Java8实战笔记0x01/","link":"","permalink":"http://sinlapis.github.io/2019/07/30/Java8实战笔记0x01/","excerpt":"","text":"流流简介 流是从支持数据处理操作的源生成的元素序列。 集合的核心是数据，而流的目的在于表达计算。 和迭代器类似，流只能遍历一次。 使用Collection接口需要用户做迭代，称为外部迭代。而使用Stream则代替用户做了迭代，称为内部迭代。 流操作List&lt;String> names = menu.stream() // 中间操作 .filter(d -> d.getCalories()) .map(Dist::getName) .limit(3) // 终端操作 .collect(toList()); 诸如filter或sorted等中间操作会返回另一个流，这让多个操作可以连接起来形成一个查询。除非流水线上触发一个终端操作，否则中间操作不会执行任何处理，因为中间操作一般都可以合并起来，在终端操作时一次性全部处理，这种技术称作循环合并。 终端操作会从流的流水线生成结果。其结果是任何不是流的值，比如List、Integer，甚至是void。 使用流筛选和切片用谓词筛选 filter方法：接受一个谓词（返回boolean的函数）作为参数，并返回一个包括所有符合谓词的元素的流。 List&lt;Dish> vegetarianMenu = menu.stream() .filter(Dish::isVegetarian) .collect(toList()); 提取不同元素 distinct方法：无参数，返回一个元素各异的流（根据流所生成元素的hashCode()和equals()方法实现）。 List&lt;Integer> numbers = Arrays.asList(1, 2, 1, 3, 3, 2, 4); numbers.stream() .filter(i -> i % 2 == 0) .distinct() .forEach(System.out::println); /* Output: 2 4 */ 截短流 limit(n)方法：返回一个不超过给定长度n的流。如果流是有序的，则最多返回钱n个元素；如果流是无序的（例如Set），则返回结果不会以任何顺序排列。 跳过元素 skip(n)方法：返回一个去掉前n个元素的流。如果流中的元素不足n个，则返回一个空流。与limit(n)是互补操作。 映射对流中的每个元素应用函数 map方法：接受一个函数作为参数，这个函数会被应用到每个元素上，并将其映射成一个新的元素（与转换的区别是，该步骤是创建一个新的版本而不是修改）。 List&lt;String> dishName = menu.stream() .map(Dish::getName) .collect(toList()); 流的扁平化 flatMap方法：传入的方法生成的流不会各自独立，而是会被合并，扁平化称为一个流。 查找和匹配 anyMatch检查谓词是否至少匹配一个元素；allMatch会检查谓词是否匹配所有元素，相对的noneMatch则会确保流中没有任何元素与给定的谓词匹配。这三种方法都用到了短路。 findAny可以返回流中的任意元素，而findFirst则返回有出现顺序的流中的第一个元素。使用时配合Optional&lt;T&gt;使用。此外findAny在使用并行流时限制较少，如果不关心返回哪个元素，那么应该使用findAny。 归约int sum = numbers.stream().reduce(0, (a, b) -> a + b); 上面代码展示了用reduce求一组整数的和，reduce接受一个初始值和一个函数，它将使用函数反复结合每个元素，直到流被归约成一个值。 使用reduce可以让内部实现得以选择并行执行操作。但是，传递给reduce的Lambda不能更改状态（如实例变量），而且操作必须满足结合律才可以按任意顺序执行。 数值流 IntStream、DoubleStream和LongStream分别将流中的元素特化为int、double和long，从而避免的暗含的装箱成本。数值流包含进行常用归约的方法，如求和sum，找到最大元素max等。 映射到数值流可以用mapToInt、mapToDouble和mapToLong，而使用boxed方法可以将数值流转回对象流（各个基本类型对应的包装类型）。 range和rangeClosed是可以用于IntStream和LongStream的静态方法，作用是生成范围内的数，区别是range不包含结束值而rangeClosed包含。 构建流由值创建流 使用Stream.of可以通过显式值创建一个流，可以接受任意数量的参数。而Stream.empty可以得到一个空流。 Stream&lt;String> stream = Stream.of(\"Java 8\", \"Lambdas\", \"In\", \"Action\"); Stream&lt;String> emptyStream = Stream.empty(); 由数组创建流 静态方法Arrays.stream可以从数组创建一个流，接受一个数组作为参数。 由文件生成流 java.nio.file.Files中的很多静态方法都会返回一个流，例如Files.lines，它会返回一个由指定文件中的各行构成的字符串流。 由函数生成流——创建无限流迭代 iterate方法接受一个初始值，以及一个一次应用在每个产生的新值上的Lambda。iterate操作基本上是顺序的，因为结果取决于前一次应用。该操作将生成一个无限流，没有结尾，因为值是按需计算的，可以永远计算下去。因此流和集合的一个关键的区别在于流是无界的。 生成 generate方法也可以生成无限流，它接受一个Supplier&lt;T&gt;类型的Lambda提供新的值。","categories":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/categories/Java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://sinlapis.github.io/tags/笔记/"},{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"},{"name":"流","slug":"流","permalink":"http://sinlapis.github.io/tags/流/"}]},{"title":"Java8实战笔记0x00","slug":"Java8实战笔记0x00","date":"2019-07-29T03:31:24.000Z","updated":"2021-03-03T02:50:12.455Z","comments":true,"path":"2019/07/29/Java8实战笔记0x00/","link":"","permalink":"http://sinlapis.github.io/2019/07/29/Java8实战笔记0x00/","excerpt":"","text":"通过行为参数化传递代码行为参数化 谓词：根据对象的某些属性来返回boolean值的函数。 代码进化节选使用接口实现策略设计模式// 顶层接口 public interface ApplePredicate { boolean test(Apple apple); } // 各种具体实现，可以不断增加 public class AppleHeavyWeightPredicate implements ApplePredicate { public boolean test(Apple apple) { return apple.getWeight() > 150; } } public class AppleGreenColorPredicate implements ApplePredicate { public boolean test(Apple apple) { return \"green\".equals(apple.getColor()); } } // 使用部分，无需变动 public static List&lt;Apple> filterApples(List&lt;Apple> inventory, ApplePredicate p) { List&lt;Apple> result = new ArrayList&lt;>(); for (Apple apple: inventory) { if (p.test(apple)) result.add(apple); } return result; } 使用匿名内部类 在上面代码中，所定义的类可能仅实例化一次， 而使用匿名内部类可以弥补这点。 // 仍然需要上面代码的顶层接口，但无需实际定义类 List&lt;Apple> redApples = filterApples(inventory, new ApplePredicate() { public boolean test(Apple a) { return \"red\".equals(a.getColor()); } }); 使用Lambda表达式List&lt;Apple> result = filterApples(inventory, (Apple apple) -> \"red\".equals(apple.getColor())); 使用泛型public interface Predicate&lt;T> { boolean test(T t); } public static &lt;T> List&lt;T> filter(List&lt;T> list, Predicate&lt;T> p) { List&lt;T> result = new ArrayList&lt;>(); for (T e: list) { if (p.test(e)) result.add(e); } return result; } //... List&lt;Apple> redApples = filter(inventory, (Apple apple) -> \"red\".equals(apple.getColor())); List&lt;Integer> evenNumbers = filter(numbers, (Integer i) -> i % 2 == 0); Lambda表达式使用Lambda表达式 函数式接口：是指只定义一个抽象方法的接口。例如Java API中的Comparetor、Runnable、Callable等。 @FunctionalInterface：用于标注接口为函数式接口，如果该接口没有定义抽象方法或者包含多个抽象方法，编译时会出现错误。其作用类似于@Override。 使用函数式接口 java.util.function.Predicate&lt;T&gt;提供一个test()方法，接受一个泛型T对象，返回一个boolean。 java.util.function.Consumer&lt;T&gt;提供一个accept()方法，接受一个泛型T对象，返回为void。 java.util.function.Function&lt;T, R&gt;提供一个apply()方法，接受一个泛型T对象，返回一个泛型R对象。 原始类型特化 虽然Java可以进行自动装箱和拆箱，但是这一操作还是有性能代价的。为避免自动装箱和拆箱，Java为其提供的函数式接口提供了原始类型特有版本，例如功能类似Predicate&lt;T&gt;的IntPredicate，其参数为int而不是Integer可以避免装箱。 异常处理 任何函数式接口都不允许抛出受检异常。如果希望Lambda表达式可以抛出异常，可以定义一个自己的函数式接口，并声明受检异常，或者把Lambda主体用try/catch块包裹。下面代码为示例。 @FunctionalInterface public interface BufferredReaderProcessor { String process(BufferedReader b) throws IOException; } //... BufferedReaderProcessor p = (BufferedReader br) -> br.readLine(); Function&lt;BufferedReader, String> f = (BufferedReader b) -> { try { return b.readLine(); } catch (IOException e) { throw new RuntimeException(e); } }; 类型推断 编译器会自动推断Lambda表达式的参数类型，而无需显式声明。 // 没有类型推断 Comparator&lt;Apple> c = (Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight()); // 有类型推断 Comparator&lt;Apple> c = (a1, a2) -> a1.getWeight().compareTo(a2.getWeight()); 使用局部变量 Lambda表达式允许使用自由变量（在外层作用域中定义的变量），类似于匿名类。 Lambda可以没有限制的捕获实例变量和静态变量，但是局部变量必须声明为final或者事实上是final。关于事实上是final的变量，见下面代码。不符合事实上是final的变量出现时，编译器将会发出错误信息。 int n = 1337; Runnable r = () -> System.out.println(n); // Error: java: 从lambda 表达式引用的本地变量必须是最终变量或实际上的最终变量 n = 31337; 方法引用 方法引用可以被看作仅仅调用特定方法的Lambda的一种快捷写法。如果一个Lambda代表的只是直接调用这个方法，那最好还是用名称调用而不是尝试去描述过程。事实上，方法引用就是根据已有的方法实现来创建Lambda表达式。 (Apple a) -> a.getWeight(); // 等价于 Apple::getWeight 分类 方法引用主要有三类： 指向静态方法的方法引用（例如Integer的parseInt()，写作Integer::parseInt） 指向任意类型实例方法的方法引用（例如String对象的length()，写作String::length） 指向现有对象的实例方法的方法引用（例如局部变量x，其拥有实例方法getValue()，则可写x::getValue） 注意，第二种实例是Lambda本身的参数，而第三种实例来自外部。 构造函数引用 可以使用ClassName::new来对构造函数进行引用。注意选择正确的接口接收构造函数引用，见下面代码示例。 class Apple { private int w; public Apple() { w = 10; } public Apple(int w) { this.w = w; } public static void main(String[] args) throws Exception { Supplier&lt;Apple> c = Apple::new; Apple a1 = c.get(); Function&lt;Integer, Apple> c2 = Apple::new; Apple a2 = c2.get(20); } } ClassName::new会选择匹配函数式接口对应方法参数列表的构造函数，而无需指定参数列表。 复合Lambda表达式 Java 8的一些函数式借口都有为方便而设计的方法，可以把多个简单的Lambda复合成复杂的表达式（例如使用or连接两个Lambda）。这些方法的实现使用了接口的默认方法。 比较器复合以一个Comparator为例： Comparator&lt;Apple> c = Comparator.comparing(Apple::getWeight); 逆序 如果希望将结果逆序输出，可以使用默认方法reversed()将比较器结果逆序： inventory.sort(comparing(Apple::getWeight).reversed()); 比较器链 如果使用比较器得到两个应该处于相同位置的对象时，可以使用thenComparing()来进一步比较： inventory.sort(comparing(Apple::getWeight)) .reversed() .thenComparing(Apple::getCountry)); 谓词复合 谓词借口包括三个方法：negate、and和or，其优先级是从左往右。 // 从现有的Predicate创建结果的非 Predicate&lt;Apple> notRedApple = redApple.negate(); // 使用and和or创建复杂的Predicate对象 Predicate&lt;Apple> p = redApple.and(a -> a.getWeight() > 150) .or(a -> \"green\".equals(a.getColor())); 函数复合 可以使用Function接口将Lambda表达式复合起来。其中提供andThen()和compose()两个方法，它们都会返回一个Function实例。andThen()会先对输入应用调用该方法的Function，后对输入应用该方法的Function参数；compose()则是先对输入应用该方法的Function参数，后对输入应用调用该方法的Function","categories":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/categories/Java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://sinlapis.github.io/tags/笔记/"},{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"}]},{"title":"Java编程思想笔记0x15","slug":"Java编程思想笔记0x15","date":"2019-07-28T07:48:16.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2019/07/28/Java编程思想笔记0x15/","link":"","permalink":"http://sinlapis.github.io/2019/07/28/Java编程思想笔记0x15/","excerpt":"","text":"并发（二）共享受限资源不正确地访问资源class Even { private int i = 0; public int next() { ++i; // [1] ++i; return i; } } 上面代码中，如果正确执行，那么next()方法返回的一定是偶数。但是在并发的条件下，[1]处如果线程被挂起，被另外一个线程调用该对象的next()方法时则会返回奇数。 使用synchronize进行同步控制class Even { private int i = 0; public synchronized int next() { ++i; // [1] ++i; return i; } } 使用synchronized关键字进行同步控制，应将涉及竞争的数据成员都声明为private，仅允许通过方法来访问这些成员。然后将相关的方法声明为synchronized。 所有对象都自动含有单一的锁（也成为监视器）。当在对象上调用其任意的synchronized方法的时候，此对象都被加锁，此时该对象上的其他synchronized方法只有等前一个方法调用完毕并释放了锁之后才能被调用。 一个任务可以多次获得对象的锁。JVM会跟踪加锁的次数，每当这个相同的任务在这个对象上获得锁时，相应的计数器会递增；每当任务离开一个synchronized方法，计数会递减；当计数为0时，锁被完全释放，此时其他任务可以使用此资源。 针对每个类，也有一个锁（作为类的Class对象的一部分），所以synchronized static方法可以在类的范围内防止对static数据的并发访问。 使用显式的Lock对象 Lock对象必须被显式地创建、锁定和释放。相比起synchronized，代码缺乏优雅性，但是更加灵活；并且，如果使用synchronized时某些事物失败的将会抛出异常，没有机会进行清理工作，而使用Lock对象可以在finally子句中进行清理工作。 class Even { private int i = 0; private Lock lock = new ReentrantLock(); public int next() { lock.lock(); try { ++i; ++i; return i; } finally { lock.unlock(); } } } 原子性和可视性 原子操作是不能被线程调度机制中断的操作，一旦操作开始，那么它一定在可能发生的上下文切换之前执行完毕。 当变量声明为volatile时，变量将具备以下两个特性： 保证此变量对所有线程的可见性，即一个线程修改了volatile变量后，其余线程可以立即获得修改后的值。 禁止指令重排序优化，即设置内存屏障，保证volatile变量修改更新到所有CPU上。 在非volatile上的原子操作不必刷新到主存中去，因此其他读取该域的任务也不必看到这个新值。 如果多个任务在同时访问某个域，那么这个域就应该是volatile的，否则，这个域就应该只能经由同步来访问。同步也会导致向主存中刷新，因此如果一个域完全由synchronized方法或语句块来防护，那就不必将其设置为是volatile的。 当一个域的值依赖于它之前的值，或者受到其他域的值的限制时，volatile将无法工作。 原子类 Java SE5引入了诸如AtomicInteger、AtomicLong、AtomicReference等特殊的原子性变量类，提供原子性条件更新操作compareAndSet(expectedValue, updateValue)，这是由硬件（CPU指令）支持的。 临界区 如果只是希望防止多个线程同时访问方法内部的部分代码而不是防止访问整个代码，可以使用synchronized指定某个对象，此对象的锁将用于对指定代码段进行同步控制。这段代码被称为临界区，或者同步控制块。 一般情况下，使用synchronized同步临界区时指定的同步对象为当前对象，即synchronized (this)。当然也可以指定其它对象，但注意确保所有任务都是在同一个对象上同步的。 终结任务线程状态 一个线程可以处于一下四种状态之一： 新建：当线程被创建时，它只会短暂地处于该状态。此时它已经得到了必需的系统资源，并进行了初始化，可以获得CPU时间了。之后调度器将把这个线程转变为可运行状态或者阻塞状态。 就绪：在这种状态下，只要调度器把时间片分配给线程，线程就可以运行，也就是说，线程可以运行也可以不运行。 阻塞：线程能够运行，但有某个条件阻止它运行。当线程处于阻塞状态时，调度器将会忽略线程，不会分配给线程任何CPU时间。直到线程重新进入了就绪状态，它才有可能执行操作。 死亡：处于死亡或终止状态的线程不再是可调度的，并且再也不会得到CPU时间，它的任务已经结束，或者不再是可运行的。任务死亡的通常方式是从run()方法返回，但是任务的线程还可以被中断。 进入阻塞状态 一个任务进入阻塞状态，可能有如下原因： 通过调用sleep()使任务进入休眠状态，在这种情况下，任务在指定的时间内不会运行。 调用wait()使线程挂起，直到线程得到了notify()或者notifyAll()消息（或者在Java中等价的signal()或signalAll()消息），线程才会进入就绪状态。 任务在等待某个输入/输出完成。 任务试图在某个对象上调用其同步控制方法，但对象锁不可用，因为另一个任务已经获取了这个锁。 中断 Thread类包含interrupt()方法，可以终止被阻塞任务，这个方法将设置线程的中断状态。如果一个线程已经被阻塞，或者试图执行一个阻塞操作，那么设置这个线程的中断状态将跑出InterruptedException。当抛出该异常或者该任务调用Thread#interrupted()时，中断状态将被复位。 如果在Executor上调用shutdownNow()，那么它将发送一个interrrupt()调用给它启动的所有线程。如果希望只中断某个任务，那么需要通过调用submit()而不是executor()启动任务，这样可以持有线程的上下文。submit()将放回一个泛型Future&lt;?&gt;，可以在其上调用cancel()，由此中断某个任务。如果将true传递给cancel()，那么它就会有在该线程上调用interrupt()以停止这个线程的权限。 interrupt()不能中断正在试图获取synchronized锁或者试图执行I/O操作的线程，因为操作系统并未提供该功能。 可以通过调用Thread.interrupted()来检查中断状态，不仅仅可以得知interrupt()是否被调用过，还可以清除中断状态。","categories":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/categories/Java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://sinlapis.github.io/tags/笔记/"},{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"}]},{"title":"Java编程思想笔记0x14","slug":"Java编程思想笔记0x14","date":"2019-07-24T07:59:24.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2019/07/24/Java编程思想笔记0x14/","link":"","permalink":"http://sinlapis.github.io/2019/07/24/Java编程思想笔记0x14/","excerpt":"","text":"并发（一）基本的线程机制定义任务class LiftOff implements Runnable { protected int countDown = 10; private static int taskCount = 0; private final int id = taskCount++; public LiftOff() {} public LiftOff(int countDown) { this.countDown = countDown; } public String status() { return String.format(\"#%d(%s)\", id, countDown > 0? countDown:\"LiftOff\"); } @Override public void run() { while (countDown-- > 0) { System.out.println(status()); Thread.yield(); } } } 实现Runnable接口并实现run()方法，即可执行自定义任务。 静态方法Thread.yield()是对线程调度器的一种建议，告知其可以让出CPU转移给其它线程。 Thread类public class Main { public static void main(String[] args) throws Exception { for (int i = 0; i &lt; 5; i++) { new Thread(new LiftOff()).start(); } } } 可以直接继承Thread类，或者向Thread构造器中传入Runnable对象，来构建由不同线程执行任务的对象。 上面代码一次执行的结果可能和另外一次不同，因为线程调度机制是非确定的。 Executor Executor能够管理异步任务的执行，无须显式地管理线程的生命周期。 public class Main { public static void main(String[] args) { ExecutorService exec = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 5; i++) { exec.execute(new LiftOff()); } exec.shutdown(); } } 在上面代码中，ExecutorService对象使用静态方法Executors.newCachedThreadPool()创建，ExecutorService#execute()为每一个任务都创建了一个线程。 ExecutorService#shutdown()方法可以防止新任务提交给该Executor，而当前线程将继续运行在shutdown()被调用之前提交的所有任务，待所有任务均执行完毕后，当前线程将会尽快退出。 ChchedThreadPool在程序执行过程中通常会创建与所需数量相同的线程，然后在它回收旧线程时停止创建新线程。 public class Main { public static void main(String[] args) { ExecutorService exec = Executors.newFixedThreadPool(5); for (int i = 0; i &lt; 5; i++) { exec.execute(new LiftOff()); } exec.shutdown(); } } FixedThreadPool可以一次性预先执行代价高昂的线程分配，因而也可以限制线程的数量。由于不需要为每个任务都固定付出创建线程的开销，因此可以节省时间。在事件驱动的系统中，需要线程的事件处理器，通过直接从池中获取线程以尽快得到服务。在这个过程中，由于线程总数是有限的，因此不会出现资源滥用。 在任何线程池中，现有线程在可能的情况下都会被自动复用。 SingleThreadExecutor类似于线程数量为1的FixedThreadPool，可以用于在另一个线程中连续运行任何事物（长期服务），例如监听进入的套接字连接的任务。如果向SingleThreadExecutor提交了多个任务，那么这些任务将会排队执行，所有的任务将使用相同的线程。这能够保证在任意时刻在任意线程中都只有唯一的任务在运行，不需要在共享资源上处理同步并有限制的使用这些资源。 从任务中产生返回值 如果需要任务在完成时能够返回一个值，可以实现Callable接口。Callable是一种具有类型参数的泛型，它的类型参数表示的是从方法call()中返回值的类型。向Executor提交任务时使用ExecutorService#submit()。 class Test implements Callable&lt;String> { private int id; public Test(int id) { this.id = id; } @Override public String call() throws Exception { return \"result: \" + id; } } public class Main { public static void main(String[] args) { ExecutorService exec = Executors.newFixedThreadPool(5); List&lt;Future&lt;String>> result = new ArrayList&lt;>(); for (int i = 0; i &lt; 10; i++) { result.add(exec.submit(new Test(i))); } for (Future&lt;String> r: result) { try { System.out.println(r.get()); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } finally { exec.shutdown(); } } exec.shutdown(); } } ExecutorService#submit()方法会产生Future对象，它用Callable返回的结果的特定类型进行参数化。可以调用Future#isDone()来查询Future是否已经完成，如果完成可以调用Future#get()获取对应结果。也可以直接调用Future#get()，此时会发生阻塞，直到结果准备就绪。 休眠 可以调用TimeUnit.MILLSECONDS.sleep()来中止任务执行给定的时间，同时会抛出InterruptedException异常。由于异常不能跨线程传播回主线程，因此必须在本地处理所有在任务内部产生的异常。 优先级 线程的优先级将该线程的重要性传递给了调度器，调度器将倾向度让优先级最高的线程先执行。然而，这并不意味着优先级较低的线程得不到执行，仅仅是执行的频率较低。 class Test implements Runnable { private int countDown = 5; private volatile double d; private int priority; public Test(int priority) { this.priority = priority; } public String toString() { return Thread.currentThread() + \": \" + countDown; } @Override public void run() { Thread.currentThread().setPriority(priority); while(true) { for (int i = 1; i &lt; 100000; i++) { d += (Math.PI + Math.E) / (double)i; if (i % 1000 == 0) Thread.yield(); } System.out.println(this); if (--countDown == 0) return; } } } public class Main { public static void main(String[] args) { ExecutorService exec = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 5; i++) { exec.execute(new Test(Thread.MAX_PRIORITY)); exec.execute(new Test(Thread.MIN_PRIORITY)); } } } 可以使用getPriority()来读取现有线程的优先级，并且可以在任何时候通过调用setPriority()来修改优先级。 尽管JDK有10个优先级，但是和多数的操作系统都不能映射得很好。唯一可移植的方法是只使用MAX_PRIORITY、NORM_PRIORITY和MIN_PRIORITY。 后台线程 后台线程，是指在程序运行的时候在后台提供一种通用服务的线程，并且这种线程并不属于程序中不可或缺的部分。因此，当所有的非后台线程结束时，程序也就终止了，同时会杀死进程中所有的后台线程。 可以使用Thread#setDaemon()来设置线程为后台线程，但必须在线程启动之前设置。 class DaemonThreadFactory implements ThreadFactory { @Override public Thread newThread(Runnable r) { Thread t = new Thread(r); t.setDaemon(true); return t; } } class Daemon implements Runnable { @Override public void run() { try { while (true) { TimeUnit.MILLISECONDS.sleep(100); System.out.println(Thread.currentThread() + \" \" + this); } } catch (InterruptedException e) { e.printStackTrace(); } } } public class Main { public static void main(String[] args) throws InterruptedException { ExecutorService exec = Executors.newCachedThreadPool(new DaemonThreadFactory()); for (int i = 0; i &lt; 10; i++) { exec.execute(new Daemon()); } System.out.println(\"all start.\"); TimeUnit.MILLISECONDS.sleep(500); } } 每个静态的ExecutorService创建方法可以被重载为接收一个ThreadFactory对象，而这个工厂对象将用于创建新的线程。在上面代码中，自定义的工厂将新的线程均设置成为后台线程。 可以通过调用Thread#isDaemon()方法来确定线程是否为一个后台线程。后台线程创建的线程都将自动设置成为后台线程。 class Daemon implements Runnable { @Override public void run() { try { System.out.println(\"starting daemon\"); TimeUnit.SECONDS.sleep(1); // [1] } catch (InterruptedException e) { e.printStackTrace(); } finally { System.out.println(\"run?\"); } } } public class Main { public static void main(String[] args) throws InterruptedException { Thread t = new Thread(new Daemon()); t.setDaemon(true); t.start(); } } 当最后一个非后台线程终止时，JVM就会立即关闭所有后台进程（例如上面代码，尽管执行到[1]处会被强制停止，但不会执行finally子句）。这不是关闭后台进程优雅的方式，相应的，非后台的Executor控制的所有任务可以同时被关闭，这是一种更好的解决方式。 加入一个线程 一个线程可以在其他线程之上调用join()方法，此时调用join()的线程将被挂起，直到目标线程结束才回复（即t.isAlive为假）。也可以在调用join()时带上一个超时参数，如果发生超时目标线程还没有结束，join()方法也会返回。 捕获线程异常class ThrowException implements Runnable { @Override public void run() { throw new RuntimeException(); } } public class Main { public static void main(String[] args) throws InterruptedException { ExecutorService exec = Executors.newCachedThreadPool(); try { exec.execute(new ThrowException()); } catch (Exception e) { e.printStackTrace(); } } } 上面代码中的try语句无法捕获线程中的异常。 class ThrowException implements Runnable { @Override public void run() { throw new RuntimeException(); } } class CatchException implements Thread.UncaughtExceptionHandler { @Override public void uncaughtException(Thread t, Throwable e) { System.out.println(\"caught: \" + e); } } class ExceptionThreadFactory implements ThreadFactory { @Override public Thread newThread(Runnable r) { Thread t = new Thread(r); t.setUncaughtExceptionHandler(new CatchException()); return t; } } public class Main { public static void main(String[] args) throws InterruptedException { ExecutorService exec = Executors.newCachedThreadPool(new ExceptionThreadFactory()); exec.execute(new ThrowException()); } } /* Output: caught: java.lang.RuntimeException */ Thread.UncaughtException接口可以为每个Thread对象都附着一个异常处理器。其中uncaughtException()方法会在线程因未捕获异常而退出前被调用。上面代码中创建了一个ThreadFactory子类来为线程添加异常处理器。","categories":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/categories/Java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://sinlapis.github.io/tags/笔记/"},{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"}]},{"title":"Java编程思想笔记0x13","slug":"Java编程思想笔记0x13","date":"2019-07-24T06:25:30.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2019/07/24/Java编程思想笔记0x13/","link":"","permalink":"http://sinlapis.github.io/2019/07/24/Java编程思想笔记0x13/","excerpt":"","text":"注解 注解也被称为元数据，为在代码中添加信息提供了一种形式化的方法，以便在后面使用这些数据。 有三种内置的注解，分别是： @Override，表示当前的方法定义将覆盖超类中的方法。如果注解的方法没有对应到超类中的方法，编译器会发出错误提示。 @Deprecated，如果在其它代码中使用了注解为@Deprecated的元素，那么编译器会发出警告信息。 @SuppressWarnings，关闭不当的编译器警告信息。 基本语法定义注解@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) @interface Test {} 除了@以外，@Test的定义很像一个空的接口。 没有元素的注解称为标记注解。 元注解 元注解 说明 @Target 表示该注解可以用于什么地方，可能的参数包括：CONSTRUCTOR（构造器声明），FIELD（域声明），LOCAL_VARIABLE（局部变量声明），METHOD（方法声明），PACKAGE（包声明），PARAMETER（参数声明），TYPE（类、接口、注解、枚举） @Retention 表示需要再什么级别保存该注解信息。可选的参数包括：SOURCE（注解将被编译器丢弃），CLASS（注解在class文件中可用，但会被VM丢弃），RUNTIME（VM在运行期也会保留注解，可以通过反射读取注解信息） @Documented 将此注解包含在Javadoc中 @Inherited 允许子类继承父类中的注解 编写注解处理器@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) @interface UseCase { public int id(); public String desc() default \"No description\"; } class PasswordUtils { @UseCase(id = 47, desc = \"Need one or more numeric\") public boolean validatePassword(String password) { return (password.matches(\"\\\\w*\\\\d\\\\w*\")); } @UseCase(id = 48) public String encryptPassword(String password) { return new StringBuilder(password).reverse().toString(); } @UseCase(id = 49, desc = \"Same with the previous\") public boolean chekcForNewPassword(List&lt;String> prevPasswords, String password) { return !prevPasswords.contains(password); } } public class Main { public static void trackUseCases(List&lt;Integer> useCases, Class&lt;?> cl) { for (Method m: cl.getDeclaredMethods()) { UseCase uc = m.getAnnotation(UseCase.class); if (uc != null) { System.out.println(uc.id() + \" \" + uc.desc()); useCases.remove((Integer)uc.id()); } } for (int i: useCases) { System.out.println(i + \"Not found\"); } } public static void main(String[] args) throws Exception { List&lt;Integer> useCases = new ArrayList&lt;>(); Collections.addAll(useCases, 47, 48, 49, 50); trackUseCases(useCases, PasswordUtils.class); } } 上面代码使用了反射来取得注解信息。其中，getAnnoation()方法返回指定类型的注解对象。如果被注解方法上没有该类型的注解，则返回null值。如果注解中没有指定注解字段值，则返回定义注解字段时的默认值。 注解元素 注解元素可用的类型： 所有基本类型 Class enum String Annotation 如果使用了其它类型则会报错。另外，注解可以作为元素的类型，这意味着注解可以嵌套。 默认值限制 元素必须有默认值，或者在使用注解时提供元素的值。 对于非基本类型的元素，无论是在源代码中，还是在注解接口中定义默认值，都不能以null作为其值。","categories":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/categories/Java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://sinlapis.github.io/tags/笔记/"},{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"}]},{"title":"全排列","slug":"全排列","date":"2019-07-22T08:05:00.000Z","updated":"2021-03-03T02:50:12.463Z","comments":true,"path":"2019/07/22/全排列/","link":"","permalink":"http://sinlapis.github.io/2019/07/22/全排列/","excerpt":"","text":"全排列递归方法public class Main { static void swap(int[] arr, int i, int j) { int t = arr[i]; arr[i] = arr[j]; arr[j] = t; } static void full(int[] arr, int start) { if (start == arr.length - 1) System.out.println(Arrays.toString(arr)); else { // 将当前最左边和后面的值依次交换 for (int i = start; i &lt; arr.length; i++) { swap(arr, start, i); // 递归解决子数组全排列 full(arr, start + 1); // 复原数组 swap(arr, start, i); } } } public static void main(String[] args) throws Exception { full(new int[]{1,2,3,4}, 0); } } 字典排序public class Main { static void dict(int[] arr) { Arrays.sort(arr); System.out.println(Arrays.toString(arr)); while (true) { // 从最右起，找出为升序的相邻两个数，记录小的位置i int i; for (i = arr.length - 2; i >= 0; i--) { if (arr[i] &lt; arr[i + 1]) break; } // 如果没有则表示完成字典排序 if (i == -1) break; // 从最右起，找出比arr[i]大的第一个数，记录位置j int j; for (j = arr.length - 1; j > 0; j--) { if (arr[j] > arr[i]) break; } // 交换i和j int t = arr[i]; arr[i] = arr[j]; arr[j] = t; // 对i + 1到最后进行排序 Arrays.sort(arr, i + 1, arr.length); System.out.println(Arrays.toString(arr)); } } public static void main(String[] args) throws Exception { dict(new int[]{1, 1, 2, 4}); } }","categories":[{"name":"算法","slug":"算法","permalink":"http://sinlapis.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://sinlapis.github.io/tags/算法/"}]},{"title":"Java编程思想笔记0x12","slug":"Java编程思想笔记0x12","date":"2019-07-21T01:22:48.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2019/07/21/Java编程思想笔记0x12/","link":"","permalink":"http://sinlapis.github.io/2019/07/21/Java编程思想笔记0x12/","excerpt":"","text":"枚举类型（二）使用EnumSet替代标志 是一种面向enum的标志，可以用来表示某种“开/关”信息。其内部实现是将一个long值作为位向量，因此EnumSet非常高效。 enum AlarmPoints { STAIR1, STAIR2, LOBBY, OFFICE1, OFFICE2, OFFICE3, OFFICE4, BATHROOM, UTILITY, KITCHEN } public class Test { public static void main(String[] args) throws Exception { EnumSet&lt;AlarmPoints> points = EnumSet.noneOf(AlarmPoints.class); points.add(AlarmPoints.BATHROOM); System.out.println(points); points.addAll(EnumSet.of(AlarmPoints.STAIR1, AlarmPoints.STAIR2, AlarmPoints.KITCHEN)); System.out.println(points); points = EnumSet.allOf(AlarmPoints.class); points.removeAll(EnumSet.of(AlarmPoints.STAIR1, AlarmPoints.STAIR2, AlarmPoints.KITCHEN)); System.out.println(points); points.removeAll(EnumSet.range(AlarmPoints.OFFICE1, AlarmPoints.OFFICE4)); System.out.println(points); points = EnumSet.complementOf(points); System.out.println(points); } } EnumSet.of()方法被重载了很多次，不仅为可变数量参数进行类重载，还为接收1到5个显式的参数的情况进行类重载。即当使用2到5个参数时，会调用对应的重载方法，而使用1个或者多于5个参数时，会调用可变参数的of()方法。注意，1个参数不会导致编译器构造可变参数数组。 在JDK 11中，EnumSet.of()不同的重载方法有：1至5个显式声明参数的方法，和一个参数列表为(E first, E... rest)的方法。 在创建EnumSet对象时，如果枚举实例小于等于64个，则使用一个long值，否则使用一个long数组。 使用EnumMap EnumMap要求其中的键必须来自一个enum。由于枚举实例总数量是确定的，EnumMap内部使用了数组实现。调用put()方法时键只能是枚举实例，其它操作和普通的Map基本一致。 enum AlarmPoints { STAIR1, STAIR2, LOBBY, OFFICE1, OFFICE2, OFFICE3, OFFICE4, BATHROOM, UTILITY, KITCHEN } interface Command { void action(); } public class Test { public static void main(String[] args) throws Exception { EnumMap&lt;AlarmPoints, Command> em = new EnumMap&lt;>(AlarmPoints.class); em.put(AlarmPoints.KITCHEN, new Command() { public void action() { System.out.println(\"Kichen fire!\"); } }); em.put(AlarmPoints.BATHROOM, new Command() { public void action() { System.out.println(\"Bathroom alart!\"); } }); for(Map.Entry&lt;AlarmPoints, Command> e: em.entrySet()) { System.out.print(e.getKey() + \": \"); e.getValue().action(); } try { em.get(AlarmPoints.UTILITY).action(); } catch (Exception e) { System.out.println(e); } } } /* Output: BATHROOM: Bathroom alart! KITCHEN: Kichen fire! java.lang.NullPointerException */ 上面代码是一种命令模式的用法，即首先需要一个只有单一方法的接口，然后从该接口实现具有各自不同的行为的多个子类。之后可以根据需要构造命令对象并使用。 如果EnumMap没有为某个键调用put()方法来存入相应的值的话，那么其对应的值就为null。 注意foreach中元素的泛型声明不可省略 常量相关方法 可以为enum实例编写方法，从而为每个枚举实例赋予各自不同的行为。首先需要为enum定义一个或多个方法（或者抽象方法），然后为选择枚举实例进行覆盖方法（如果是抽象方法则每个枚举实例都要实现该方法）。 public enum Test { DATE_TIME { String getInfo() { return DateFormat.getDateInstance().format(new Date()); } }, CLASSPATH { String getInfo() { return System.getenv(\"CLASSPATH\"); } }, VERSION { String getInfo() { return System.getProperty(\"java.version\"); } }, TEST { String getInfo() { return \"test info\"; } int getNumber() { return 222222; } }; abstract String getInfo(); int getNumber() { return 111111; } public static void main(String[] args) throws Exception { for (Test t: values()) { System.out.println(t.getInfo() + \" \" + t.getNumber()); } } } /* Output: 2019年7月21日 111111 .;C:\\Program Files\\Java\\jdk-11.0.3\\lib\\dt.jar;C:\\Program Files\\Java\\jdk-11.0.3\\lib\\tools.jar; 111111 11.0.3 111111 test info 222222 */ 通过相应的枚举实例，可以调用其上的方法，这通常也称为表驱动的代码（tabledriven code）。在上面代码中，枚举实例似乎被当做其“超类”来使用，在调用覆盖（实现）的方法（抽象方法）时体现多态的行为。 使用enum职责链 在职责链设计模式中，可以用多种不同的方法来解决一个问题，然后将它们链接在一起。当一个请求到来时，遍历这个链，直到链中的某个解决方案能够处理该请求。 通过常量相关的方法，可以很容易地实现一个简单的职责链。其中每一次尝试可以看做一个策略（设计模式），完整的处理方式列表就是一个职责链。 enum Handle { PLUS { boolean modify(int src, int target) { switch(target - src) { case 1: System.out.println(\"plus\"); return true; default: return false; } } }, MINUS { boolean modify(int src, int target) { switch(target - src) { case -1: System.out.println(\"minus\"); return true; default: return false; } } }, ABS { boolean modify(int src, int target) { switch(target + src) { case 0: System.out.println(\"abs\"); return true; default: return false; } } }; abstract boolean modify(int src, int target); } public class Test { static void modify(int src, int target) { System.out.print(src + \" \"); for(Handle h: Handle.values()) { if(h.modify(src, target)) return; } System.out.println(\"can't modify\"); } public static void main(String[] args) throws Exception { Random r = new Random(47); int target = r.nextInt(10) - 5; System.out.println(target); for (int i = 0; i &lt; 10; i++) { int src = r.nextInt(10) - 5; modify(src, target); } } } /* Output: 3 0 can't modify -2 can't modify -4 can't modify -4 can't modify 4 minus 3 can't modify -5 can't modify -3 abs 2 plus 3 can't modify */ 使用enum的状态机 枚举类型非常适合用来创建状态机。一个状态机有有限的特定状态，它通常根据输入，从一个状态转移到下一个状态。每个状态都具有某些可接受的输入，不同的输入回事状态机从当前状态转移到不同的新状态。由于enum对其实例有严格的限制，非常适合用来表现不同的状态和输入。 enum Check { EVEN { void next(char n) { switch(n) { case '0': c = ODD; return; case '1': return; default: c = ERROR; } } }, ODD { void next(char n) { switch(n) { case '0': c = EVEN; return; case '1': return; default: c = ERROR; } } }, ERROR; private static Check c; void next(char n) { throw new RuntimeException(\"no such method.\"); }; public static void check(String num) { c = EVEN; char[] ns = num.toCharArray(); for (char n: ns) { c.next(n); if(c == ERROR) break; } switch(c) { case ODD: System.out.println(\"odd 0s\"); return; case EVEN: System.out.println(\"even 0s\"); return; case ERROR: System.out.println(\"incorrect input\"); } } } public class Test { public static void main(String[] args) throws Exception { Check.check(\"01001100001\"); Check.check(\"000011110000\"); Check.check(\"00110020\"); } } /* Output: odd 0s even 0s incorrect input */ 上面代码中实现了判断一串字符串的二进制数中有奇数还是偶数个0。有三种状态，EVEN、ODD、ERROR，前两种状态根据输入的不同决定将要转移的下一个状态，而ERROR则表示输入有误，仅作为最终状态。 多路分发 如果存在一种多元运算，其变量类型范围确定但是不能知道某个变量的具体类型，并且该运算结果与变量类型相关，即该运算的实现需要判断各个参数的类型，那么此时可以使用多路分发。 enum Outcome { WIN, DRAW, LOSE} interface Item { Outcome compete(Item it); Outcome eval(Paper p); Outcome eval(Scissors s); Outcome eval(Rock r); } class Paper implements Item { public Outcome compete(Item it) { return it.eval(this); } public Outcome eval(Paper p) { return Outcome.DRAW; } public Outcome eval(Scissors s) { return Outcome.WIN; } public Outcome eval(Rock r) { return Outcome.LOSE; } public String toString() { return \"Paper\"; } } class Scissors implements Item { public Outcome compete(Item it) { return it.eval(this); } public Outcome eval(Paper p) { return Outcome.LOSE; } public Outcome eval(Scissors s) { return Outcome.DRAW; } public Outcome eval(Rock r) { return Outcome.WIN; } public String toString() { return \"Scissors\"; } } class Rock implements Item { public Outcome compete(Item it) { return it.eval(this); } public Outcome eval(Paper p) { return Outcome.WIN; } public Outcome eval(Scissors s) { return Outcome.LOSE; } public Outcome eval(Rock r) { return Outcome.DRAW; } public String toString() { return \"Rock\"; } } public class Test { static final int SIZE = 10; private static Random r = new Random(47); public static Item newItem() { switch(r.nextInt(3)) { default: case 0: return new Scissors(); case 1: return new Rock(); case 2: return new Paper(); } } public static void match(Item a, Item b) { System.out.println(a + \" vs. \" + b + \": \" + a.compete(b)); } public static void main(String[] args) throws Exception { for (int i = 0; i &lt; SIZE; i++) { match(newItem(), newItem()); } } } 上面代码实现了“石头、剪刀、布”游戏，采用了接口的方式进行多路分发（两路分发），避免了需要判断类型的代码。 使用enum分发enum Outcome { WIN, DRAW, LOSE} enum RoShamBo2 { PAPER(Outcome.DRAW, Outcome.LOSE, Outcome.WIN), SCISSORS(Outcome.WIN, Outcome.DRAW, Outcome.LOSE), ROCK(Outcome.LOSE, Outcome.WIN, Outcome.DRAW); private Outcome vPaper, vScissors, vRock; RoShamBo2(Outcome paper, Outcome scissors, Outcome rock) { this.vPaper = paper; this.vScissorc = scissors; this.vRock = rock; } public Outcome compete(RoShamBo2 it) { switch(it) { default: case Outcome.PAPER: return vPaper; case Outcome.SCISSORS: return vScissors; case Outcome.ROCK: return vRock; } } } // 调用略 上面代码使用构造器来初始化每个枚举实例，并以一组结果作为参数，形成类类似查询表的结构。 使用常量相关的方法 为每个枚举实例提供方法的不同实现同样可以完成多路分发，但是在需要添加类型时代码的改动量要多于使用enum分发。 enum Outcome { WIN, DRAW, LOSE} enum RoShamBo3 { PAPER { public Outcome compete(RoShamBo3 it) { switch(it) { default: case PAPER: return DRAW; case SCISSORS: return LOSE; case ROCK: return WIN; } } }; // SCISSORS, ROCK略 } 使用EnumMap分发enum Outcome { WIN, DRAW, LOSE} enum RoShamBo5 { PAPER, SCISSORS, ROCK; static EnumMap&lt;RoShamBo5, EnumMap&lt;RoShamBo5, Outcome>> table = new EnumMap&lt;>(RoShamBo5.class); static { for (RoShamBo5 it: RoShamBo5.values()) { table.put(it, new EnumMap&lt;>(RoShamBo5.class)); } initRow(PAPER, Outcome.DRAW, Outcome.LOSE, Outcome.WIN); initRow(SCISSORS, Outcome.WIN, Outcome.DRAW, Outcome.LOSE); initRow(ROCK, Outcome.LOSE, Outcome.WIN, Outcome.DRAW); } static void initRow(RoShamBo5 it, Outcome vPAPER, Outcome vSCISSORS, Outcome vROCK) { EnumMap&lt;RoShamBo5, Outcome> row = RoShamBo5.table.get(it); row.put(RoShamBo5.PAPER, vPAPER); row.put(RoShamBo5.SCISSORS, vSCISSORS); row.put(RoShamBo5.ROCK, vROCK); } public Outcome compete(RoShamBo5 it) { return table.get(this).get(it); } } 使用EnumMap实现类似于表格的方法，从而达到了分发的目的。当然也可以使用二维数组来实现。","categories":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/categories/Java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://sinlapis.github.io/tags/笔记/"},{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"}]},{"title":"Java编程思想笔记0x11","slug":"Java编程思想笔记0x11","date":"2019-07-18T09:06:13.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2019/07/18/Java编程思想笔记0x11/","link":"","permalink":"http://sinlapis.github.io/2019/07/18/Java编程思想笔记0x11/","excerpt":"","text":"枚举类型（一）基本enum特性 调用enum的values()方法，可以遍历enum实例，返回一个enum实例的数组，并且数组中实例的顺序和声明时的顺序保持一致。 创建enum时，编译器会为你生成一个相关的类，这个类继承自java.lang.Enum。 ordinal()方法返回一个int值，表示每个enum实例在声明中的次序，从0开始计算。 可以使用==来比较enum实例，编译器会自动提供equals()和hashCode()方法。 Enum实现了Comparable接口，拥有compareTo()方法。 name()方法返回enum实例声明时的名字，和toString()方法相同。 valueOf()根据参数给出的实例名称返回相应的enum实例，如果不存在该名称的实例将会抛出异常。 enum是java中的语法糖，实际反编译后是继承自Enum类。 向enum中添加新方法 enum除了不能被继承，和普通的类基本相同。 public enum Main { WEST(\"west\"), NORTH(\"north\"), EAST(\"east\"), SOUTH(\"south\"); private String desc; Main(String desc) { this.desc = desc; } public String getDesc() { return desc; } public static void main(String[] args) { for (Main m: Main.values()) { System.out.println(m + \" \" + m.getDesc()); } } } /* Output: WEST west NORTH north EAST east SOUTH south */ 如果希望为enum添加方法，必须先定义enum实例，并且在实例序列最后添加一个分号。否则在编译时会得到错误消息。 可以为enum添加构造方法，注意声明enum实例时就是在使用enum的构造方法。此外，enum的构造方法无所谓是否private，因为就算不声明private其构造方法也只能在enum内部使用。 可以覆盖原来的toString()方法，以提供定制化效果。 enum的构造方法不能被反射调用，当反射调用构造方法时会检查对应类是否为枚举类。 switch语句中的enum 在case语句中不需要enum类来修饰enum实例。 values()方法// 反编译enum代码 final class Apple extends java.lang.Enum&lt;Apple> { public static final Apple A; public static final Apple B; public static final Apple C; public static Apple[] values(); public static Apple valueOf(java.lang.String); static {}; } values()方法和valueOf(String)方法是编译器向enum中加入的静态方法。 编译器将enum标记为final类，因此无法继承enum。 随机选取public class Enums { private static Random rand = new Random(42); public static &lt;T extends Enum&lt;T>> T random(Class&lt;T> ec) { return random(ec.getEnumConstants()); } public static &lt;T> T random(T[] values) { return values[rand.nextInt(values.length)]; } } &lt;T extends Enum&lt;T&gt;&gt;限制泛型必须为enum，使用Class&lt;T&gt;可以获取枚举的实例数组。 使用接口组织枚举interface Food { enum Appetizer implements Food { SALAD, SOUP, SPRING_ROLLS } enum MainCourse implements Food { LASAGNE, BURRITO, PAD_THAI, LENTILS } enum Dessert implements Food { TIRAMISU, GELATO, BLACK_FOREST_CAKE } enum Coffee implements Food { BLACK_COFFEE, DECAF_COFFEE, ESPRESSO } } public class Main { public static void main(String[] args) throws Exception { Food f = Food.Appetizer.SALAD; f = Food.Coffee.BLACK_COFFEE; f = Food.Dessert.BLACK_FOREST_CAKE; } } 在一个接口的内部，创建实现该接口的枚举，以此将元素进行分组，可以达到将枚举元素分类组织的目的。","categories":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/categories/Java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://sinlapis.github.io/tags/笔记/"},{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"}]},{"title":"Java编程思想笔记0x10","slug":"Java编程思想笔记0x10","date":"2019-07-15T07:36:47.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2019/07/15/Java编程思想笔记0x10/","link":"","permalink":"http://sinlapis.github.io/2019/07/15/Java编程思想笔记0x10/","excerpt":"","text":"Java I/O 系统（六）对象序列化 Java的对象序列化将那些实现了Serializable接口的对象转换成一个字节序列，并能够在以后将这个字节序列完全恢复为原来的对象。这一过程甚至可通过网络进行；这意味着序列化机制能自动弥补不同操作系统之间的差异。 对象序列化可以实现轻量级持久性。持久性值为准一个对象的生存周期并不取决于程序是否在执行，而是可以生存与程序调用之间。之所以称其为轻量级，是因为不能用某种持久的关键字来简单地定义一个对象，并让系统自动维护其它细节问题，相反，对象必须在程序中显示地序列化和反序列化。 对象序列化可以用于Java的远程方法调用和Java Beans对象序列化。 实现RMI的主要步骤： 定义一个远程接口，此接口需要继承Remote 开发远程接口的实现类 创建一个server并把远程对象注册到端口 创建一个client查找远程对象，调用远程方法、 Java Bean类是指Java中遵循关于命名、构造器、方法的特定规范的一种类型，以提供通用性。 只要对象实现了Serializable接口就可以进行对象序列化。Serializable是一个标记接口，其中没有任何方法。 序列化一个对象，首先要创建某些OutputStream对象，然后将其封装在一个ObjectOutputStream对象内，然后调用writeObject()即可将对象序列化，并将其发送给OutputStream；反序列化一个对象，需要将一个InputStream对象封装在ObjectInputStream中，然后调用readObject()，此时获得一个引用，指向一个向上转型的Object，需要进行合适的向下转型才能使用。 对象序列化不仅保存了对象本身的信息，而且能最终对象内所包含的所有引用，并保存那些对象；接着对这些对象继续追踪它们包含的引用并保存，以此类推。 寻找类 必须保证Java虚拟机能够找到序列化对象对应类的.class文件，否则会出现ClassNotFoundException。 class Alien implements Serializable {} public class Main { public static void main(String[] args) throws Exception { ObjectOutput out = new ObjectOutputStream(new FileOutputStream(\"x.file\")); Alien a = new Alien(); out.writeObject(a); } } 此时再编写反序列化部分，和Alien不在同一目录下。 public class Test { public static void main(String[] args) throws Exception { ObjectInputStream in = new ObjectInputStream(new FileInputStream(\"x.file\")); Object a = in.readObject(); System.out.println(a.getClass()); } } /* Output: Exception in thread \"main\" java.lang.ClassNotFoundException: Alien ... */ 如果前后序列化的类名字相同，但是成员有变化会出现异常。 // 序列化时定义 class Alien implements Serializable { int i = 1; } // 反序列化时定义 class Alien implements Serializable { String i = \"1\"; } 此时进行反序列化会出现： Exception in thread &quot;main&quot; java.io.InvalidClassException: Alien; local class incompatible: stream classdesc serialVersionUID = 185057998004728250, local class serialVersionUID = 6323316111603380755 但是如果成员名称和权限相同，成员变量仅赋值不同，成员方法的返回值和参数列表均相同但方法内部实现不同则不会出现异常，例如： // 序列化时定义 class Alien implements Serializable { int k = 0; public int a() { int i = 0; i++; return i; } } // 反序列化时定义 class Alien implements Serializable { int k = 566; public int a() { return 10; } } 此时进行反序列化不会出现异常。 序列化控制 如果希望对序列化过程进行控制，可以通过实现Externalizable接口代替Serializable。 public class Test { public static void main(String[] args) throws Exception { System.out.println(\"Constructing objects...\"); Blip1 b1 = new Blip1(); Blip2 b2 = new Blip2(); ObjectOutputStream o = new ObjectOutputStream(new FileOutputStream(\"blips.out\")); System.out.println(\"Saving objects...\"); o.writeObject(b1); o.writeObject(b2); o.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\"blips.out\")); System.out.println(\"Recovering b1...\"); b1 = (Blip1) in.readObject(); System.out.println(\"Recovering b2...\"); b2 = (Blip2) in.readObject(); in.close();; } } class Blip1 implements Externalizable { public Blip1() { System.out.println(\"Blip1 Constructor\"); } public void writeExternal(ObjectOutput out) throws IOException { System.out.println(\"Blip1#writeExternal\"); } public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { System.out.println(\"Blip1#reeadExternal\"); } } class Blip2 implements Externalizable { Blip2() { System.out.println(\"Blip2 Constructor\"); } public void writeExternal(ObjectOutput out) throws IOException { System.out.println(\"Blip2#writeExternal\"); } public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { System.out.println(\"Blip2#reeadExternal\"); } } /* Output: Constructing objects... Blip1 Constructor Blip2 Constructor Saving objects... Blip1#writeExternal Blip2#writeExternal Recovering b1... Blip1 Constructor Blip1#reeadExternal Recovering b2... Exception in thread \"main\" java.io.InvalidClassException: Blip2; no valid constructor */ Externalizable和Serializable不同，后者完全以对象存储的二进制位来构造，而不需要构造器，前者则会调用类所有默认的构造器（包括字段定义的初始化），然后调用readExternal()。 public class Blip3 implements Externalizable { private int i; private String s; public Blip3() { System.out.println(\"Blip3 Constructor\"); } public Blip3(String x, int a) { s = x; i = a; } public String toString() { return s + i; } public void writeExternal(ObjectOutput out) throws IOException { System.out.println(\"Blip3#writeExternal\"); // 可以控制序列化成员 out.writeObject(s); out.writeInt(i); } public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { // 按照writeExternal中写入顺序读出 s = (String) in.readObject(); i = in.readInt(); } public static void main(String[] args) throws Exception { System.out.println(\"Constructing objects...\"); Blip3 b3 = new Blip3(); System.out.println(b3); ObjectOutputStream o = new ObjectOutputStream(new FileOutputStream(\"b3.out\")); System.out.println(\"Saving object...\"); o.writeObject(b3); o.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\"b3.out\")); System.out.println(\"Recovering object...\"); b3 = (Blips3) in.readObject(); System.out.println(b3); } } 在上面代码中，如果在writeExternal()和readExternal()不保存和恢复成员变量，那么反序列化对象后，其成员变量值均为初始值（i为0，s为null）。 如果不希望对象中某个变量被序列化，除了实现Externalizable接口以外，可以使用Serializable配合关键字transient，该关键字修饰的成员变量在序列化时会被忽略。例如： private transient String password; 无论在使用中对password赋任何值，在序列化和反序列化后，其值一定为null。 尽管Serializable中没有定义方法，但是如果在实现该接口的类中添加writeObject(ObjectOutputStream out)和readObject(ObjectInputStream in)，那么对该类的对象进行序列化和反序列化时就会调用这两个方法，无论其权限如何（即使是private也会被调用）。此处使用的是反射搜索方法，而不是检查接口。 使用持久性class House implements Serializable {} class Animal implements Serializable { private String name; private House preferredHouse; Animal(String nm, House h) { name = nm; preferredHouse = h; } public String toString() { return name + \"[\" + super.toString() + \"], \" + preferredHouse + \"\\n\"; } } public class Main { public static void main(String[] args) throws Exception { House house = new House(); List&lt;Animal> animals = new ArrayList&lt;>(); animals.add(new Animal(\"dog\", house)); animals.add(new Animal(\"hamster\", house)); animals.add(new Animal(\"cat\", house)); System.out.println(animals); ByteArrayOutputStream buf1 = new ByteArrayOutputStream(); ObjectOutputStream o1 = new ObjectOutputStream(buf1); o1.writeObject(animals); // 写第2次 o1.writeObject(animals); ByteArrayOutputStream buf2 = new ByteArrayOutputStream(); ObjectOutputStream o2 = new ObjectOutputStream(buf2); o2.writeObject(animals); ObjectInputStream in1 = new ObjectInputStream(new ByteArrayInputStream(buf1.toByteArray())); ObjectInputStream in2 = new ObjectInputStream(new ByteArrayInputStream(buf2.toByteArray())); List a1 = (List)in1.readObject(); List a2 = (List)in1.readObject(); List a3 = (List)in2.readObject(); System.out.println(a1); System.out.println(a2); System.out.println(a3); } } /* Output: [dog[Animal@5b464ce8], House@2d3fcdbd , hamster[Animal@617c74e5], House@2d3fcdbd , cat[Animal@6537cf78], House@2d3fcdbd ] [dog[Animal@4501b7af], House@523884b2 , hamster[Animal@5b275dab], House@523884b2 , cat[Animal@61832929], House@523884b2 ] [dog[Animal@4501b7af], House@523884b2 , hamster[Animal@5b275dab], House@523884b2 , cat[Animal@61832929], House@523884b2 ] [dog[Animal@29774679], House@3ffc5af1 , hamster[Animal@5e5792a0], House@3ffc5af1 , cat[Animal@26653222], House@3ffc5af1 ] */ 可以发现，首先对象序列化实现了对象的深拷贝。此外，在o1中写入两次的对象地址是相同的，这意味着在同一个对象序列化流中，系统能够识别出相同的引用。 abstract class Shape implements Serializable { public static final int RED = 1, BLUE = 2, GREEN = 3; private int xPos, yPos, dimension; private static Random rand = new Random(47); private static int counter = 0; public abstract void setColor(int newColor); public abstract int getColor(); public Shape(int x, int y, int dim) { xPos = x; yPos = y; dimension = dim; } public String toString() { return getClass() + \"color[\" + getColor() + \"] xPos[\" + xPos + \"] yPos\" + yPos + \"] dim[\" + dimension + \"]\\n\"; } public static Shape randomFactory() { int x = rand.nextInt(100); int y = rand.nextInt(100); int dim = rand.nextInt(100); switch (counter++ % 3) { default: case 0: return new Circle(x, y, dim); case 1: return new Square(x, y, dim); case 2: return new Line(x, y, dim); } } } class Circle extends Shape { private static int color = RED; @Override public void setColor(int newColor) { color = newColor; } @Override public int getColor() { return color; } public Circle(int x, int y, int dim) { super(x, y, dim); } } class Square extends Shape { private static int color; public Square(int x, int y, int dim) { super(x, y, dim); color = RED; } @Override public void setColor(int newColor) { color = newColor; } @Override public int getColor() { return color; } } class Line extends Shape { private static int color = RED; public Line(int x, int y, int dim) { super(x, y, dim); } public static void serializeStaticState(ObjectOutputStream os) throws IOException { os.writeObject(color); } public static void deserializeStaticState(ObjectInputStream os) throws IOException { color = os.readInt(); } @Override public void setColor(int newColor) { color = newColor; } @Override public int getColor() { return color; } } public class Test { public static void main(String[] args) throws Exception { List&lt;Class&lt;? extends Shape>> shapeTypes = new ArrayList&lt;>(); shapeTypes.add(Circle.class); shapeTypes.add(Square.class); shapeTypes.add(Line.class); List&lt;Shape> shapes = new ArrayList&lt;>(); for (int i = 0; i &lt; 10; i++) shapes.add(Shape.randomFactory()); for (int i = 0; i &lt; 10; i++) ((Shape)shapes.get(i)).setColor(Shape.GREEN); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\"cad.out\")); out.writeObject(shapeTypes); Line.serializeStaticState(out); out.writeObject(shapes); System.out.println(shapes); } } // 类定义略 public class Test { public static void main(String[] args) throws Exception { // 恢复 ObjectInputStream in = new ObjectInputStream(new FileInputStream(\"cad.out\")); List&lt;Class&lt;? extends Shape>> shapeTypes2 = (List&lt;Class&lt;? extends Shape>>)in.readObject(); Line.deserializeStaticState(in); List&lt;Shape> shapes2 = (List&lt;Shape>) in.readObject(); System.out.println(shapes2); } } 注意，在上面代码中，除了Line对象以外的其它对象的static字段color在反序列化后没有设置正确的值，这也是Line类中两个静态方法serializeStaticState()和deserializeStaticState()的作用，手动实现static字段的序列化。 Perferences Perferences提供存储小的、受限的数据集合（基本类型和字符串），存储位置和方法与操作系统相关（Windows存储在注册表中）。","categories":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/categories/Java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://sinlapis.github.io/tags/笔记/"},{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"}]},{"title":"Java编程思想笔记0x0f","slug":"Java编程思想笔记0x0f","date":"2019-07-14T08:38:58.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2019/07/14/Java编程思想笔记0x0f/","link":"","permalink":"http://sinlapis.github.io/2019/07/14/Java编程思想笔记0x0f/","excerpt":"","text":"Java I/O 系统（五）压缩 Java I/O类库中的类支持读写压缩格式的数据流。压缩类库是按字节方式处理的，因此属于InputStream和OutputStream继承层次结构的一部分。 可以使用InputStreamReader和OutputStreamWriter在两种类型之间进行转换。 GZIP 使用GZIP压缩，直接将输出流封装成GZIPOutputStream或ZipOutputStream，解压就将输入流封装成GZIPInputStream或ZipInputStream。 public class GZIPcompress { public static void main(String[] args) throws IOException { // 检查参数 if (args.length == 0) { System.out.println(\"no file.\"); System.exit(1); } // 压缩 BufferedReader in = new BufferedReader(new FileReader(args[0])); BufferedOutputStream out = new BufferedOutputStream(new GZIPOutputStream(new FileOutputStream(\"test.gz\"))); System.out.println(\"Writing file\"); int c; while ((c = in.read()) != -1) out.write(c); in.close(); out.close(); // 解压 System.out.println(\"Reading file\"); BufferedReader in2 = new BufferedReader(new InputStreamReader(new GZIPInputStream(new FileInputStream(\"test.gz\")))); String s; while ((s = in2.readLine()) != null) System.out.println(s); } } 用Zip进行多文件压缩、解压public class Main { public static void main(String[] args) throws IOException { // 压缩 FileOutputStream f = new FileOutputStream(\"test.zip\"); CheckedOutputStream csum = new CheckedOutputStream(f, new Adler32()); ZipOutputStream zos = new ZipOutputStream(csum); BufferedOutputStream out = new BufferedOutputStream(zos); for (String arg: args) { System.out.print(\"Writing file \" + arg); BufferedReader in = new BufferedReader(new FileReader(arg)); zos.putNextEntry(new ZipEntry(arg)); int c; while ((c = in.read()) != -1) out.write(c); in.close(); out.flush(); } out.close(); // 校验和 System.out.println(\"Checksum: \" + csum.getChecksum().getValue()); // 解压 FileInputStream fi = new FileInputStream(\"test.zip\"); CheckedInputStream csumi = new CheckedInputStream(fi, new Adler32()); ZipInputStream in2 = new ZipInputStream(csumi); BufferedInputStream bis = new BufferedInputStream(in2); ZipEntry ze; while ((ze = in2.getNextEntry()) != null) { System.out.println(\"Reading file: \" + ze); int x; while ((x = bis.read()) != -1) System.out.write(x); } if (args.length == 1) System.out.println(\"Checksum: \" + csumi.getChecksum().getValue()); bis.close(); // 另一种解压方式 ZipFile zf = new ZipFile(\"test.zip\"); Enumeration e = zf.entries(); while (e.hasMoreElements()) { ZipEntry ze2 = (ZipEntry) e.nextElement(); System.out.println(\"File: \" + ze2); // ... } } } 对于每一个要加入压缩档案的文件，都必须调用putNextEntry()，并将其传递给一个ZipEntry对象。ZipEntry对象包含了一个功能很广泛的接口，可以获取和设置Zip文件内特定想上所有可利用的数据，例如名字、压缩和未压缩的文件大小、日期、校验和等等。 为了能够解压文件，ZipInputStream提供了一个getNextEntry()方法返回下一个ZipEntry（如果存在）。 为了读取校验和，必须拥有相关联的Checksum对象的访问权限。","categories":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/categories/Java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://sinlapis.github.io/tags/笔记/"},{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"}]},{"title":"Java编程思想笔记0x0e","slug":"Java编程思想笔记0x0e","date":"2019-07-14T02:40:21.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2019/07/14/Java编程思想笔记0x0e/","link":"","permalink":"http://sinlapis.github.io/2019/07/14/Java编程思想笔记0x0e/","excerpt":"","text":"Java I/O 系统（四）新I/O java.nio.*包中引入了新的Java I/O类库，其目的在于提高速度。而速度的提高来自于所使用的结构更接近于操作系统执行I/O的方式：通道和缓冲器。在交互过程中只需要和缓冲器交互，把缓冲器派送到通道。通道要么从缓冲器获得数据，要么向缓冲器发送数据。 唯一直接与通道交互的缓冲器是ByteBuffer，可以存储未加工字节的缓冲器。 引入NIO后，FileInputStream、OutputStream、RandomAccessFile被修改，可以产生FileChannel，用于操纵字节流。java.nio.channels.Channels类提供了可以在通道中产生Reader和Writer等字符模式类的方法。 public class Test { public static void main(String[] args) throws IOException { // FileChannel fc = new FileOutputStream(\"test.out\").getChannel(); FileOutputStream fos = new FileOutputStream(\"test.out\"); FileChannel fc = fos.getChannel(); fc.write(ByteBuffer.wrap(\"Some text\".getBytes())); fc.close(); fos.close(); // fc = new RandomAccessFile(\"test.out\", \"rw\").getChannel(); RandomAccessFile raf = new RandomAccessFile(\"test.out\", \"rw\"); fc = raf.getChannel(); fc.position(fc.size()); fc.write(ByteBuffer.wrap(\"Some more\".getBytes())); fc.close(); raf.close(); // fc = new FileInputStream(\"test.out\").getChannel(); FileInputStream fis = new FileInputStream(\"test.out\"); fc = fis.getChannel(); ByteBuffer buff = ByteBuffer.allocate(1024); fc.read(buff); buff.flip(); while(buff.hasRemaining()) System.out.print((char)buff.get()); fc.close(); fis.close(); } } getChannel()会产生一个FileChannel，可以向它传送用于读写的ByteBuffer，并且可以锁定文件的某些区域用于独占式访问。 对于只读访问，必须显式地使用静态allocate()方法来分配ByteBuffer。ByteBuffer的大小关乎I/O的速度。使用allocateDirect()可以产生与操作系统有更高耦合性的直接缓冲器，以获得更高的速度。但是这种分配的开支会更大，并且具体实现与操作系统相关。 public class ChannelCopy { private static final int BSIZE = 1024; public static void main(String[] args) throw Exception { if(args.length !=2) { System.out.println(\"arguments: sourcefile destfile\"); System.exit(1); } FileInputStream in = new FileInputStream(args[0]); FileOutputStream out = new FileOutputStream(args[1]); FileChannel fi = in.getChannel(), fo = out.getChannel(); ByteBuffer buffer = ByteBuffer.allocate(BSIZE); while((in.readf(buffer)) != -1) { buffer.flip(); fo.write(buffer); buffer.clear(); } } } 一旦调用read()来告知FileChannel向ByteBuffer存储字节，就必须调用缓冲器上的flip()，准备好让其它对象来读取其内容。如果打算继续使用缓冲器执行read()，则必须使用clear()。 FileChannel#read()返回-1时即达到了输入的末尾。 transferTo()和transferFrom()可以将一个通道和另一个通道相连。 转换数据public class Test { public static void main(String[] args) throws IOException { // 直接输入输出 FileOutputStream fos = new FileOutputStream(\"data2.txt\"); FileChannel fc = fos.getChannel(); fc.write(ByteBuffer.wrap(\"Some text\".getBytes())); fc.close(); fos.close(); FileInputStream fis = new FileInputStream(\"data2.txt\"); fc = fis.getChannel(); ByteBuffer bb = ByteBuffer.allocate(1024); fc.read(bb); bb.flip(); System.out.println(bb.asCharBuffer()); System.out.println(\"-----\"); bb.rewind(); // 输出时解码 String encoding = System.getProperty(\"file.encoding\"); System.out.println(\"encoding: \" + encoding); System.out.println(Charset.forName(encoding).decode(bb)); System.out.println(\"-----\"); fis.close(); // 输入时编码 fos = new FileOutputStream(\"data2.txt\"); fc = fos.getChannel(); fc.write(ByteBuffer.wrap(\"Some text\".getBytes(\"UTF-16BE\"))); fc.close(); fos.close(); fis = new FileInputStream(\"data2.txt\"); fc = fis.getChannel(); bb.clear(); fc.read(bb); bb.flip(); System.out.println(bb.asCharBuffer()); // 使用CharBuffer输出 fos = new FileOutputStream(\"data2.txt\"); fc = fos.getChannel(); bb = ByteBuffer.allocate(24); bb.asCharBuffer().put(\"Some text\"); fc.write(bb); fc.close(); fis.close(); // 使用CharBuffer输入 fis = new FileInputStream(\"data2.txt\"); fc = fis.getChannel(); bb.clear(); fc.read(bb); bb.flip(); System.out.println(bb.asCharBuffer()); fc.close(); fis.close(); fos.close(); } } /* Output: 卯浥⁴數 ----- encoding: UTF-8 Some text ----- Some text Some text */ java.nio.CharBuffer有一个toString()方法，可以返回一个包含缓冲器所有字符的字符串。但是缓冲器中容纳的是普通的字节，要将其转为字符，要么在输入时对其进行编码，要么在将其从缓冲器输出时对其进行解码。 获取基本类型 向ByteBuffer插入基本类型数据，可以利用asCharBuffer()、asShortBuffer()等获得该缓冲器上的视图，然后使用视图的put()方法。注意使用ShortBuffer的put()方法时需要进行强制类型转换，而其它所有的数据缓冲器在使用put()方法时，不要进行转换。 视图缓冲器 视图缓冲器可以通过某个特定的基本数据类型的试穿查看其底层的ByteBuffer。此外还可以从ByteBuffer一次一个或者成批（数组）读取基本类型值。 public class IntBufferDemo { public static void main(String[] args) { ByteBuffer bb = ByteBuffer.allocate(1024); IntBuffer ib = bb.asIntBuffer(); ib.put(new int[]{11, 42, 47, 99, 143, 811, 1016}); System.out.println(ib.get(3)); System.out.println(\"-----\"); ib.put(3, 1811); // [11, 42, 47, 1811, 143, 811, 1016] ib.flip(); while(ib.hasRemaining()) { int i = ib.get(); System.out.println(i); } } } 上面代码中，先用重载后的put()方法存储一个整数数组。get()和put()方法调用直接访问底层ByteBuffer中的某个整数位置。 小端：低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。大端：高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。 ByteBuffer默认是大端形式存储数据，并且数据在网络中传送时也常常使用大端模式。可以使用带有参数ByteOrder.BIG_ENDIAN或ByteOrder.LITTLE_ENDIAN的order()方法改变ByteBuffer的字节排序方式。 缓冲器的细节 Buffer由数据和四个索引组成。四个索引mark、position、limit、capacity可以高效地访问及操纵Buffer中的数据。 方法 功能 capacity() 返回缓冲区的容量capacity clear() 清空缓冲区，将position设置为0，limit设置为容量capacity，可以用于覆写缓冲区 flip() 将limit设为position，position设为0，用于准备从缓冲区读取已经写入的数据 limit() 返回limit值 limit(int lim) 设置limit值 mark() 将mark设为position position() 返回position值 position(int pos) 设置position值 remaining() 返回limit - position hasRemaining() 若有介于position和limit之间的元素，则返回true 内存映射文件 内存映射文件可以创建和修改因为过大而不能放入内存的文件。对应类为MappedByteBuffer。 public class LarggeMappedFiles { static int length = 0x8FFFFFFF; public static void main(String[] args) throws Exception { RandomAccessFile raf = new RandomAccessFile(\"test.dat\", \"rw\"); MappedByteBuffer mbb = raf.getChannel().map(FileChannel.MapMode.READ_WRITE, 0, length); for (int i = 0; i &lt; length; i++) mbb.put((byte)'x'); System.out.println(\"Finished writing\"); for (int i = length / 2; i &lt; length / 2 + 6; i++) System.out.println((char)mbb.get(i)); } } MappedByteBuffer主要是通过FileChannel#map方法，把文件映射到虚拟内存，并返回逻辑地址address，后续文件的读写操作都使用维护的虚拟内存地址和偏移进行操作。 文件加锁 文件加锁机制允许同步访问某个作为共享资源的文件，并且文件锁对其它的操作系统进程是可见的，因为Java的文件加锁直接映射到了本地操作系统的加锁工具。 public class FileLocking { public static void main(String[] args) throws Exception { FileOutputStream fos = new FileOutputStream(\"file.txt\"); FileLock fl = fos.getChannel().tryLock(); if (fl != null) { System.out.println(\"Locked File\"); TimeUnit.MILLISECONDS.sleep(100); fl.release(); System.out.println(\"Released Lock\"); } fos.close(); } } 通过对FileChannel调用tryLock()或lock，就可以获得整个文件的FileLock。tryLock()是非阻塞式的，会尝试一次获得锁，如果失败则直接返回。lock()是阻塞式的，会阻塞进程直到获得锁，或调用lock()的线程中断，或调用lock()的通道关闭。Java虚拟机会自动释放锁或者关闭加锁的通道，也可以显式使用FileLock#release()释放锁。 可以对文件的一部分上锁，使用重载的tryLock(long position, long size, boolean shared)或lock(long position, long size, boolean shared)，其中加锁区域由size - position决定，第三个参数指明是否为共享锁。 对独占所或者共享锁的支持必须由底层的操作系统提供，如果操作系统不支持共享锁并为每一个请求都创建一个锁，那么就会使用独占锁。 SocketChannel、DatagramChannel、ServerSocketChannel不需要加锁，因为这些通道是从单进程实体继承而来，通常不在两个进程之间共享网络socket。 对于映射文件，同样可以进行部分加锁，以便其它进程可以修改文件中未被加锁的部分，例如数据库。其方法和上述过程相同。","categories":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/categories/Java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://sinlapis.github.io/tags/笔记/"},{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"}]},{"title":"Java编程思想笔记0x0d","slug":"Java编程思想笔记0x0d","date":"2019-07-12T11:30:15.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2019/07/12/Java编程思想笔记0x0d/","link":"","permalink":"http://sinlapis.github.io/2019/07/12/Java编程思想笔记0x0d/","excerpt":"","text":"Java I/O 系统（三）标准I/O 标准I/O是Unix中的概念，指程序所使用的单一信息流。程序的所有输入都可以来自标准输入，所有输出也都可以发送到标准输出，以及所有的错误信息都可以发送到标准错误。其意义在于，可以容易的吧程序传亮起来，一个程序的标准输出可以成为另一个程序的标准输入。 从标准输入中读取 Java提供了System.in、System.out和System.err。System.out和System.err已经事先被包装成了PrintStream对象，System.in是没有被包装过的InputStream。 public class Test { public static void main(String[] args) throws IOException { BufferedReader stdin = new BufferedReader(new InputStreamReader(System.in)); String s; while((s = stdin.readLine()) != null &amp;&amp; s.length() != 0) System.out.println(s); } } 标准I/O重定向 Java的System类提供一些简单的静态方法调用，以允许我们队标准输入、输出和错误I/O流进行重定向。 public class Test { public static void main(String[] args) throws IOException { PrintStream console = System.out; BufferedInputStream in = new BufferedInputStream(new FileInputStream(\"Test.java\")); PrintStream out = new PrintStream(new BufferedOutputStream(new FileOutputStream(\"test.out\"))); System.setIn(in); System.setOut(out); System.setErr(out); BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String s; while((s = br.readLine()) != null) System.out.println(s); out.close(); System.setOut(console); } } 上面代码中将标准输入接在了文件上，而标准输出和标准错误重定向至另一个文件。此外，在开始部分保存了最初System.out的引用，在最后部分进行了还原。 I/O重定向操作的是字节流，而不是字符流，因此重定向时注意使用InputStream和OutputStream。 进程控制 可以使用Java执行控制台命令，并获取其标准输出、错误。 public class Test { public static void main(String[] args) throws IOException { OSExecute.command(\"ping 114.114.114.114\"); } } class OSExecute { public static void command(String command) { boolean err = false; try { Process process = new ProcessBuilder(command.split(\" \")).start(); BufferedReader results = new BufferedReader(new InputStreamReader(process.getInputStream())); String s; while ((s = results.readLine()) != null) System.out.println(s); BufferedReader errors = new BufferedReader(new InputStreamReader(process.getErrorStream())); while((s = errors.readLine()) != null) { System.err.println(s); err = true; } } catch (Exception e) { if(!command.startsWith(\"CMD /C\")) command(\"CMD /C\" + command); else throw new RuntimeException(e); } if (err) { System.err.println(\"Error executing \" + command); } } }","categories":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/categories/Java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://sinlapis.github.io/tags/笔记/"},{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"}]},{"title":"Java编程思想笔记0x0c","slug":"Java编程思想笔记0x0c","date":"2019-07-11T06:43:45.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2019/07/11/Java编程思想笔记0x0c/","link":"","permalink":"http://sinlapis.github.io/2019/07/11/Java编程思想笔记0x0c/","excerpt":"","text":"Java I/O 系统（二）I/O流典型的使用方式缓冲输入文件class BufferedInputFile { public static String read(String filename) throws IOException { BufferedReader in = new BufferedReader(new FileReader(filename)); String s; StringBuilder sb = new StringBuilder(); while((s = in.readLine()) != null) sb.append(s + \"\\n\"); in.close(); return sb.toString(); } } 如果想要打开一个文件用于字符输入，可以使用以String或File对象作为文件名的FileInputReader。为了提高速度，需要对文件进行缓冲，可以将所产生的引用传给一个BufferedReader构造器。BufferedReader也提供readLine()方法，可以进行内容读取。当readLine()返回null时即达到文件末尾。最后调用close()关闭文件。 从内存输入public class Main { public static void main(String[] args) throws IOException { StringReader in = new StringReader(\"aaa bbb ccc ddd\\n\"); int c; while((c = in.read()) != -1) System.out.print((char)c); in.close(); } } 使用StringReader读取内存中的String，read()每次会读取一个字节（是int形式，注意使用类型转换）。 格式化的内存输入public class Main { public static void main(String[] args) throws IOException { DataInputStream in = new DataInputStream(new BufferedInputStream(new FileInputStream(\"Main.java\"))); while (in.available() != 0) { System.out.println((char)in.readByte()); } /* 一次读多个字节 byte[] b = new byte[10]; while (in.available() != 0) { in.read(b); System.out.println(Arrays.toString(b)); } */ } } 读取格式化的数据，需要使用DataInputStream，这是一个面向字节的I/O类。因为任何字节的值都是合法结果，所以需要available()方法检查还有多少可供存取的字符。 基本的文件输出public class Main { public static void main(String[] args) throws IOException { BufferedReader in = new BufferedReader(new FileReader(\"a.txt\")); PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(\"b.txt\"))); int lineCount = 1; String s; while((s = in.readLine()) != null) out.println(lineCount++ + \": \" + s); in.close(); out.close(); } } FileWriter对象可以向文件写入数据。首先，创建一个与指定文件连接的FileWriter。此外，通常会用BufferedWriter将其包装来缓冲输出，因为缓冲往往能够显著地提高I/O性能。为了提供格式化机制，使用了PrintWriter装饰。最后，应该显式调用Writer#close()，否则缓冲区内容不会刷新清空，内容也不会写入文件。 在Java SE5中，PrintWriter添加了一个辅助构造器，可以省略其它装饰器，直接填入文件名String即可。 存储和恢复数据public class Main { public static void main(String[] args) throws IOException { DataOutputStream out = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(\"a.txt\"))); out.writeDouble(3.14159); out.writeUTF(\"That was pi\"); out.writeDouble(1.41413); out.writeUTF(\"Square root of 2\"); out.close(); DataInputStream in = new DataInputStream(new BufferedInputStream(new FileInputStream(\"a.txt\"))); System.out.println(in.readDouble()); System.out.println(in.readUTF()); System.out.println(in.readDouble()); System.out.println(in.readUTF()); } } 可以用DataOutputStream、DataInputStream以与机器无关方式从底层流中读写基本 Java 数据类型。 当使用DataOutputStream写字符串并让DataInputStream能够恢复它的唯一可靠做法就是使用UTF-8编码，在上面代码中就是使用writeUTF()和readUTF()。 ASCII字符只占7位，为了避免空间浪费，UTF-8将ASCII字符编码成单一字节形式，而非ASCII字符则编码成两到三个字节的形式。另外，字符串的长度存储在UTF-8字符串的前两个字节。writeUTF()和readUTF()使用的是UTF-8变体。 为了保证所有的读方法能够正常工作，必须知道流中数据项所在的确切位置，要么为文件中的数据采用固定的割舍，标准要么将额外的信息保存在文件中以便能够对其解析来确定数据的存放位置。","categories":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/categories/Java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://sinlapis.github.io/tags/笔记/"},{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"}]},{"title":"Java编程思想笔记0x0b","slug":"Java编程思想笔记0x0b","date":"2019-07-09T12:14:59.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2019/07/09/Java编程思想笔记0x0b/","link":"","permalink":"http://sinlapis.github.io/2019/07/09/Java编程思想笔记0x0b/","excerpt":"","text":"Java I/O 系统（一）File File类既代表一个特定文件的名称，又能代表一个目录下的一组文件的名称。 public class Main { public static void main(String[] args) { File path = new File(\".\"); String[] list; if(args.length == 0) list = path.list(); else list = path.list(new DirFilter(args[0])); Arrays.sort(list, String.CASE_INSENSITIVE_ORDER); for(String dirItem: list) System.out.println(dirItem); } } class DirFilter implements FilenameFilter { private Pattern pattern; public DirFilter(String regex) { pattern = Pattern.compile(regex); } @Override public boolean accept(File dir, String name) { return pattern.matcher(name).matches(); } } 上面代码中，File#list()可以接受一个FilenameFilter对象，用于过滤文件。此处使用了回调，重载了accept()方法并让list()调用。 输入和输出InputStream类型 InputStream的作用是用来表示那些从不同数据源产生的输入的类，包括：字节数组、String对象、文件、管道、由其他种类的流组成的序列等，每一种数据源都有相应的InputStream子类。 类 功能 构造器参数 如何使用 ByteArrayInputStream 允许将内存的缓冲区当做InputStream使用 缓冲区，字节将从中取出 作为一种数据源：将其与FilterInputStream对象相连以提供有用接口 StringBufferInputStream 将String转换成InputStream使用 字符串，底层是实现使用StringBuffer 作为一种数据源：将其与FilterInputStream对象相连以提供有用接口 FileInputStream 用于从文件中读取信息 字符串，表示文件名、文件或FileDescriptor对象 作为一种数据源：将其与FilterInputStream对象相连以提供有用接口 PipedInputStream 产生用于写入相关PipedOutputStream的数据，实现管道化的概念 PipedOutputStream 作为一种数据源：将其与FilterInputStream对象相连以提供有用接口 SequenceInputStream 将两个或多个InputStream对象转换成单一InputStream 两个InputSteam对象或者一个容纳InputStream对象的容器Enumeration 作为多线程中数据源：将其与FilterInputStream对象相连以提供有用接口 FilterInputStream 抽象类，作为装饰器的接口。其中，装饰器为其它的InputStream类提供有用的功能 - - OutputStream类型 OutputStream类的类别决定了输出所要去往的目标：字节数组、文件或管道。 类 功能 构造器参数 如何使用 ByteArrayOutputStream 在内存中创建缓冲区，所有送往流的数据都要放置在此缓冲区。 缓冲区初始化尺寸（可选） 用于指定数据的目的地：将其与FilterOutputStream对象相连以提供有用接口 FileOutputStream 用于将信息写至文件 字符串，表示文件名、文件或FileDescriptor对象 用于指定数据的目的地：将其与FilterOutputStream对象相连以提供有用接口 PipedOutputStream 任何写入其中的信息都会自动作为相关PipedInputStream的输出。实现管道化的概念 PipedInputStream 用于指定多线程的数据的目的地：将其与FilterOutputStream对象相连以提供有用接口 FilterOutputStream 抽象类，作为装饰器的皆苦。其中，装饰器为其它OutputStream提供有用功能 - - 添加属性和有用的接口FilterInputStream 类 功能 构造器参数 如何使用 DataInputStream 与DataOutputStream搭配使用，可以按照可移植方式从流读取基本数据类型（int、char、long等） InputStream 包含用于读取基本类型数据的全部接口 BufferedInputStream 可以防止每次读取时都得进行实际写操作，代表使用缓冲区。 InputStream，可选指定缓冲区大小 本质上不提供接口，只不过是向进程中添加缓冲区所必须的 LineNumberInputStream 跟踪输入流中的行号，可调用getLineNumber()和setLineNumber(int) InputStream 仅增加了行号，因此可能要与接口对象搭配使用 PushbackInputStream 能弹出一个字节的缓冲区，因此可以将读到的最后一个字符回退。 InputStream 通常作为编译器的扫描器 FilterOutputStream 类 功能 构造器参数 如何使用 DataOutputStream 与DataInputStream搭配使用，可以按照可移植方式从流读取基本数据类型（int、char、long等） OutputStream 包含用于写入基本类型数据的全部接口 PrintStream 用于产生格式化输出。其中DataOutputStream处理数据的存储，PrintStream处理显示 OutputStream，可选是否每次换行时清空缓冲区 - BufferedOutputStream 可以防止每次读取时都得进行实际写操作，代表使用缓冲区。 OutputStream，可选指定缓冲区大小 本质上不提供接口，只不过是向进程中添加缓冲区所必须的 Reader和Writer InputStream和OutputStream是面向字节形式的I/O，而Reader和Writer则提供兼容Unicode与面向字符的I/O功能。 数据的来源与去处 InputStream和OutputStream Reader和Writer InputStream Reader，适配器InputStreamReader OutputStream Writer， 适配器OutputStreamWriter FileInputStream FileReader FileOutputStream FileWriter - StringReader - StringWriter ByteArrayInputStream CharArrayReader ByteArrayOutputStream CharArrayWriter PipedInputStream PipedReader PipedOutputStream PipedWriter 更改流的行为 FilterInputStream和FilterOutputStream FilterReader和FilterWriter FilterInputStream FilterReader FilterOutputStream FilterWriter BufferedInputStream BufferedReader BufferedOutputStream BufferedWriter PrintStream PrintWriter 如果需要使用readLine()方法，就不应该使用DataInputStream，而用BufferedReader代替。 DataInputStream#readLine()方法已被废弃，因为它无法正确地将字节转换为字符。","categories":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/categories/Java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://sinlapis.github.io/tags/笔记/"},{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"}]},{"title":"DNS与BIND笔记0x00","slug":"DNS与BIND笔记0x00","date":"2019-07-08T02:38:09.000Z","updated":"2021-03-03T02:50:12.455Z","comments":true,"path":"2019/07/08/DNS与BIND笔记0x00/","link":"","permalink":"http://sinlapis.github.io/2019/07/08/DNS与BIND笔记0x00/","excerpt":"","text":"DNS的运行机制域命名空间 DNS的本质是分布式数据库，通过域名来进行索引。每个域名本质上是一颗大型逆向树的一条路径，这棵逆向树就是域命名空间。 域名 如果根节点（以”.”和一个空标签结束）出现在一个域名的结尾时，称之为完全限定域名（fully qualified domain name, FQDN），它能准确地标识出一个节点在层次结构中的位置。 域 一个域就是域命名空间的一颗子树。 资源记录 与域名相关的数据都被包含在资源记录（resource record, RR）中。记录按照所关联的网络或软件的类型被分成不同的类。 名称服务器和区域 存储域命名空间信息的程序称作名称服务器（nameserver）。名称服务器通常只拥有域命名空间某一部分的完整信息，这一部分称作区域（zone）。加载区域后，名称服务器可宣称对此区域具有权威（authority）。 区域和域的区别：所有的顶级域以及许多二级域和更低级别的域通过授权被划分成了更小更好管理的单元，这些单元就是区域。 名称服务器的类型 primary master：其区域数据来源于主机上的文件 slave(secondary master)：其区域数据来源于primary master或者另外一台slave。 解析解析器 解析器是访问名称服务器，从域命名空间获取信息的客户端程序。 递归查询 当名称服务器接收到递归查询请求时，如果它能够回答，就直接返回查询结果。如果它不能回答，那么它递归检查自己是否知道域名的权威名称服务器，如果知道，就给该权威名称服务器发送查询请求，如果不知道，则再检索上一级域名的权威名称服务器，直到检索根域名，此时将直接向根服务器发起查询请求。 迭代查询 在迭代查询请求中，收到请求的名称服务器只会返回它认为的“最佳答案”，即返回解析结果或者它所知道的和域名最相近的权威名称服务器。 往返时间 往返时间（roundtrip time，RTT）是同一区域的不同名称服务器的选择依据。 缓存 名称服务器在处理递归查询时，会遇到许多与域命名空间有关的信息，它会记录下每次遇到的名称服务器、地址和对应的区域。这样既能加快处理查询请求的速度，也能减少向根服务器查询的次数。 生存时间 生存时间（time to live，TTL）是名称服务器允许数据在缓存中存放的时间，如果到期，名称服务器就会丢弃过期数据，并从权威名称服务器获取新的数据。","categories":[{"name":"网络","slug":"网络","permalink":"http://sinlapis.github.io/categories/网络/"}],"tags":[{"name":"网络","slug":"网络","permalink":"http://sinlapis.github.io/tags/网络/"},{"name":"笔记","slug":"笔记","permalink":"http://sinlapis.github.io/tags/笔记/"},{"name":"DNS","slug":"DNS","permalink":"http://sinlapis.github.io/tags/DNS/"}]},{"title":"Java编程思想笔记0x0a","slug":"Java编程思想笔记0x0a","date":"2019-07-07T08:52:29.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2019/07/07/Java编程思想笔记0x0a/","link":"","permalink":"http://sinlapis.github.io/2019/07/07/Java编程思想笔记0x0a/","excerpt":"","text":"容器深入研究Collection的功能方法 方法 说明 boolean add(T) 添加元素，如果类型不为T则返回false。可选 boolean addAll(Collection&lt;? extends T&gt;) 添加所有元素，只要添加了元素就返回true。可选 void clear() 移除所有元素。可选 boolean contains(T) 如果容器包含该元素，则返回true boolean containsAll(Collection&lt;?&gt;) 如果容器中包含所有元素，则返回true boolean isEmpty() 容器中没有元素返回true Iterator&lt;T&gt; iterator() 返回一个可以遍历容器所有元素的Iterator&lt;T&gt; boolean remove(Object) 如果元素在容器中，则移除一个该元素的实例。如果发生了移除则返回true。可选 boolean removeAll(Collection&lt;?&gt;) 移除参数中所有的元素，如果发生了移除就返回true。可选 boolean retainAll(Collection&lt;?&gt;) 只保存参数中的元素，只要Collection发生了改变就返回true int size() 返回容器中元素的数目 Object[] toArray() 返回包含容器中所有元素的数组 &lt;T&gt; T[] toArray(T[] a) 返回包含容器中所有元素的数组，数组类型与参数类型一致 可选操作 在Collection方法中，一些方法是可选的，这意味着继承Collection时这些方法可以不进行覆盖。此时导出类对象调用该方法时会出现UnsupportedOperationException。Collection的可选方法实现如下: public boolean add(E e) { throw new UnsupportedOperationException(); } 可见，如果导出类不实现可选方法，那么该方法会调用Collection中的实现，即抛出一个UnsupportedOperationException异常。 Set与存储顺序Set 存入Set的每个元素都必须是唯一的，因为Set不保存重复元素。加入Set的元素必须定义equals()方法一确保对象的唯一性。Set和Collection有完全一样的接口。Set不保证维护元素的次序。 HashSet 为快速查找而设计的Set，存入HashSet的元素必须定义hashCode()。HashSet存储元素的顺序是按照底层哈希桶号从小到大排序，如果桶号相同就按照放入桶的先后顺序。 TreeSet 保持次序的Set，底层为树结构。使用它可以从Set中提取有序的序列。元素必须实现Comparable接口 LinkedHashSet 具有HashSet的查询速度，且内部使用链表维护元素的顺序（插入的顺序）。 SortedSet 可以保证其中的元素处于排序状态，并提供一些附加功能 队列LinkedList 队列的基本实现。 优先级队列 PriorityQueue：按照元素从小到大排列。 MapMap的各种实现 HashMap：Map基于散列表的实现。插入和查询键值对的开销是固定的，可以通过构造器设置容量和负载因子，以调整容器性能 负载因子：如果容器持有元素超过一定比例会进行扩容，此时作为底层实现的旧数组会被更大容量的新数组取代。这个比例就是负载因子。 LinkedHashMap：类似于HashMap，但是迭代遍历时，取得键值对的顺序是插入顺序，或者是最近最少使用（LRU）次序。仅比HashMap慢一点，而在迭代访问时反而更快，因为其使用链表维护内部次序。 TreeMap：基于红黑树的实现。查看键或者键值对时，它们会被排序。TreeMap的特点在于，所得到的结果是经过排序的（按元素大小排序）。TreeMap是唯一带有subMap()方法的Map，它可以返回一棵子树。 WeakHashMap：弱键映射，允许释放映射所指向的对象，这是为解决某类特殊问题而设计的。如果映射之外没有引用指向某个键，则此键可以被垃圾回收。 ConcurrentHashMap：一种线程安全的Map，它不涉及同步加锁。 IdentityHashMap：使用==代替equals()对键进行比较的散列映射，专为解决特殊问题而设计的。 散列 HashMap使用了散列码作为键的搜索。在Java中，hashCode()是根类Object的方法，因此所有Java对象都能产生散列码。使用hashCode()进行查询能够显著地提高性能。 默认的Object#equals()只是比较对象地址，如果需要某个自定义的类作为键使用，需要重载hashCode()和equals()。 容器的选择List ArrayList应该作为默认选择，只有当程序的性能因为经常从表中间进行插入和删除而变差的时候，才去选择LinkedList。如果使用的是固定数量的元素，也可以直接使用数组。 Set HashSet的性能基本上总是比TreeSet好，特别是在添加和查询元素时。当需要对元素进行排序，或者需要对元素进行迭代时才会需要TreeSet。 Map 类似于Set的结果，TreeMap比HashMap要慢。 实用方法 方法 说明 max(Collection), min(Collection) 返回参数Collection中最大或者最小的元素，采用Collection中内置的自然比较法 max(Collection, Comparator), min(Collection, Comparator) 返回参数Collection中最大或最小的元素，采用参数中的Comparator进行比较 indexOfSubList(List source, List target) 返回target在source中第一次出现的位置，或者在找不到时返回-1 lastIndexOfSubList(List source, List target) 返回target在source中最后一次出现的位置，或者在找不到时返回-1 replaceAll(List&lt;T&gt;, T oldVal, T newVal) 使用newVal替换所有oldVal reverse(List) 逆转所有元素的次序 reverseOrder(), reverseOrder(Comparator&lt;T&gt;) 返回一个Comparator，它可以以逆转实现了Comparator&lt;T&gt;的对象集合的自然顺序。第二个版本可以逆转所提供的Comparator的顺序 rotate(List, int distance) 所有元素向后移动distance个位置，将末尾的元素循环到前面来 shuffle(List), shuffle(List, Random) 随机改变指定列表顺序。第一种形式提供其自己的随机机制，第二种则来源于参数Random对象 sort(List&lt;T&gt;), sort(List&lt;T&gt;, Comparator&lt;? super T&gt; c) 使用List&lt;T&gt;中的自然顺序排序。第二种形式允许提供用于排序的Comparator copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) 将src中的元素复制到dest swap(List, int i, int j) 交换list中位置i与位置j的元素，通常比手动实现要快 fill(LIst&lt;? super T&gt;, T x) 用对象x替换list中的所有元素 disjoint(Collection, Collection) 当两个集合没有重复元素时返回true frequency(Collection, Object x) 返回Collection中x出现的次数 emptyList(), emptyMap(), emptySet() 返回不可变且为泛型的List、Map、Set singleton(T x), singletonList(T x), singletonMap(K key, V value) 产生不可变的Set&lt;T&gt;、List&lt;T&gt;、Map&lt;K, V&gt;。 在比较字符串而使用max()、min()、sort()等方法时，使用参数String.CASE_INSENSITIVE_ORDER可以忽略大小写。 同步控制 Collections.synchonizedCollection()可以传入一个新生成的容器，返回的是有同步功能的版本。类似的还有Collections.synchonizedList()、Collections.synchonizedSet()、Collections.synchonizedMap()等。 快速报错：Java容器的一种保护机制，能够防止多个进程同时修改同一个容器的内容。它会探查容器上的任何除了当前进程进行的操作以外的所有变化，一旦发现其它进行修改了容器，就立刻抛出ConcurrentModificationException异常。","categories":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/categories/Java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://sinlapis.github.io/tags/笔记/"},{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"}]},{"title":"Java编程思想笔记0x09","slug":"Java编程思想笔记0x09","date":"2019-07-07T01:42:32.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2019/07/07/Java编程思想笔记0x09/","link":"","permalink":"http://sinlapis.github.io/2019/07/07/Java编程思想笔记0x09/","excerpt":"","text":"泛型（四）动态类型安全 因为可以向旧版本的Java代码中传递容器，而如果旧版本的代码没有使用泛型则需要动态类型检查。java.uitl.Collections中有一系列方法可以完成这项工作：checkedCollection()、checkedList()、checkedMap()、checkedSet()、checkedSortedMap()、checkedSortedSet()。其参数为希望获得检查的容器和强制要求的类型。受检查的容器在插入不正确的类型时会抛出ClassCastException。例如： List&lt;Cat&gt; cats = Collections.checkedList(new ArrayList&lt;&gt;(), Cat.class); 此时插入Cat对象是正确的，而插入Dog对象则会出现异常。 异常 由于擦除的原因，将泛型应用于异常是非常受限的。catch语句不能捕获泛型类型异常，因为在编译期和运行时都必须知道异常的确切类型。泛型类也不能直接或间接继承Throwable。 在方法的throw子句可以使用类型参数，使得随检查异常的类型发生变化而变化的代码 混型 混型是指回合多个类的能力，以产生一个可以表示混型中所有类型的类。 混型的价值之一是可以将特性和行为一致地应用于多个类型，如果在混型类中修改，那么这些修改将会应用于混型所应用的所有类型之上。混型有一点面向切面编程的意思。 与接口混合 一种常见的混型方法就是使用接口产生混型效果，即使用代理，每个混入类型都有一个相应的域，调用方法时要转发给对应的域。 使用装饰器模式 装饰器是通过使用组合和形式化结构（可装饰物/装饰器层器结构）类实现的，而混型是基于继承的。因此可以将基于参数化类型的混型当做一种泛型装饰器机制，这种机制不需要装饰器设计模式的继承结构。（即声明一个混型，其泛型类型参数为混型基于的所有类型，以达到混型的目的） 与动态代理混合 可以使用动态代理实现更为接近混合模型的机制。通过使用动态代理，所产生的类的动态类型将会是已经混入的组合类型。 由于动态代理的限制，每个被混入的类都必须是某个接口的实现。 在调用混入类型的方法之前，需对混型对象进行向下转型到合适的类型。 潜在类型机制 潜在类型机制，又称鸭子类型机制，具有这种机制的语言只要求实现某个方法的自己，而不是某个特定类型或者接口，从而放松了限制。潜在类型机制可以横跨类型继承结构，调用某个不是公共接口的方法。 在Java中是没有原生实现的潜在类型机制，会被强制要求继承某个类或者实现某个接口。 对缺乏潜在类型机制的补救反射class CommunicateReflectively { public static void perform(Object speaker) { Class&lt;?> spkr = speaker.getClass(); try { Method speak = spkr.getMethod(\"speak\"); speak.invoke(speaker); } catch(NoSuchMethodException e) { System.out.println(speaker + \"cannot speak\"); } } } 上面的代码使用了反射获取了指定名称的方法，但是类型检查转移到了运行时。 将一个方法应用于序列public class Apply { public static &lt;T, S extends Iterable&lt;? extends T>> void apply(S seq, Method f, Object... args) { try { for (T t: seq) { f.invoke(t, args); } } catch(Exception e) { throw new RuntimException(e); } } } 上面代码的目的是实现对任意的序列S&lt;T&gt;调用某种方法，然而恰好序列都是实现了Iterable接口的。但是这种方法并不适用于没有实现内建接口或者继承内建类的类型。 用适配器模式仿真潜在类型机制 可以使用适配器模式来适配已有的接口，来产生需要的接口。 数组数组的特点 效率：数组是一种效率最高的存储和随机访问对象引用序列的方式，代价是数组对象的大小被固定，并且在其生命周期中不能改变。 类型：相比缺少泛型的容器，数组可以持有某种类型的对象，可以通过编译期检查来防止不当的操作。 持有基本类型：数组可以持有基本类型，但是容器不能直接持有基本类型。","categories":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/categories/Java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://sinlapis.github.io/tags/笔记/"},{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"}]},{"title":"Java编程思想笔记0x08","slug":"Java编程思想笔记0x08","date":"2019-07-05T10:57:32.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2019/07/05/Java编程思想笔记0x08/","link":"","permalink":"http://sinlapis.github.io/2019/07/05/Java编程思想笔记0x08/","excerpt":"","text":"泛型（三）问题任何基本类型都不能作为类型参数 Java泛型中不能使用基本类型用作类型参数，取而代之可以使用基本类型的包装器以及自动包装机制。 实现参数化接口 一个类不能实现同一个泛型接口的两种变体，由于擦除的原因，这两个变体会成为相同的接口。 转型和警告 使用带有泛型类型参数的转型或instanceof不会有任何效果。因为类型参数T会被擦除到第一个边界，默认为Object，使用转型或instanceof也只使用了Object。 在必须进行转型到某种泛型类时，需要使用泛型类对象转型，例如List.class.cast(x)，但是无法转换到具体类型，即不能使用List&lt;RealClass&gt;.class.cast(x)。 重载 由于擦除的原因，相同泛型类、不同类型参数的重载方法将产生相同的类型签名。 基类劫持接口 当父类实现泛型接口时，实现了接口中的某个带有相应泛型参数的方法，此时子类将不能修改该方法的参数类型。 自限定的类型古怪的循环泛型 诸如class Sub extends Basic&lt;Sub&gt;的定义就是古怪的循环泛型，子类类型出现在了基类中。 其本质是基类用导出类替代其参数，意味着泛型基类变成了一种其所有导出类的公共功能的模板，但是这些功能对于其所有的参数和返回值，将使用导出类型。 自限定 下面代码中SelfBounded即自限定的泛型基类。 class SelfBounded&lt;T extends SelfBounded&lt;T>> { T element; SelfBounded&lt;T> set(T arg) { element = arg; return this; } T get() { return element; } } 继承SelfBounded必须类似与class A extends SelfBounded&lt;A&gt;来定义子类，这保证了类型参数必定与正在被定义的类相同。 同样的，自限定还可以用于泛型方法，防止该方法用于自限定参数之外的任何事物上： public class SelfBoundingMethods { static &lt;T extends SelfBoundingMethods&lt;T>> T f (T arg) { return arg.set(arg).get(); } public static void main(String[] args) { A a = f(new A()); } } 参数协变 自限定类型的意义在于能够产生协变参数类型，即方法参数类型会随着子类变化而变化，不会出现重载。 但实际上如果仅为了实现参数协变，自限定并不是必要的，使用循环泛型就能解决，例如： public class Test { public static void main(String[] args) { A a = new A(); System.out.println(a.set(a)); System.out.println(a); System.out.println(a.get()); B b = new B(); System.out.println(b.set(b)); System.out.println(b); System.out.println(b.get()); } } class SelfBounded&lt;T extends SelfBounded&lt;T>> { T element; SelfBounded&lt;T> set(T arg) { element = arg; return this; } T get() { return element; } } class Cyclic&lt;T> { T element; Cyclic&lt;T> set(T arg) { element = arg; return this; } T get() { return element; } } class A extends SelfBounded&lt;A> {} class B extends Cyclic&lt;B> {} /* Output: A@2c13da15 A@2c13da15 A@2c13da15 B@9e89d68 B@9e89d68 B@9e89d68 */ 上面代码中，SelfBounded是自限定的，而Cyclic仅是普通的泛型类，其子类B使用了循环泛型就实现了参数协变。两者唯一的不同仅在于自限定中类型参数必须是自限定的，而循环泛型并无此限制","categories":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/categories/Java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://sinlapis.github.io/tags/笔记/"},{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"}]},{"title":"Java编程思想笔记0x07","slug":"Java编程思想笔记0x07","date":"2019-07-04T11:22:09.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2019/07/04/Java编程思想笔记0x07/","link":"","permalink":"http://sinlapis.github.io/2019/07/04/Java编程思想笔记0x07/","excerpt":"","text":"泛型（二）边界 泛型边界不但可以强制规定泛型可以应用的类型，还允许泛型按照其边界类型调用方法。 通配符 逆变与协变用来描述类型转换后的继承关系，其定义为：如果A、B表示类型，f(⋅)表示类型转换，≤表示继承关系（比如，A≤B表示A是由B派生出来的子类）f(⋅)是逆变（contravariant）的，当A≤B时有f(B)≤f(A)成立；f(⋅)是协变（covariant）的，当A≤B时有f(A)≤f(B)成立；f(⋅)是不变（invariant）的，当A≤B时上述两个式子均不成立，即f(A)与f(B)相互之间没有继承关系。 在Java中，数组是协变的 class Fruit {} class Apple extends Fruit {} class Jonathan extends Apple {} class Orange extends Fruit {} public class Test { public static void main(String[] args) { Fruit[] fruits = new Apple[10]; fruits[0] = new Apple(); fruits[1] = new Jonathan(); try { fruits[0] = new Fruit(); // Runtime Error } catch (Exception e) { System.out.println(e); } try { fruits[1] = new Orange(); // Runtime Error } catch (Exception e) { System.out.println(e); } } } 上述代码可以通过编译，但是在运行时会报错。 由于早期Java不支持泛型，对数组的通用操作都是使用Object[]实现的，因此上述代码可以通过编译。但是为了避免因为声明类型和实际类型不一致而引发的问题，Java把类型检查放在了运行时 然而使用泛型时，由于擦除的存在，所有检查都必须在编译期完成，因此诸如List&lt;Fruit&gt; flist = new ArrayList&lt;Apple&gt;;的代码是无法通过编译的。与数组不同，泛型没有内建的协变类型。 但是这一限制可以使用通配符解除，例如List&lt;? extends Fruit&gt; flist = new ArrayList&lt;Apple&gt;;，这不意味着flist可以持有任意Fruit及其子类的对象，仍然需要指明其持有类型，并向上转型。 此时问题又出现了，向上转型后将无法传入任何类型对象给flist，因为编译器不知道&lt;? extends Fruit&gt;指向哪个类型（此时编译器会将其标记为某种未知类型），例如它可以指向Orange，那么向其中放入Apple、Fruit、Object对象都是非法的。不过此时从flist中取出Apple对象是允许的（前提是容器中有对象）。 class Gen&lt;T> { T t; public Test(T t) { // this.t = t; setT(t); } T getT() { return t; } void setT(T t) { this.t = t; } } class Fruit {} class Apple extends Fruit {} public class Test { public static void main(String[] args) throws Exception { Gen&lt;? extends Number> g = new Gen&lt;>(new Apple()); g.setT(new Apple()); // error } } // Cannot infer type arguments for Test1&lt;> // The method setT(capture#2-of ? extends Number) in the type Test1&lt;capture#2-of ? extends Number> is not applicable for the arguments (Apple) 在上面代码中，在构造方法中却是正确的。个人推测，new Gen&lt;&gt;(new Apple())这部分实际上泛型是Apple，并且也不能是包含通配符的泛型，因此构造方法顺利通过编译，但是变量g的泛型是包含通配符的，即其泛型是不确定的类型，因此后续调用setT()方法出现问题。 逆变 使用超类型通配符可以允许向持有某种类型的容器中写入其子类，即指定泛型&lt;? super ClassName&gt;，甚至可以使用类型参数&lt;? super T&gt;（但不能针对类型参数给出一个超类型边界&lt;T super ClassName&gt;）。 public class SuperType { static void writeTo(List&lt;? super Apple> apples) { apples.add(new Apple()); apples.add(new Jonathan()); } } 下面代码中writeExact()无法将Apple对象放入List&lt;Fruit&gt;中，即使是允许的。而使用了超类型通配符的writeWithWildcard()则以把Apple对象放入List&lt;Fruit&gt;。 class GenericWriting { static &lt;T> void writeExact(List&lt;T> list, T item) { list.add(item); } static List&lt;Apple> apples = new ArrayList&lt;>(); static List&lt;Fruit> fruits = new ArrayList&lt;>(); static void f1() { writeExact(apples, new Apple()); //writeExact(fruits, new Apple()); // Error } static &lt;T> void writeWithWildcard(List&lt;? super T> list, T item) { list.add(item); } static void f2() { writeWithWildcard(apples, new Apple()); writeWithWildcard(fruits, new Apple()); } } 相对应的，读取的代码可以使用子类型通配符，使读取对象时实现向上转型。 class GenericReading { static &lt;T> T readExact(List&lt;T> list) { return list.get(0); } static List&lt;Apple> apples = Arrays.asList(new Apple()); static List&lt;Fruit> fruits = Arrays.asList(new Fruit()); static void f1() { Apple a = readExact(apples); Fruit f = readExact(fruits); f = readExact(apples); } static class Reader&lt;T> { T readExact(List&lt;T> list) { return list.get(0); } } static void f2() { Reader&lt;Fruit> fruitReader = new Reader&lt;>(); //Fruit a = fruitReader.readExact(apples); // Error } static class CovariantReader&lt;T> { T readCovariant(List&lt;? extends T> list) { return list.get(0); } } static void f3() { CovariantReader&lt;Fruit> fruitCovariantReader = new CovariantReader&lt;>(); Fruit f = fruitCovariantReader.readCovariant(fruits); Fruit a = fruitCovariantReader.readCovariant(apples); } } 在上面的代码中，静态方法readExact()由于类型参数由list决定，所以正确返回了Apple对象并向上转型。如果只是读取，可以不使用泛型。而在f2()中，由于创建泛型类时先指定了类型参数为Fruit，因此Reader#readExact()不能接受List&lt;Apple&gt;参数。此时使用子类通配符即可解决问题。 无界通配符 使用无界通配符表示，当前不知道（或者不需要知道）具体类型，但是不影响对其进行操作。例如可以从List&lt;?&gt;中取值出来（但是会丢失类型信息），不可以向其中写入。 捕获转换 如果向一个使用&lt;?&gt;的方法传递原生类型，对于编译器来说，可能会推断出实际的类型参数，使得这个方法可以回转并调用另一个使用这个确切类型的方法，即捕获转换。 public class Main { static &lt;T> T f1(List&lt;T> list) { T t = list.get(0); return t; } static void f2(List&lt;?> list) { f1(list); } public static void main(String[] args) { List list = new ArrayList&lt;>(); list.add(0); f1(list); f2(list); } } 上面代码中，main()方法中调用f1(list)是有警告的，而经过f2()的捕获转换后警告消失了。","categories":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/categories/Java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://sinlapis.github.io/tags/笔记/"},{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"}]},{"title":"Java编程思想笔记0x06","slug":"Java编程思想笔记0x06","date":"2019-07-02T12:33:00.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2019/07/02/Java编程思想笔记0x06/","link":"","permalink":"http://sinlapis.github.io/2019/07/02/Java编程思想笔记0x06/","excerpt":"","text":"泛型（一）简单泛型 让一个类能够持有多种类型的对象，可以使用泛型实现。 class A&lt;T> { T i; A(T ii) { i = ii; } } public class Test { public static void main(String[] args) { A&lt;Integer> a = new A&lt;>(1); int i = a.i; // a.i = \"str test\"; // 错误 A&lt;String> b = new A&lt;>(\"test\"); String s = b.i; } } 示例：元组 元组是指将一组对象直接打包存储于其中的一个单一对象，这个容器对象允许读取其中的元素，但是不允许向其中存放新的对象。 public class TwoTuple&lt;A,B> { public final A first; public final B second; public TwoTuple(A a, B b) { first = a; second = b; } public String toString() { return \"(\" + first + \", \" + second + \")\"; } } 当希望某个方法返回两个及以上的参数是可以使用元组来实现，创建时填入类型即可。 泛型接口 泛型可以应用于接口，例如生成器： public interface Generator&lt;T> { T next(); } 泛型方法 泛型同样可以在类中包含参数化方法，并且与类是否泛型无关。 如果使用泛型方法可以取代整个类泛型化，那么就应该只使用泛型方法 静态方法无法访问类成员中的泛型变量。如果希望静态方法拥有泛型能力，那么就需要让静态方法称为泛型方法。 定义泛型方法，只需将泛型参数列表置于返回值之前： public &lt;T> void f(T x){} 调用泛型方法时，不需要指明参数类型，编译器会自动判断类型，即类型参数推断。 在Java 8以前，泛型方法的结果传递给另外一个方法时编译器不会进行推断，而Java 8 中编译器能够根据调用的方法和相应的声明来确定需要的参数类型。 匿名内部类 泛型可以用于匿名内部类，同样以生成器为例： public interface Generator&lt;T> { T next(); } public static Generator&lt;String> generator() { return new Generator&lt;String> { public String next() { return \"test\"; } } } 擦除 Java的泛型是使用擦除来实现的，这意味着在泛型代码内部，无法获得任何有关泛型参数类型的信息，即实际上，List&lt;Integer&gt;和List&lt;String&gt;在运行时是相同的类型List。 泛型类型参数将擦除到它的第一个边界，实际上编译器会把类型参数替换为它的擦除。 当希望代码能够跨多个类工作时，使用泛型才有所帮助。例如某个类有一个返回T的方法，那么泛型可以帮助该方法返回正确的类型。 补救擦除的缺陷 在需要类型信息而其已经被擦除时，必须显式地传递类型的Class对象。例如，x instanceof T是错误的表达，需要x先用Class&lt;T&gt; ct对象保存类型信息，再比较类型信息ct.isInstnce(x)。 创建泛型类型对象 传递一个工厂对象到构造器中，并使用该工厂创建新对象。 class ClassAsFactory&lt;T> { T x; public ClassAsFactory(Class&lt;T> kind) { try { x = kind.getDeclaredConstructor().newInstance(); } catch(Exception e) { System.out.println(e); } } } class Employee {} public class Test { public static void main(String[] args) { ClassAsFactory&lt;Employee> fe = new ClassAsFactory(Employee.class); } } 上面代码中使用了无参构造器，如果传入的类型没有无参构造器则无法工作。 interface FactoryI&lt;T> { T create(); } class Foo&lt;T> { private T x; public &lt;F extends FactoryI&lt;T>> Foo(F factory) { //public Foo(FactoryI factory) { // Error x = factory.create(); } } class IntegerFactory implements FactoryI&lt;Integer> { public Integer create() { return 0; } } class Widget { public static class Factory implements FactoryI&lt;Widget> { public Widget create() { return new Widget(); } } } public class Test { public static void main(String[] args) { new Foo&lt;Integer>(new IntegerFactory()); new Foo&lt;Widget>(new Widget.Factory()); } } 使用了显式的工厂对象后，可以应用于任何一种类型，并且获得了编译期检查。 abstract class GenericWithCreate&lt;T> { final T element; GenericWithCreate() { element = create(); } abstract T create(); } class X {} class Creator extends GenericWithCreate { X create() { return new X(); } } public class Test { public static void main(String[] args) { Creator c = new Creator(); } } 上面代码使用了模板方法。 泛型数组 一般情况下使用ArrayList。如果确实需要数组，则只能使用强制类型转换(T[])new Object[size]。","categories":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/categories/Java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://sinlapis.github.io/tags/笔记/"},{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"}]},{"title":"Java编程思想笔记0x05","slug":"Java编程思想笔记0x05","date":"2019-07-01T12:19:43.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2019/07/01/Java编程思想笔记0x05/","link":"","permalink":"http://sinlapis.github.io/2019/07/01/Java编程思想笔记0x05/","excerpt":"","text":"类型信息Class对象 Java使用Class对象来执行其RTTI。 类是程序的一部分，每个类都有一个Class对象 类加载过程（见深入理解Java虚拟机笔记0x02） Class对象仅在需要的时候才被加载 Class.forName(String className)可以取得Class对象的引用，参数为一个包含目标类的文本名（区分大小写）。注意此方法会使类加载并初始化，作为对比，使用ClassLoader对象的loadClass()方法只会对类进行加载，而不会初始化。 Object对象有方法getClass()可以获取相应Class对象引用。 Class#getSimpleName()返回不含包名的类名，Class#getCanonicalName()返回全限定的类名。 Class#getSuperclass()返回其基类的Class对象 关于Class#newInstance()：该方法已于Java 9声明废弃，使用Class#getDeclaredConstructor().newInstance()代替。 泛化的Class引用 可以使用泛型将Class引用所指向的Class对象的类型进行限定，使其变得更为具体 。 Class&lt;?&gt;与Class：Class没有表现出是否要限制Class的意思，而Class&lt;?&gt;则表示此处Class的限制是无限制。 向Class引用添加泛型语法的原因仅仅是为了提供编译期类型检查。 转型 Class#cast()可以将参数对象转换为Class引用的类型 类型检查 关键字instanceof：判断对象是否为某种类型，用法：x instanceof ClassName。只可将其与命名类型比较，不能与Class对象比较。 Class#isInstance()判断参数引用是否为Class引用的实例。 使用instanceof或者Class#isInstance()进行的判断是对象是否为目标类或者目标类的子类，而使用==或者equals()则表示对象是否确切的是目标类，而不是目标类的子类或者其他类。 反射 Java中使用Class类和java.lang.reflect共同支持反射。在类库中，Constructor用于创建新的对象，get()和set()方法用于修改与Field对象关联的字段，invoke()方法用于调用与Method对象关联的方法；此外，getFields()、getMethods()、getConstructors()方法可以分别获得表示字段、方法以及构造器对象的数组。 RTTI与反射的区别：对于RTTI来说，编译器在编译时打开和检查.class文件，而对于反射来说，.class文件在编译时是不可获取的。","categories":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/categories/Java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://sinlapis.github.io/tags/笔记/"},{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"}]},{"title":"Java编程思想笔记0x04","slug":"Java编程思想笔记0x04","date":"2019-06-30T07:42:12.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2019/06/30/Java编程思想笔记0x04/","link":"","permalink":"http://sinlapis.github.io/2019/06/30/Java编程思想笔记0x04/","excerpt":"","text":"字符串不可变String String对象是不可变的。String类中每一个看起来会修改String值的方法，实际上都是创建了一个全新的String对象。 对于一个方法而言，参数是为该方法提供信息的，而不是想让该方法改变自己。 重载“+”与StringBuilder 重载：一个操作符在应用于特定的类时，赋予其特定的含义。 在Java中，用于String的+和+=是仅有的两个重载过的操作符，不允许程序员重载任何操作符。 Java编译器会自动优化String操作并使用StringBuilder,因为其高效，但是并不是所有的状况都会被优化。因此在需要大量操作String时使用StringBuilder是明智的选择。 无意识递归 如果在toString()方法中使用this指针与其它字符串拼接，试图打印对象的地址，那么会引起无限的递归调用。[因为编译器试图把this指针转换为String类型，而转换的方法就是调用this.toString()。正确的做法是调用父类的toString()，即super.toString()。 格式化输出System.out.format() 类似于C语言中的printf()，接受一个简单的格式化字符串以及一串参数。 Formatter类 创建Formatter对象时需要向构造器中传入输出目标，例如System.out。使用时调用Formatter对象的format()方法。 格式化说明符 抽象语法：%[argument_index$][flags][width][.precision]conversion width：控制一个域的最小尺寸，在有必要时添加空格，来确保一个域至少达到某个长度。可以用于各种类型的数据转换。默认情况下数据是右对齐，可以使用-来改变对齐方向。 precision：指明数据的最大尺寸。不能用于所有的数据类型转换，例如整数类型，并且应用于不同的数据类型转换时意义也不同。应用于String时表示打印String时输出的字符的最大数量；应用于浮点数时，表示小数部分要显示的位数（默认是6位），多则舍入，少则补0。 Formatter转换 常用的类型转换： 类型转换字符 含义 d 整数型（十进制） c Unicode字符 b Boolean值 s String f 浮点数（十进制） e 浮点数（科学计数） x 整数（十六进制） h 散列码（十六进制） % 字符”%” 关于b转换，对于boolean基本类型和Boolean对象，其转换结果就是true或false；对于其它类型的参数，只要其不为null，那么转换结果就是true，即使是数字0，转换结果依然是true。 正则表达式基本构造 字符 含义 B 指定字符B \\xhh 十六进制值为0xhh的字符 \\uhhhh 十六进制表示为0xhhhh的Unicode字符 \\t 制表符Tab \\n 换行符 \\r 回车 \\f 换页 \\e 转义（Escape） 字符类 含义 . 任意字符 [abc] 包含a、b、c的任何字符，同 a&#124;b&#124;c [^abc] 除了a、b、c的任何字符（否定） [a-zA-Z] 从a到z或从A到Z的任何字符 \\s 空白符（空格、Tab、换行、换页和回车） \\S 非空白符 \\d 数字，同[0-9] \\D 非数字，[^0-9] \\w 词字符，[a-zA-Z0-9] \\W 非词字符，[^\\w] 逻辑操作符 含义 XY Y跟在X后面 X&#124;Y X或Y (X) 捕获组，可以在表达式中使用\\i来引用第i个捕获 边界匹配符 含义 ^ 一行的开始 $ 一行的结束 \\b 词的边界 \\B 非词的边界 \\G 前一个匹配的结束 量词 量词描述了一个模式吸收输入文本的方式 贪婪型：一次性地读入整个字符串，如果无法完成匹配就去掉最右边的一个字符再匹配，直到找到匹配的字符串或字符串的长度为0为止。它的宗旨是读尽可能多的字符，所以当读到第一个匹配时就立刻返回。 厌恶型：立刻进入匹配，如果无法匹配则多读一个字符串，直到匹配成功或者字符串读完。它尽量减少了匹配到的字符串，但同样读到第一个匹配的就返回。 占有型：仅匹配一次，失败不会再次尝试。 Pattern和Matcher 正则表达式对象：位于java.util.regex包中，使用Pattern.compile()编译正则表达式，并返回一个Pattern对象。使用Pattern对象的matcher()方法检索一个字符串，会得到一个Matcher对象。 Pattern对象的split()方法可以从匹配了正则表达式的地方分割输入的字符串，返回分割后的子字符串String数组。 Matcher对象的find()方法可用来在CharSequence中查找多个匹配 组：是用括号划分的正则表达式，可以根据组的编号来引用某个组。组号为0便是整个正则表达式，组号1表示第一对括号括起来的组。 Matcher对象中有许多关于组的方法： 方法名 用途 int groupCount() 返回Matcher对象中组数，不包含第0组 String group() 返回前一次匹配的第0组 String group(int i) 返回前一次匹配的指定组号，如果匹配成功但是指定的组没有匹配输入字符串的任何部分则返回null int start(int group) 返回前一次匹配操作中寻找到的组的起始索引 int end(int group) 返回前一次匹配操作中寻找到的组的最后一个字符索引加1的值 替换 方法名 用途 String replaceFirst(String replacement) 用replacement替换掉第一个匹配成功的部分 String replaceAll(String replacement) 用replacement替换所有匹配成功的部分 Matcher appendReplacement(StringBuffer sb, String replacement) 1. 先将不匹配的地方放入sb中，即从上次读取的位置开始，到本次start() - 1；2. 将replacement放入sb中；3. 将读取位置改为end() StringBuffer appendTail(StringBuffer sb) 在多次使用appendReplacement()方法后，使用此方法将把剩余部分的字符串直接放入sb中 reset() reset()可以将现有的Matcher对象应用于一个新的字符序列。 扫描输入Scanner定界符 默认情况下，Scanner对象使用空白字符对输入进行分词。使用Scanner对象的useDelimiter()并输入正则表达式作为参数可以修改成自定义的定界符。 用正则表达式扫描 Scanner对象的hasNext()和next()方法都支持输入一个Pattern对象，找到下一个匹配该模式的部分，调用match()就能获得匹配结果。如果正则表达式中有定界符，将永远不会匹配成功。","categories":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/categories/Java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://sinlapis.github.io/tags/笔记/"},{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"}]},{"title":"Java编程思想笔记0x03","slug":"Java编程思想笔记0x03","date":"2019-06-28T12:48:30.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2019/06/28/Java编程思想笔记0x03/","link":"","permalink":"http://sinlapis.github.io/2019/06/28/Java编程思想笔记0x03/","excerpt":"","text":"通过异常处理错误基本异常 异常是指组织当前方法或作用于继续执行的问题 与普通问题对比：普通问题在当前环境中能得到足够的信息，总能处理错误，而对于异常则在当前环境中无法获得足够信息来解决问题。 抛出异常：从当前环境跳出，并且把问题交给上一级环境 异常参数：异常类有两个构造器，一个是默认构造器，另一个接受一个字符串参数，能够输入自定义的错误信息 捕获异常try块 如果不希望在方法内遇到异常就结束，可以使用try包裹可能出现异常的代码来捕获异常 相较于不支持处理异常的语言，try可以不需要在每一次调用方法的前后设置错误检查的代码，从而使代码更容易编写和阅读 异常处理程序 用于处理try捕获的异常，关键字为catch，参数为错误类型以及标识符。 终止与恢复 终止模型：假设错误非常关键，以至于程序无法返回到异常发生的地方继续执行 恢复模型：异常处理程序的工作是修正错误，然后重新尝试调用出问题的方法，并任务第二次能成功 尽管恢复模型显得很吸引人，但是并不实用。其中的主要原因可能是它所导致的耦合：恢复性的处理程序需要了解异常抛出的地点，这势必要包含依赖于抛出位置的非通用代码。 自定义异常 自定义异常需要从已有的异常类继承，最好是选择意思相近的异常类继承，也可以选择编程相关的所有异常的父类Exception继承。 异常说明 在方法声明中，形式参数列表后使用关键字throw，后面接一个所有潜在异常类型的列表，可以表示该方法可能会抛出相应的异常。调用此方法时，如果没有处理这些异常将无法通过编译。 捕获所有异常 捕获时，使用Exception类可以捕获到所有编程相关的异常。最好将其放在处理程序的末尾，以防它抢在其它异常处理程序之前把异常捕获了。 栈轨迹：异常对象的getStackTrace()可以获得发生错误时调用序列，栈顶是调用序列中最后一个方法调用。 重新抛出异常：在catch块中可以使用throw重新抛出异常，将异常抛给上一级环境中的异常处理程序，后续的catch子句将被忽略。 异常链 异常链是指在捕获一个异常后抛出另一个异常，并且希望保存原始异常的信息。 Throwable的构造器可接受另一个Throwable对象作为原始异常（cause）来追踪异常最初发生的位置。 initCause()方法可以为一个没有设置原始异常的Throwable对象设置原始异常。注意此方法仅能调用一次，并且如果该对象已经通过构造器设置原始异常或者该方法调用超过一次，那么会抛出IllegalStateException。 Java标准异常 运行时异常（RuntimeException），例如空指针异常（NullPointerException）会被Java虚拟机自动抛出，不需要在异常说明中添加这类异常，如果没有被捕获，它们将直达main()方法。 使用finally清理 finally子句中的代码无论try块中是否抛出异常都会得到执行。 当要把除内存之外的资源恢复到它们的初始状态时，可以使用finally子句。例如关闭打开的文件或者网络连接等。 丢失异常：try块中的异常会被finally子句中的异常覆盖；如果在finally子句中返回，即使抛出异常也不会产生输出。","categories":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/categories/Java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://sinlapis.github.io/tags/笔记/"},{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"}]},{"title":"Java编程思想笔记0x02","slug":"Java编程思想笔记0x02","date":"2019-06-28T11:36:43.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2019/06/28/Java编程思想笔记0x02/","link":"","permalink":"http://sinlapis.github.io/2019/06/28/Java编程思想笔记0x02/","excerpt":"","text":"持有对象添加一组元素 Collections.addAll()方法接受一个Collection对象，以及一个数组或者一个逗号分隔符列表，将元素添加到Collection中。推荐使用此方法。 Arrays.asList()方法接受数组或列表，但是其返回的对象类型List并不是java.util.List，而是Arrays内的一个静态内部类，没有add()和remove()方法。 List List在Collection中添加了大量方法，可以在List中间插入和移除元素 类型 ArrayList：长于随机访问元素，但是在List中间插入和移除元素较慢 LinkedList：在中间插入和删除操作代价较低，提供了优化的顺序访问，但是随机访问相对较慢 部分方法 remove()：此方法接受元素类型对象（调用其equals()方法）或者在List中的序号，来删除指定元素。注意如果List中元素为Integer类型时，删除值为x的方式为remove((Integer) x)而不是remove(x)，后者会删掉序号为x的元素。 subList()：获取子列表 containsAll()：是否包含参数序列中所有的值。与参数顺序无关。 retainsALL()：参数为另一个List，求两个List交集，结果保存在调用对象里。 LinkedList 实现了List的基本接口，添加了可以使其用作栈、队列或双端队列的方法。 StackSet类型 HashSet：使用散列函数实现，查找速度较快 TreeSet：基于红黑树实现 LinkedHashSet：同样使用散列函数实现，但同时用链表维护了元素插入顺序 MapQueue offer()：在允许的情况下将一个元素插入队尾，或者返回false。 PriorityQueue：使用offer()插入时会对元素进行排序。默认顺序是元素在队列中的自然顺序，可通过修改Comparator来修改顺序。","categories":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/categories/Java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://sinlapis.github.io/tags/笔记/"},{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"}]},{"title":"Java编程思想笔记0x01","slug":"Java编程思想笔记0x01","date":"2019-06-26T11:20:45.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2019/06/26/Java编程思想笔记0x01/","link":"","permalink":"http://sinlapis.github.io/2019/06/26/Java编程思想笔记0x01/","excerpt":"","text":"内部类链接到外部类 内部类拥有外围对象所有成员的访问权限，以及外围类的访问权限。 获取外部类引用 在内部类中，使用外部类名称以及.this可以获得外部类对象的引用。 内部类访问外部类变量 如果内部类或者外围方法没有与外部类重名的变量，那么可以直接访问外部类的变量，如果有重名变量，则需要通过上述方法访问外部类变量。 创建内部类对象 如果内部类不是静态的，需要通过外部类对象来创建，例如外部类Test的实例test，其包括一个内部类Inner，那么创建方式为test.new Test.Inner() 匿名内部类 是指创建一个继承某个类的匿名类，通过new表达式返回的引用自动向上转型为父类的引用。 可以方便快速继承类重写方法或者实现接口。 内部类的用处 每个内部类都能独立地继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响，有效的实现了多重继承。 内部类用于回调 回调函数：有些库函数需要传给它一个函数，好在合适的时候调用，以完成目标任务。这个被传入的、后又被调用的函数就称为回调函数。 通过内部类实现同名方法的不同实现，后通过回调可以选择向外部提供调用的方法。 内部类与控制框架 应用程序框架：用于解决某类特定问题的一个类或一组类 控制框架：一类特殊的应用程序框架，用来解决响应事件的请求 内部类与覆盖 内部类无法被子类的同名内部类覆盖。","categories":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/categories/Java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://sinlapis.github.io/tags/笔记/"},{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"}]},{"title":"Java编程思想笔记0x00","slug":"Java编程思想笔记0x00","date":"2019-06-25T10:43:55.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2019/06/25/Java编程思想笔记0x00/","link":"","permalink":"http://sinlapis.github.io/2019/06/25/Java编程思想笔记0x00/","excerpt":"","text":"对象面向对象的程序设计方式 万物皆对象 程序是对象的集合，它们通过发送消息来告知彼此要做的。 每个对象都有自己的、由其他对象所构成的存储 每个对象都有其类型 某一特定类型的所有对象都可以接受同样的消息 封装 只向客户端程序员暴露必须的部分，而隐藏其它部分 原因： 让客户端程序员无法触及他们不应该触及的部分，关注对他们来说关键的东西。 允许库设计者可以改变类内部的工作方式而不必担心会影响到客户端程序员。 继承 继承使用基类型和导出类型的概念表示了类型间的相似性。 多态 后期绑定：当向对象发送消息时，被调用代码直到运行时才能确定。编译器确保被调用方法存在，并对调用参数和返回值执行类型检查，但并不知道被执行的确切代码。 向上转型：在程序执行过程中，把导出类看做其基类的过程。 基本类型 基本类型的创建：创建一个并非是引用的“自动”变量，这个变量直接存储值并置于堆栈中。 基本类型占用的存储空间不随机器硬件架构变化而变化 所有的数值类型都有正负号 static 当声明一个事物是static时，就意味着这个域或方法不会与包含它的那个类的任何对象实例关联在一起。即使从未创建过某个类的任何对象，也可以调用其static方法或访问其staic域。 在static内部不能调用非静态方法。 初始化与清理构造器 构造器是一种特殊类型的方法，因为它没有返回值。这与返回值为空是不同的。new表达式返回了对象的引用，但这并不是构造器的返回值。 构造器中对变量的初始化会覆盖该变量在定义时的初始化 如果类中没有构造器，那么编译器会自动创建一个默认的构造器，但是如果已经定义类一个构造器，无论是否有参数，编译器就不再创建默认构造器。 重载 如果传入的数据类型小于方法中声明的形式参数类型，实际数据的类型就会提升。但是char型略有不同，如果无法找到恰好接受char型的方法，就会把char直接提升到int型。 初始化 静态初始化只在必要的时候进行。如果不创建对象，或者不访问静态域，那么就不会进行静态初始化。 初始化的顺序是先静态对象，后其它对象。 可变参数列表 可以使用类似Object... args的参数形式来代替显示的声明数组。 访问权限控制代码组织 一个Java源文件称为编译单元。一个编译单元中只能有一个public类，且该类的名称需与文件名称相同（包括大小写，不包括文件名后缀）。 类库中会有一组类文件，每个文件都由一个public类和任意数量的非public类组成，因此每个文件都由一个构件。如果希望这些构件从属于同一个群组，可以使用关键字package。 访问权限 包访问权限：是默认的访问权限，意味着当前包中的所有其它类对该成员都有访问权限。 默认包：如果没有给Java文件设置任何包名称，则编译器会把处于相同目录下的Java文件看作是属于该目录下的默认包之中。 public：由public修饰的成员对任何类都是可用的。 private：由private修饰的成员，除了包含该成员的类以外，其它任何类都无法访问这个成员。 如果使用privatge修饰构造器，那么将无法通过通常手段进行对象的创建，并且会阻碍对此类的继承。 protected：由protected修饰的成员仅支持当前类、继承类以及相同包的其它类访问（即提供包访问权限） 复用类组合继承 继承中的构建：在继承中，构建过程是从基类流向导出类的，因此基类在导出类构造器可以访问它之前就已经完成了初始化。即使导出类没有显式创建构造器，编译器也会自动创建一个默认的构造器，该构造器将调用基类的构造器。但是如果基类设置了有参构造器，那么在导出类中如果不显示声明调用基类的某个构造器，在创建过程中将会默认调用基类的无参构造器，如果基类没有声明无参构造器则编译不会通过。 代理 将一个成员对象置于要构造的类中，同时在新类中暴露该类所有的成员方法。 final 使用final修饰的基本类型变量值不能改变，如果是引用类型变量则引用值不能改变，但是引用指向的对象自身是可以改变的。此外，使用final修饰的变量必须初始化（可以在声明时初始化或者在构造器中初始化）。 一个既是static又是final的变量只能占据一段不能改变的存储空间，并且必须在声明时初始化。 只有想要明确禁止覆盖方法时，才将方法设为final。 多态 协变返回类型：在导出类中的被覆盖方法可以返回基类方法的返回类型的某种导出类。 接口抽象类 抽象类和抽象方法可以使类的抽象性明确起来，并且可以明确传达类的使用方法。此外，抽象类还是有用的重构工具。 接口 当组合接口时，如果存在两个方法重名、参数列表或返回值不一致，那么会产生冲突。","categories":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/categories/Java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://sinlapis.github.io/tags/笔记/"},{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"}]},{"title":"深入理解Java虚拟机笔记0x03","slug":"深入理解Java虚拟机笔记0x03","date":"2019-06-23T09:17:43.000Z","updated":"2021-03-03T02:50:12.463Z","comments":true,"path":"2019/06/23/深入理解Java虚拟机笔记0x03/","link":"","permalink":"http://sinlapis.github.io/2019/06/23/深入理解Java虚拟机笔记0x03/","excerpt":"","text":"Java线程volatile 当变量声明为volatile时，变量将具备以下两个特性： 保证此变量对所有线程的可见性，即一个线程修改了volatile变量后，其余线程可以立即获得修改后的值。 禁止指令重排序优化，即设置内存屏障，保证volatile变量修改更新到所有CPU上 Java线程实现 基于操作系统的原生线程模型。Windows和Linux下都使用一对一的线程模型。 线程状态及转换 新建：创建后未启动的线程 运行：正在执行或者等待CPU为其分配运行时间 无限期等待：等待被其它线程显式地唤醒，不会被分配CPU时间，例如没有设置Timeout的Object.wait()或者Thread.join() 限期等待：不会被分配CPU时间，但是不需要其它线程显式地唤醒，一定时间后会由系统自动唤醒，例如Thread.sleep()，设置了Timeout的Object.wait()或者Thread.join() 阻塞：等待获取一个排他锁。 结束：已终止的线程状态。 线程安全线程安全程度 不可变：无论是对象的方法实现还是方法的调用者，都不需要再采取任何的线程安全保障措施。例如final关键字修饰的变量 绝对线程安全：调用者不需要任何额外的同步措施。 相对线程安全：保证对对象的单独操作是安全的，调用者不需要做额外的保障措施。但对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性（可以保证调用对象不同的方法时，不同的方法不会交叉执行，但是无法保证一组方法的调用顺序）。例如对Vector对象同时进行remove()和get()操作时可能会出现删除第i个元素后面是访问第i个元素的情况。在Java语言中，大部分的线程安全类都属于这种类型。 线程兼容：对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全使用。 线程对立：无论调用端是否采取同步措施，都无法在多线程环境中并发使用的代码。 线程安全的实现方法互斥同步 保证共享数据在同一时刻只被一个（使用信号量的条件下是一些）线程使用 是一种悲观的同步策略 在Java中使用synchronized关键字进行同步。 非阻塞同步 基于冲突检测的乐观并发策略，即先进行操作，如果没有其它线程竞争，那么操作成功；反之，再采取其它补偿措施（最常见的措施是不断重试，直到成功为止），需要硬件保证操作和冲突检测两个步骤具备原子性。 CAS指令：当且仅当内存值和预期值相等时，使用新值更新内存值，否则不更新。 ABA问题：在某线程获取变量值时是A，在检查之前被改为了B，然后又恢复了A，检查时会认为该变量没有修改过。多数情况下该问题不影响程序的并发，如需解决，改为使用互斥同步可能更有效。 无同步方案 可重入代码：可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），在中断返回后，原来的程序不会出现任何错误。 线程本地存储：把使用共享数据的代码放入同一线程中。 锁优化自旋锁 让请求锁的线程进行短暂的等待，看锁是否很快就被释放。 避免了线程切换开销，但是等待时间过长会浪费CPU资源 自适应自旋锁：是否自旋、自旋时间不再确定，由前一次在同一个对象上的自旋锁时间和拥有者的状态决定。 锁消除 对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。判定依据来源于逃逸分析。 一些线程同步代码是内嵌的Java内部的，可以通过锁消除进行优化。 锁粗化 如果有连续的对同一个对象加锁，则虚拟机会把加锁同步的范围扩大至整个操作序列外部，以减少加锁解锁带来的性能损耗。 轻量级锁 使用CAS操作和对象的Mark Word实现的锁机制。 前提是绝大部分的锁在同步周期内是不存在竞争的，因此CAS操作避免了使用互斥量的开销。但是如果存在锁竞争，轻量级锁比传统的互斥同步还多出CAS操作的消耗。 偏向锁 该种锁偏向于第一个获得它的线程，在接下来的执行过程中，如果该锁没有被其它线程获取，则持有偏向锁的线程将永远不会进行同步。一旦有其它线程获取该锁，偏向模式即结束，转变为传统的互斥同步。","categories":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/categories/Java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://sinlapis.github.io/tags/笔记/"},{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"}]},{"title":"深入理解Java虚拟机笔记0x02","slug":"深入理解Java虚拟机笔记0x02","date":"2019-06-23T01:31:06.000Z","updated":"2021-03-03T02:50:12.463Z","comments":true,"path":"2019/06/23/深入理解Java虚拟机笔记0x02/","link":"","permalink":"http://sinlapis.github.io/2019/06/23/深入理解Java虚拟机笔记0x02/","excerpt":"","text":"虚拟机类加载机制类加载时机类的生命周期 包括：加载、验证、准备、解析、初始化、使用、卸载。其中，验证、准备、解析统称为链接。 类初始化条件（当且仅当） 遇到new、getstatic、putstatic、invokestatic字节码指令时，如果类没有初始化则触发其初始化。使用场景： 使用new实例化对象 读取或设置一个类的静态字段（不含被final修饰、已在编译期把结果放入常量池的静态字段） 调用一个类的静态方法 对类进行反射调用的时候，如果类没有初始化则触发其初始化。 初始化一个类的时候，如果发现其父类没有初始化，则触发其父类的初始化。 虚拟机启动时会先初始化用户指定的主类（包含main()方法）。 使用动态语言支持时*。 类加载过程加载主要步骤 通过一个类的全限定名来获取定义此类的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区中这个类的各种数据的访问入口。 加载方式 对于非数组类的加载，可以使用系统提供的引导类加载器来完成，也可以由用户自定义的类加载器完成（重写loadClass()） 对于数组类的加载，主要遵循以下规则： 如果数组的组件类型（去掉一个维度）是引用类型，那就递归进行组件类型的加载，数组类将在加载该组件类型的类加载器的类名称空间上被标识。 如果数组的组件类型不是引用类型，虚拟机将会把数组类标记为与引导类加载器关联。 数组类的可见性与它的组件类型一致，如果组件类型不是引用类型，那数组的可见性将默认为public。 验证 主要为了确保Class文件的字节流中包含的信息符合当前虚拟机要求，并且不会危害虚拟机自身的安全。大致包括4个方面：文件格式验证、元数据验证、字节码验证、符号引用验证。 文件格式验证 文件是否以魔数开头 主、次版本号是否在当前虚拟机的处理范围内 常量池中的常量是否有不支持的常量类型 … 元数据验证 是否有父类（除java.lang.Object以外，所有类都应当有父类） 父类是否继承类不允许被继承的类（被final修饰的类） 非抽象类是否实现了其父类以及接口中所有要求实现的方法 类中的字段、方法是否与父类产生矛盾（覆盖了父类中的final字段，重载方法参数一致但返回类型不同等不合规则的重载） … 字节码验证 确保操作数栈的数据类型与指令代码操作匹配 确保跳转指令不会跳转到方法体以外的字节码指令上 确保方法体的类型转换是有效的（父类转换为子类、或者不相干的两种类型的数据互相转换是危险的） … 符号引用验证 符号引用中通过字符串描述的全限定名是否能找到对应的类 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段 符号引用中的类、字段、方法的访问性（private、protected、public，default）是否可被当前类访问 … 准备 为类变量分配内存并设置初始值，这些变量所使用的内存将在方法区中分配。 分配内存的变量仅包括被static修饰的变量，不包括实例变量。 初始值为数据类型的零值，而如果变量的字段属表中存在ConstantValue属性（被final修饰）则初始值为定义的值。 解析 将常量池内的符号引用替换为直接引用的过程 符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位带目标即可。 直接引用：可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。 初始化 根据用户的程序制定的计划来初始化类变量和其他资源 类加载器 类加载器是在虚拟机外实现的、通过类的全限定名来获取描述此类的二进制字节流的模块，可以让应用程序自行决定如何去获取所需要的类。 对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。即使两个类来源于同一个Class文件、同时处于同一个虚拟机中，它们的类加载器不同，那么它们就不属于同一个类。 类加载器分类对虚拟机而言 启动类加载器，是虚拟机的一部分 其他类加载器，独立于虚拟机外部 对开发人员而言 启动类加载器，加载&lt;JAVA_HOME&gt;/lib目录下，或者是虚拟机配置中指定路径的，并且被虚拟机识别的（按文件名识别）的类库。 扩展类加载器，加载&lt;JAVA_HOME&gt;/lib/ext目录下，或被java.ext.dirs系统变量指定路径下的所有类库。 应用程序类加载器，加载用户类路径下所指定的类库，如果应用程序没有指定自己的类加载器，将默认使用该类加载器。 自定义类加载器。 双亲委派模型 如上图所示，这种类加载器的层次关系即类加载器的双亲委派模型。 工作过程：如果一个类加载器收到了类加载请求，它不会先去尝试加载该类，而是把该请求委派给父类加载器去加载，每一层都是如此，即所有类加载请求都会到顶层的启动类加载器中。只有当父加载器反馈在其搜索范围内没有搜索到所需的类，无法完成加载请求时，子加载器才会尝试自己去加载。 优点：使用双亲委派模型后，Java类随着它的类加载器一起具备了一种带有优先级的层级关系。例如类java.lang.Object，无论是哪一个类加载器需要加载这个类，最终都是交给启动类加载器来加载，保证了Object类在不同的类加载器环境中都是同一个类。 程序编译与代码优化泛型 真实泛型：存在于任意阶段的代码，在系统运行期间生成，有自己的虚方法和类型数据。这种现象称为类型膨胀，基于这种方法实现的泛型称为真实泛型，例如C#。 伪泛型：泛型仅存在于源码，编译后仅剩原生类型（又称裸类型），并加入强制类型转换。这种方法称为类型擦除，基于这种方法实现的泛型称为伪泛型。Java泛型是伪泛型。 即时编译 在程序运行过程中，“热点代码”会被即时编译为机器码以提高运行速度，包括被多次调用的方法和被多次调用的循环体。 热点探测：用于判断一段代码是否为热点代码，是否需要触发即时编译，主要有两种技术： 基于采样的热点探测：周期性检查各个线程的栈顶，如果发现某个或者某些方法经常在栈顶出现，则认为这个或这些方法为热点方法。优点是实现简单，高效，容易获得方法调用关系（展开调用堆栈），缺点是难以精确的判定方法的热度，易受线程阻塞等因素影响。 基于计数器的热点探测：设置计数器，统计方法调用次数；设置阈值，如果调用次数超过该阈值则认为其是热点方法。","categories":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/categories/Java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://sinlapis.github.io/tags/笔记/"},{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"}]},{"title":"深入理解Java虚拟机笔记0x01","slug":"深入理解Java虚拟机笔记0x01","date":"2019-06-20T11:22:02.000Z","updated":"2021-03-03T02:50:12.463Z","comments":true,"path":"2019/06/20/深入理解Java虚拟机笔记0x01/","link":"","permalink":"http://sinlapis.github.io/2019/06/20/深入理解Java虚拟机笔记0x01/","excerpt":"","text":"类文件结构魔数 0xCAFEBABE，用于表示文件类型，4字节。 Class文件版本 4字节，高版本能够兼容低版本，但是不能运行更新版本的Class文件。 常量池 入口有表示常量池容量计数值。 主要包含字面量和符号引用。 字面量：接近Java语言层面的常量概念，例如文本字符串，声明为final的常量值等。 符号引用：包括类和接口的全限定名（含包名以及类名）、字段的名称和描述符、方法的名称和描述符。 访问标志 用于标识该Class是类还是接口、是否为public、是否为abstract、是类的话是否为final等。 类索引、父类索引与接口索引集合 用于确定类的继承关系。 字段表集合 用于描述接口或者类中声明的变量，包括类级变量以及实例级变量，但是不包括方法内部声明的局部变量。 字段描述信息包括：字段作用域（public、private、protected）、可变性（final）、并发可见性（volatile，是否强制从主内存读写）、可否被序列化（transient）、字段数据类型（基本类型、对象、数组）。 方法表集合 类似字段表，同样包含类访问标志、名称索引、描述符索引、属性表集合等。 方法中的代码在属性表集合中。 属性表集合Code属性 Class文件中最重要的一个属性，主要包括方法编译后的字节码。 异常表也在Code属性中，表示确定的代码范围（开始行数到结束行数）如果出现了某些异常要跳转到到位置。 字节码支持的数据类型 byte、short、int、long、float、double、char、reference 指令类型 加载和存储指令：常量读进操作栈、局部变量表读进操作栈、操作栈写入局部变量表 运算指令：加法、减法、乘法、除法、求余、取反、位移、按位与、按位或、按位异或、自增、比较 类型转换指令 对象创建与访问指令：创建类实例、创建数组、访问类与实例、加载数组元素、写回数组元素、取数组长度 操作数栈管理指令：出栈、复制栈顶元素并入栈、交换栈顶两个元素 控制转移指令：条件分支、复合条件分支、无条件分支 方法调用和返回指令 异常处理指令 同步指令","categories":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/categories/Java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://sinlapis.github.io/tags/笔记/"},{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"}]},{"title":"深入理解Java虚拟机笔记0x00","slug":"深入理解Java虚拟机笔记0x00","date":"2019-06-19T13:03:33.000Z","updated":"2021-03-03T02:50:12.463Z","comments":true,"path":"2019/06/19/深入理解Java虚拟机笔记0x00/","link":"","permalink":"http://sinlapis.github.io/2019/06/19/深入理解Java虚拟机笔记0x00/","excerpt":"","text":"JVM内存模型 程序计数器：线程私有，用于表示当前执行的字节码地址。 虚拟机栈：线程私有，方法执行时创建一个栈帧，存储局部变量表、操作数栈、动态链接、方法出口等，服务于字节码。 本地方法栈：同虚拟机栈，但为本地方法服务。 本地方法：由Java调用非Java代码接口。 堆：存放对象实例。 方法区：已加载类的信息、常量、静态变量、即时编译后的代码。其中包括运行常量池。 对象创建对象步骤 检查类的符号引用，若没有则进行类加载过程。 分配内存。 内存空间初始化（不含对象头）。 配置对象头。 执行构造函数。 对象的内存分配包括对象头，实例数据，对齐填充 对象头 存储自身运行时数据，例如HashCode、GC分代年龄、锁状态等。 类型指针。 如果为数组，则还要有用于记录数组长度等块。 对象等访问定位通过栈 -&gt; reference -&gt; 堆来操作对象，可以通过句柄或者直接指针访问。 Java GC存活对象判断引用计数算法 为对象添加引用计数器，每次产生引用加1，引用失效减1。 缺点：难以解决对象之间循环引用的问题。 可达性分析算法 从GC Root节点沿引用链向下搜索，当从GC Root到某对象不可达时则该对象应该被回收。 垃圾收集算法 标记 - 清除算法：先通过可达性分析标记需要回收的对象，完成后统一回收所用被标记的对象。 复制算法：将内存划分为两块，每次只用其中一块。用尽时，将存活的对象复制到另外一块上，然后将该块内存全部清理。主要用于新生代的内存回收。缺点是会浪费部分内存。 标记 - 整理算法：标记步骤同标记 - 清除算法，整理则是将存活对象向内存的一端移动，然后清掉边界外的内存。 分代收集：根据对象存活周期的不同，将村村划分为几块。一般是把Java堆分成新生代和老年代。 垃圾收集器Serial收集器 单线程，STW 100ms以内。作用于新生代时采用复制算法，作用于老年代时使用标记 - 整理算法。 ParNew收集器 Serial收集器的多线程版 Parallel Scavenge收集器 同ParNew收集器，回收新生代，目标为达到可控制的吞吐量。 CMS收集器 采用标记 - 清除算法。 步骤： 初始标记，STW 并发标记，与其他线程同步运行 重新标记，STW 并发清除 缺点： 并发阶段会占用CPU资源而导致吞吐量下降 无法处理浮动垃圾（并发清除时产生的垃圾） 标记 - 清除带来的内存碎片问题 G1收集器 采用标记 - 整理算法。 优势： 利用多CPU、多核，缩短STW 分代收集 使用复制算法减少碎片产生 可预测停顿 G1收集器将堆划分成大小相同堆多个Region，新生代和老年代不再物理隔离。跟踪Region中垃圾价值大小，维护优先列表，优先回收价值最大的Region。 步骤： 初始标记，STW 并发标记 最终标记，STW 筛选回收，STW 内存分配与回收策略 对象优先在Eden分配，若Eden区没有足够空间则出发minor GC 大对象直接进入老年代 长期存活对象进入老年代 动态的对象年龄判定：如果Survivor区相同年龄所有对象大小的总和大于Survivor区的一半，则年龄大于或等于该年龄的对象就可以直接进入老年代 空间分配担保 老年代最大可用连续空间是否大于新生代所有对象空间，是则进行minor GC安全。 老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，则minor GC有风险，可能会再次出发full GC，反之若小于，或者设置不允许冒险，则直接进行full GC。","categories":[{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/categories/Java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://sinlapis.github.io/tags/笔记/"},{"name":"Java","slug":"Java","permalink":"http://sinlapis.github.io/tags/Java/"}]},{"title":"记录：在CentOS下安装VirtualBox","slug":"记录：在CentOS下安装VirtualBox","date":"2017-12-25T05:10:54.000Z","updated":"2021-03-03T02:50:12.463Z","comments":true,"path":"2017/12/25/记录：在CentOS下安装VirtualBox/","link":"","permalink":"http://sinlapis.github.io/2017/12/25/记录：在CentOS下安装VirtualBox/","excerpt":"","text":"安装kernel-devel，注意和系统内核版本对应。查看系统内核版本： uname -r 安装其他依赖： yum install -y SDL gcc make perl 到官网上下载CentOS对应的rpm安装包，下载并安装即可。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://sinlapis.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://sinlapis.github.io/tags/Linux/"}]},{"title":"记录：MySQL在Windows/CentOS下的安装","slug":"记录：mysql在windows-centos下的安装","date":"2017-12-25T03:07:36.000Z","updated":"2021-03-03T02:50:12.463Z","comments":true,"path":"2017/12/25/记录：mysql在windows-centos下的安装/","link":"","permalink":"http://sinlapis.github.io/2017/12/25/记录：mysql在windows-centos下的安装/","excerpt":"","text":"Windows 7下安装MySQL www.microsoft.com下载并安装.NET Framework 4.0 www.microsoft.com下载并安装.NET Framework 4.5 www.microsoft.com下载并安装VC++ 2013运行库。注意，需要安装32位，64位可选。 www.microsoft.com下载并安装VC++ 2015运行库。 dev.mysql.com下载并安装对应Windows的MySQL Installer","categories":[{"name":"Database","slug":"Database","permalink":"http://sinlapis.github.io/categories/Database/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://sinlapis.github.io/tags/MySQL/"},{"name":"CentOS","slug":"CentOS","permalink":"http://sinlapis.github.io/tags/CentOS/"},{"name":"Database","slug":"Database","permalink":"http://sinlapis.github.io/tags/Database/"},{"name":"Windows","slug":"Windows","permalink":"http://sinlapis.github.io/tags/Windows/"}]},{"title":"记录：给centos/rhel服务器安装GNOME以及VNC，实现界面远程控制服务器","slug":"记录：给centos-rhel服务器安装GNOME以及VNC，实现图形远程控制服务器","date":"2017-12-24T07:27:30.000Z","updated":"2021-03-03T02:50:12.463Z","comments":true,"path":"2017/12/24/记录：给centos-rhel服务器安装GNOME以及VNC，实现图形远程控制服务器/","link":"","permalink":"http://sinlapis.github.io/2017/12/24/记录：给centos-rhel服务器安装GNOME以及VNC，实现图形远程控制服务器/","excerpt":"","text":"服务器部分（CentOS 7） 安装GNOME： yum groupinstall -y \"GNOME Desktop\" 安装VNC yum install vnc-server vnc* 修改/etc/sysconfig/vncservers： VNCSERVERS=\"1:root\" VNCSERVERARGS[1]=\"-geometry 1024x768 -alwaysshared -depth 24\" 添加/修改/root/.vnc/xstartup #!/bin/sh unset SESSION_MANAGER [ -x /etc/vnc/xstartup ] && exec /etc/vnc/xstartup [ -r $HOME/.Xresources ] && xrdb $HOME/.Xresources xsetroot -solid grey vncconfig -iconic & gnome-session & 终端输入vncpasswd并根据提示设置密码。 终端输入vncserver以启动vncserver。 防火墙开启端口5901、6001： iptables -A INPUT -p tcp --dport 3836 -j ACCEPT iptables -A INPUT -p tcp --sport 3836 -j ACCEPT iptables -A INPUT -p tcp --dport 9996 -j ACCEPT iptables -A INPUT -p tcp --sport 9996 -j ACCEPT iptables-save 客户端部分（Windows） 下载VNC-Viewer并安装。 建立连接，输入&lt;ip&gt;:1，其中&lt;ip&gt;为装有VNC的服务器地址，按回车后输入密码即可。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://sinlapis.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://sinlapis.github.io/tags/Linux/"}]},{"title":"记录：rhel中yum换centos源","slug":"记录：rhel中yum换centos源","date":"2017-12-24T06:25:07.000Z","updated":"2021-03-03T02:50:12.463Z","comments":true,"path":"2017/12/24/记录：rhel中yum换centos源/","link":"","permalink":"http://sinlapis.github.io/2017/12/24/记录：rhel中yum换centos源/","excerpt":"","text":"删除原来的yum rpm -qa | grep yum | xargs rpm -e --nodeps 使用curl或wget从http://mirrors.163.com/centos/7/os/x86_64/下载yum及其依赖安装包，包括yum、yum-metadata-parser、yum-plugin-fastestmirror、python-urlgrabber并安装。如果出现冲突则使用rpm -i --force --nodeps强制安装。有可能需要升级rpm，同样下载安装包并强制安装。 从http://mirrors.163.com的centos帮助文档中获取对应的repo文件，放入/etc/yum.d.repo/,然后执行： yum clean all yum makecache","categories":[{"name":"Linux","slug":"Linux","permalink":"http://sinlapis.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://sinlapis.github.io/tags/Linux/"}]},{"title":"MongoDB笔记0x05","slug":"MongoDB笔记0x05","date":"2017-10-28T01:44:45.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2017/10/28/MongoDB笔记0x05/","link":"","permalink":"http://sinlapis.github.io/2017/10/28/MongoDB笔记0x05/","excerpt":"","text":"4.4 $where查询$where可以进行任何的查询。比较常用的是比较文档中两个键的值是否相等。但是如果非必要，务必不要使用$where进行查询。因为$where查询要比常规查询慢很多，$where查询会把每个文档从BSON转换为JavaScript对象，然后再进行查询，而且$where不能使用索引。如果必须使用$where，也尽量先用常规查询进行过滤再使用$where来查询。 4.5 游标游标可以保存一次查询的结果并提供逐条查看结果。例如： var cursor = db.foo.find() 此时游标仅是保存了查询的构造，而并没有向服务器发起查询。在执行： cursor.hasNext() 后，查询请求才会到达服务器，返回查询结果。接下来的cursor.next()以及cursor.hasNext()均是在本地执行的。 针对返回结果的限制的方法有limit、skip、sort。limit可以限制返回结果数量，即最多返回指定数量的文档；skip可以略过指定数量的文档，如果结果收少于指定数量则不返回结果；sort可以按照指定的键值大小进行文档的排序，例如： db.c.find().sort({ username: 1, age: -1 }) 这表示针对username进行升序排列，针对age斤西瓜降序排列。这三种方法可以组合使用，链式写法即可。 此外，sort如果对类型不一致的键值进行排序时是有指定类型循序的：（1）最小值；（2）null；（3）数字（整型、长整型、双精度）；（4）字符串；（5）对象/文档；（6）数组；（7）二进制数据（8）对象ID；（9）布尔型；（10）日期型；（11）时间戳；（12）正则表达式；（13）最大值。 如果需要排序的结果集的大小超过32M，MongoDB就会报错，拒绝对过多的数据进行排序。 使用skip跳过大量的文档会变得很慢，因为这些需要略过的文档也需要被找出，然后再抛弃这些文档。 高级查询选项：如find({&quot;foo&quot;: &quot;bar&quot;}).sort({&quot;x&quot;: 1})在shell或者其它驱动程序中并不是直接发出{&quot;foo&quot;: &quot;bar&quot;}这样的查询请求，而是将它们封装进更大的查询文档中，像这样： { \"$query\": {\"foo\": \"bar\"}, \"$orderby\": {\"x\": 1} } 此外还有一些其他的辅助查询操作，例如$maxscan（指定本次查询中扫描文档的上限）、$min（文档必须与索引的键完全匹配，并指定索引扫描的下边界）、$max（文档必须与索引的键完全匹配，并指定索引扫描的下边界）等。 像前文所说，MongoDB中文档是顺序存储的，如果对某个文档进行修改而使其体积变大，MongoDB会将其移动到所有文档后面存储。由于游标同样是向后查询文档，如果在前面修改了某个文档导致其变大被移动到了后面，游标向后移动时会再次查询到该文档。解决这个问题需要对查询结果进行快照，这样查询就在_id索引上遍历执行，保证每个文档只返回一次。使用快照会使查询变慢，所以应该只在必要的时候使用快照。 游标的生命周期：在服务端，游标占用内存等资源。当游标遍历了所有结果或者客户端发来信息要求终止，数据库会释放游标占用的资源。当然，还有一些其他情况会使得游标被删除，例如如果客户端的游标已经不在作用域内时，客户端会发出一个特殊的消息要求服务端销毁游标，或者10分钟内某个游标没有使用的话也会删除。 4.6 数据库命令数据库命令，例如drop，其实是一种特殊的查询，只不过服务端收到这类“查询”会进行特殊的逻辑处理。 5 索引5.1 索引简介索引可以根据给定字段组织数据，让MongoDB能够根据这些字段快速找到指定的文档。例如，为username创建索引： db.users.ensureIndex({\"username\": 1}); 建立索引所耗时间根据机器性能以及文档整体大小的不同而不同。虽然建立索引之后查询几乎会瞬间完成，但是其他操作，包括插入、更新、删除等将会消耗更多时间，因为这些操作会修改集合的结构，从而导致需要修改建立的索引。因此，MongoDB也限制每个集合上最多有64个索引，一般来说，一个特定的集合上不应该有两个以上的索引。挑选合适的字段建立索引非常重要。如果某个字段是常用的查询字段，那么在这个字段上建立索引是一个好选择，反之则没有必要建立索引。 索引的值是按照一定的顺序排列的，因此索引键对文档进行排序非常快。但是如果查询时没有首先使用索引键进行排序时，索引并不会发挥作用。不过可以针对多个字段建立复合索引。建立复合索引时优先考虑需要排序的键，将其放在首位索引键。 索引的排序方式并不重要，因为MongoDB可以在索引的任意方向进行便遍历。 有一些查询操作完全无法使用索引，例如$where、$exists、$nin查询只能进行全表扫描，而$ne、$not多数情况下也会进行全表扫描。 $or查询实际上是两次查询，最后合并结果，这样的效率必然不如一次查询的效率高，因此尽可能使用$in代替。此外，MongoDB一次查询只能使用一个索引/复合索引，但是由于$or是两次独立的查询，所以它可以使用多个索引。 MongoDB可以针对嵌套文档的键建立索引，和建立普通的索引类似。例如文档： { \"username\": \"sid\", \"loc\": { \"ip\": \"1.2.3.4\", \"city\": \"Springfield\", \"state\": \"NY\" } } 给loc.city建立索引： db.users.ensureIndex({\"loc.city\": 1}); 即可。但是注意和子文档loc的索引进行区分。如果建立的索引是子文档的索引，那么只有如下的查询才会使用子文档索引： db.users.find({ \"loc\": { \"ip\": \"123.234.111.222\", \"city\": \"Shelbycille\", \"state\": \"NY\" } }); 即必须与子文档字段顺序完全匹配的子文档查询才能使用子文档索引，而： db.users.find({\"loc.city\": \"Shelbycille\"}); 才会使用子文档的键的索引。 同样可以给数组元素建立索引，但是不能给数组本身建立索引。给数组元素建立索引即给数组的每一个元素建立索引，因此数组索引的代价要高于单值索引的代价。并且，一个索引中的数组字段最多只允许有一个，以防止多个数组建立索引之后索引条目爆炸式增长。 多键索引：在索引中，如果某个键是数组，那么这个索引会被标记为多键索引。多键索引会比非多键慢一些，因为可能会有多个索引条目指向同一个文档，因此MongoDB在返回结果集时需要先去重。 索引基数：就是指某个字段对应不同值的数量。例如性别可能只有两种取值，这种字段的基数就比较低；像用户名、住址这类字段可能每个值和其他的都不一样，这类字段的基数就很高；也有介于两者之间的，例如年龄。通常情况下，一个字段的基数越高，那么对这个字段建立的索引越有价值，因为这个索引可以快速将查询范围缩小到一个比较小的结果集，以供下一步操作快速完成。因此建立索引应该选择基数高的字段，或者在复合索引中将基数高的字段提前。 5.2 使用explain()和hint()explain()能够提供大量与查询相关的信息，其中返回的一些字段有助于发现查询速度慢的原因。以下列举一些字段： （1）cursor：表示游标的类型。可以看出本次查询是否使用了索引以及使用的什么索引。 （2）isMultiKey：是否使用了多键索引。 （3）n：本次查询返回的文档数量。 （4）nscannedObjects：MongoDB按照索引指针去磁盘上查找文档的次数。如果查询包含的查询条件不是索引的一部分，或者要求返回的内容不在索引字段内，MongoDB就会从磁盘中读取原文档。 （5）nscanned：如果使用了索引，这个字段表示查找过的索引条目，如果没有使用索引，那么这个字段表示查找的文档数量。 （6）scanAndOrder：MongoDB是否对内存中的结果进行了排序。 （7）indexOnly：MongoDB是否只是用了索引就完成了此次查询，即包括查找字段以及返回的结果集都包含在索引中，又称覆盖索引。 （8）nYields：查询暂停次数，如果有写入请求，查询会周期性释放锁，以供写入执行。 （9）millis：查询所耗毫秒数。 （10）indexBounds：这个字段描述了索引的使用情况，给出了索引的遍历范围。 hint()可以指定查询使用的索引。 查询优化器：与关系型数据库不同，当有多个索引可能适合本次查询时，MongoDB的查询优化器会并行执行这些查询，最早返回100个结果的索引就是“胜者”，并且这个索引会被缓存，在接下来的这个查询都会使用这个索引。如果建立了新的索引或者每执行1000次查询后，查询优化器就会重新评估查询计划。explain()返回的allPlans字段表示了本次查询尝试的每个查询计划。 5.3 何时不应该使用索引如果数据集较小时，索引会十分高效。但是当结果集在原集合中所占比例越大，索引查找的速度就越慢。因为使用索引需要进行两次查找，最坏情况下索引查找的时间是全表查找的两倍。一般来说，当查询需返回30%的文档或更多时，就需要对比索引查找和全表查找的速度。 5.4 索引类型唯一索引：唯一索引可以确保集合的每一个文档的指定键都有唯一值。例如： db.users.ensureIndex({\"username\": 1}, {\"unique\": true}); 这样可以防止有重复键的插入。但是如果有第一个没有该键的文档插入时，该键将被创建，值会置为null，如果继续插入缺少该键的文档就会报错。 进行索引的所有字段都应当小于1024字节，否则这个条目将不会出现在索引中。如果唯一索引的字段超过8KB，唯一索引将会失效。 可以创建复合的唯一索引，复合唯一索引中，单个键的值可以重复，但是所有键的值的组合必须在集合中是唯一的。 稀疏索引：区别与关系型数据库中的稀疏索引，这里的稀疏索引是指如果文档包含指定字段，则为这些文档建立索引。如果和唯一索引一起使用，则这些字段的值必须唯一。 5.5 索引管理索引的元信息保存在system.indexes中，可以通过db.collectionName.getIndexes()来查看集合的索引。 索引的标识形如keyname1_dir1_keyname2_dir2_..._keynameN_dirN，索引标识也是有长度限制的。 如果需要删除索引，可以使用dropIndex。","categories":[{"name":"Database","slug":"Database","permalink":"http://sinlapis.github.io/categories/Database/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://sinlapis.github.io/tags/MongoDB/"}]},{"title":"MongoDB笔记0x04","slug":"MongoDB笔记0x04","date":"2017-10-27T11:28:33.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2017/10/27/MongoDB笔记0x04/","link":"","permalink":"http://sinlapis.github.io/2017/10/27/MongoDB笔记0x04/","excerpt":"","text":"4 查询4.1 find在MongoDB中，使用find()来进行查询操作。第一个参数是查询条件，类型为文档，其中包括希望返回结果满足的键值对的要求。如果有对个键值对，将视为“与”进行查询。 find()的第二个参数为希望返回/不返回的键，类型为文档，键即文档的键，值为1则返回该键值对，值为0则不返回该键值对。_id默认是返回的，如果不希望返回_id，可以使用&quot;_id&quot;: 0。 4.2 查询条件除了精确查询以外，还可以使用$lt、$lte、$gt、$gte来进行范围查询，它们分别表示&lt;、&lt;=、&gt;、&gt;=。例如： { \"age\": { \"$gt\": 18, \"$lt\": 30 } } 上述查询条件表示查找键名&quot;age&quot;值大于18小于30的文档。另外，$ne表示不相等。 关于$in、$nin：如果希望能查找某个键对应的多个值，可以使用$in。$in的参数为一个数组，数组中的值可以为任何类型，MongoDB会查找所有该键的值在数组中的文档。$nin则相反，会返回所有该键的值不在数组中的文档。 关于$or：$or可以进行不同键的“或”查询。和$in类似，其参数为一个数组，不过数组中的值均为文档类型。文档中即普通的查询条件。 $not：$not会返回所有不符合参数中查询条件的文档。和$and、$or都被称为“元操作符”。 null值：如果查询时设置值为null，则查询不仅会返回对应键值为null的文档，还会返回没有对应键的文档。如果不希望返回这些缺少键的文档，可以使用$exist来判断键值对是否存在。 正则表达式：进行匹配的值可以是正则表达式，所有含有匹配正则表达式的对应键值的文档都会被返回。使用正则表达式进行查询之前最好在shell中进行正则表达式的验证来防止出现问题。 数组查询：如果有一个文档： { \"fruit\": [\"apple\", \"banana\", \"peach\"] } 如果查询条件如下： { \"fruit\": \"apple\" } 则之前的文档会成功匹配。即如上的查询条件意味着MongoDB会查找数组内部的值。但是如果查询条件如下： { \"fruit\": [\"apple\", \"banana\"] } 或 { \"fruit\": [\"banana\", \"apple\", \"peach\"] } 都不会匹配所提供的文档。即值如果是数组的话会进行精确匹配，无论是缺项或者是乱序都不会匹配。 $all：$all可以接受一个数组作为查询参数，只要对应键的数组中包含该数组内所有值的文档就会作为结果返回。其中$all的数组参数的顺序是无关紧要的。 $slice：$slice可以限制返回的文档数。为正值时返回前面指定数目的文档，为负值时返回后面指定数目的文档。$slice还可以指定偏移，例如： { \"comments\": { \"$slice\": [23, 10] } } 表示从第24个元素开始，返回10个文档，不足则全部返回。 数组和范围查询相互作用：例如文档： [ {\"x\": 5}, {\"x\": 15}, {\"x\": 25}, {\"x\": [5, 25]} ] 如果查询条件为： { \"x\": { \"$gt\": 10, \"$lt\": 20 } } 则结果会返回： [ {\"x\": 15}, {\"x\": [5, 25]} ] 匹配{&quot;x&quot;: [5, 25]}的原因是5小于20且25大于10。 查询内嵌文档：如果直接进行查询的话需要内嵌文档完全一致（即和数组查询一样是精确匹配），而且不能针对内嵌文档进行范围等条件查询。使用$elemMatch来满足进行内嵌文档的查询。例如： { \"comments\":{ \"$elemMatch\": { \"author\": \"Joe\", \"score\": {\"$gte\": 5} } } } 可以查到评论中Joe 大于等于5分的评论。","categories":[{"name":"Database","slug":"Database","permalink":"http://sinlapis.github.io/categories/Database/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://sinlapis.github.io/tags/MongoDB/"}]},{"title":"MongoDB笔记0x03","slug":"MongoDB笔记0x03","date":"2017-10-24T10:59:30.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2017/10/24/MongoDB笔记0x03/","link":"","permalink":"http://sinlapis.github.io/2017/10/24/MongoDB笔记0x03/","excerpt":"","text":"3.3 更新文档更新update()可以接收两个参数，一个是查询条件，即需要修改哪个文档；另一个是需修改的内容。更新操作时不可分割的。如果有两个更新同时发生，则请求先到达服务器的先执行。系统则会保留最后的更新。update的第三个参数是upsert，类型为布尔值，为true则在查询过程中若没有找到符合条件的文档时会进行创建。第四个参数是是否修改查询得到的全部文档，默认为false，即只修改查询得到的第一个文档。 默认情况下，update中需修改的内容会被认为是替换原有文档，但是如果希望仅针对文档中的某键值修改的话，可以使用修改器，例如： db.analytics.update( {\"url\": \"www.example.com\"}, {\"$inc\": {\"pageviews\": 1}} ) 不同的修改器修改文档的速度是不同的。例如只修改值的$inc修改器修改速度很快，因为不需要改变文档大小。但是可以修改文档大小的——例如$set——就会比较慢，由于MongoDB是给每个文档固定长度的存储空间，如果文档变大进而不能再原先位置存储，还需要移动的磁盘上的其他位置。文档有一个填充因子的参数，用于文档大小的增长。如果一个文档多次因变大而在磁盘上移动，则该文档的填充因子同样会增长。 一个修改操作中不能含有多个修改器，例如在某个修改请求中同时含有$inc和$set，这个请求就是非法的。 为防止多个线程/进程修改同一个文档而导致竞态，MongoDB提供了一个findAndModify方法，其查找和修改是原子操作，不会出现竞态。findAndModify不仅可以用于update，也可以用于remove。 写入安全：分为应答式写入和非应答式写入。应答式写入是指客户端提出写入请求后等待服务端返回写入结果，非应答式写入则相反。","categories":[{"name":"Database","slug":"Database","permalink":"http://sinlapis.github.io/categories/Database/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://sinlapis.github.io/tags/MongoDB/"}]},{"title":"MongoDB笔记0x02","slug":"MongoDB笔记0x02","date":"2017-10-23T02:28:36.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2017/10/23/MongoDB笔记0x02/","link":"","permalink":"http://sinlapis.github.io/2017/10/23/MongoDB笔记0x02/","excerpt":"","text":"2.7 MongoDB shell 的使用由于使用了V8引擎，MongoDB shell支持运行JavaScript代码，并且如果在启动MongoDB客户端时在mongo后面添加js文件，即可在shell可交互之前运行指定的js代码。如果有些js文件需要频繁运行，可以把这部分JavaScript代码写入一个名为.mongorc.js的文件，并放在用户主目录下；这时MongoDB shell运行时就会先执行.mongorc.js。 mongorc.js中，可以： （1）创建需要的全局变量；（2）简化过长的名字，为其起一个别名；（3）重写内置函数；（4）移除比较危险的函数，例如dropDatabase以及deleteIndexes,让它们不能执行，防止误操作。这条是比较常用的。 shell中的提示是可以定制的，例如在查询过程中显示时间以及显示当前使用的Da名。 如果在shell中希望修改之前已经输入的行，可以在.mongorc.js中添加一行： EDITOR = \"/usr/bin/vi\" 如此，需要修改某个变量时可以输入edit post即可修改post变量。 shell与集合命名：如果集合名中包含JavaScript的保留字或者不允许的字符，将不能使用db.collectionName的形式来访问集合，需要使用函数db.getCollection()来代替，也可以使用类似于db[&#39;collectionName&#39;]来访问。 2.8 服务器端脚本在服务器上执行脚本务必注意安全性问题。如果配置不当，很容易遭受注入攻击。例如： func = \"function() { print('Hello, '\" + name + \"); }\" 此时用户如果传入的name为： name = \"'); db.dropDatabase(); print('\" 这样和原脚本中拼接起来是合法的JavaScript代码时，就造成了注入攻击，导致数据库被删除。防范注入攻击主要是确保不要将用户输入的内容直接传递给mongod，例如应对上述的注入攻击可以使用作用域，以下为python的例子： func = pymongo.code.Code(\"function() { print('Hello, ' + username + '!'); }\", {\"username\": name}) 如此再输入之前的内容，则输出结果会变为： Hello, &#39;); db.dropDatabase(); print(&#39;! 3 创建、更新和删除文档3.1 插入并保存文档批量插入：除了使用insert插入单条数据，还可以使用batchInsert进行批量插入，它接受一个文档数组。MongoDB接受的最长消息为48MB，如果超过48MB，多数的驱动程序会将插入请求拆分成多个。如果在插入的过程中某个文档插入错误，则这个文档之前的文档均插入成功，之后的文档均插入失败。可以设置continueOnError参数，跳过插入有误的文档，继续进行插入。所有的驱动程序均支持该参数，但shell不支持。 插入校验：插入文档时，会进行基本的数据校验，例如检查有没有_id字段，没有则会自动生成一个；会检查文档的大小，单个文档的大小不能超过16M，以防止不良的设计模式，保持性能的一致；会检查有误非utf-8字符存在等等。但尽管如此，向MongoDB中插入非法数据是十分容易的，所以应当只允许信任源连接数据库是必要的。 3.2 删除文档使用remove()进行文档删除时，会删除集合中的所有文档，但不会删除集合本身，以及集合的元信息。remove()也可以接受一个条件参数，来删除指定的文档。删除时永久性的，不可撤销，也不可恢复。 使用drop()的删除速度要远远超过remove()，但是如此之后集合也会被删除，也不能指定条件。","categories":[{"name":"Database","slug":"Database","permalink":"http://sinlapis.github.io/categories/Database/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://sinlapis.github.io/tags/MongoDB/"}]},{"title":"MongoDB笔记0x01","slug":"MongoDB笔记0x01","date":"2017-10-21T12:48:13.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2017/10/21/MongoDB笔记0x01/","link":"","permalink":"http://sinlapis.github.io/2017/10/21/MongoDB笔记0x01/","excerpt":"2.5 MongoDB shellMongoDB的shell包含Google的V8引擎，可以执行JavaScript代码，支持JavaScript标准库。打开shell时将会自动连接到本地的MongoDB服务器，也可以指定连接到远端的MongoDB服务器。此外，MongoDB的shell也提供一些方便的语法糖，供习惯于SQL shell的用户使用。","text":"2.5 MongoDB shellMongoDB的shell包含Google的V8引擎，可以执行JavaScript代码，支持JavaScript标准库。打开shell时将会自动连接到本地的MongoDB服务器，也可以指定连接到远端的MongoDB服务器。此外，MongoDB的shell也提供一些方便的语法糖，供习惯于SQL shell的用户使用。 2.6 数据类型MongoDB中包含JSON中的几种基本数据类型，还包括了一些其他的扩展类型，以下举出常用的数据类型：（1）null：空值或值不存在；（2）布尔值：true或false；（3）数值：shell中默认使用64位的浮点数，如果想表示整数，可以使用整数类NumberInt（4字节有符号整数）或NumberLong（8字节有符号整数）；（4）字符串：utf-8的字符串；（5）日期：Date类，使用new Date()创建；（6）正则表达式：与JavaScript的正则表达式相同；（7）内嵌文档：将一个文档作为另一个文档的值；（8）对象id：ObjectId类，作为文档的唯一标识；（9）数组：由一系列可以不同类型的数据构成。 关于日期：如果不使用new Date()创建日期对象而使用形如Date(...)的构造函数，返回的将是字符串而不是毫秒数。 关于内嵌文档：内嵌文档可以让数据存储更加自然、高效、立体。例如： { \"name\": \"Joe\", \"address\": { \"street\": \"123 Park Street\", \"city\": \"X town\", \"state\": \"NY\" } } 如果将这段数据存入关系型数据库中，一般来说会拆分成复数个表，会比较复杂。但是，MongoDB如此做的缺点是造成数据冗余。例如某城市的拼写有误，在关系型数据库中只需要修改城市表中有误的项，而对于MongoDB来说则是对属于该城市的每个人的信息进行修改。 关于_id：在MongoDB中，每个文档都必须有_id，其值可以是任意类型的任何值。在同一个集合的不同文档，其_id不能相同。 关于ObjectId：这是一种轻量型生成ID的类，可以在不同的机器上使用同种方法生成全局唯一的ID。由于传统数据库中使用的自增主键很难在分布式数据库中同步生成，所以MongoDB采用了这种方法。 ObjectId构成：ObjectId占用12字节的空间，其中0-3字节是秒级的时间戳，标明文档的创建时间；4-6字节是机器名的hash值，以保证不同机器产生的ObjectId不同；7-8字节是PID，以保证在同一机器上并发的进程产生的文档的ObjectId不同；9-11字节是一个自增的计数器，以保证同一进程在1秒内创建的文档的ObjectId不同，一个进程在一秒内最多可以拥有2563个不同的ObjectId。 插入文档时如果没有_id，系统会自动生成ObjectId。虽然可以由MongoDB服务器来做这件事，但通常是由客户端的驱动程序来完成。这体现了MongoDB的哲学理念：能交给客户端驱动程序做的事就不要交给服务器来做。因为扩展应用层比扩展数据库层简单很多，将部分工作交给客户端来完成，也能够减少服务器的负担。","categories":[{"name":"Database","slug":"Database","permalink":"http://sinlapis.github.io/categories/Database/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://sinlapis.github.io/tags/MongoDB/"}]},{"title":"MongoDB笔记0x00","slug":"MongoDB笔记0x00","date":"2017-10-20T11:33:13.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2017/10/20/MongoDB笔记0x00/","link":"","permalink":"http://sinlapis.github.io/2017/10/20/MongoDB笔记0x00/","excerpt":"1 MongoDB简介MongoDB是一个面向文档的数据库，与传统的关系型数据库不同，MongoDB中没有行的概念，取而代之的是文档中的内容和数组。这种形式可以灵活的表现各种复杂的层次关系，加快开发者开发进程。","text":"1 MongoDB简介MongoDB是一个面向文档的数据库，与传统的关系型数据库不同，MongoDB中没有行的概念，取而代之的是文档中的内容和数组。这种形式可以灵活的表现各种复杂的层次关系，加快开发者开发进程。 当数据积累到一定程度，当前的服务器性能不足以胜任计算性能和存储空间要求时，应当进行数据库的纵向扩展或者横向扩展。纵向扩展是指单纯提高服务器的硬件性能，横向扩展是指向服务器集群中添加更多的服务器。显然纵向扩展是有极限的，而MongoDB可以进行较为方便的横向扩展，以提高数据库集群的计算能力以及存储空间。 MongoDB支持索引、聚合、特殊的集合类型、文件存储的功能，但是例如连接和复杂的多行事物等是不支持的，这是由于这些功能不方便在分布式系统上实现。 2 基础部分2.1 文档文档是一组有序键值对的集合。注意：（1）键中不能含有\\0（表示字符串结尾），.和$有特殊含义，不能随意使用；（2）键不能重复；（3）键字符串可以是任意utf-8符号。 2.2 集合集合是一组文档。虽然可以将不同结构的文档，但是出于方便管理、为集合建立索引以及查询性能的考虑，建议把同种结构、包括同类内容的文档归入同一集合内。这也是为什么设计集合的原因。 类似于文档键的命名规则，集合名的命名规则有：（1）不能为&quot;&quot;；（2）不能包含\\0、$；（3）不能以system.开头，这些是系统集合的保留前缀。 可以用.来进行子集合的组织，构成各种不同的集合子命名空间。 2.3 数据库数据库由多个集合组成。每个数据库都是独立的，无论是权限还是磁盘存储位置。 与集合名、文档键名类似，数据库名也有相应的命名规则：（1）不能为&quot;&quot;；（2）不能包含\\、/、*、&quot;、&lt;、&gt;、|、?、、$、\\0，推荐使用ASCII中的字母和数字；（3）区分字母大小写，简单起见，均使用小写字母；（4）数据库名最长为64字节。 有一些数据库名是保留的，它们有相应的功能：（1）admin：如果将一个用户加入该数据库，它将获得所有数据库的权限，另外有一些指令必须从admin数据库中启动；（2）local：所有本地的集合都会存到这个数据库中，此外，该数据库不能复制；（3）config：分片信息会保存到这个数据库中。 2.4 安装MongoDB以及启动安装环境为CentOS 7。 添加官方源到/etc/yum.repos.d/mongo-2.6.repo： [mongodb-org-2.6] name=MongoDB Repository baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/2.6/x86_64/ gpgcheck=1 enabled=1 gpgkey=https://www.mongodb.org/static/pgp/server-2.6.asc 使用yum开始安装： yum -y install mongodb-org 启动MongoDB服务： systemctl start mongod","categories":[{"name":"Database","slug":"Database","permalink":"http://sinlapis.github.io/categories/Database/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://sinlapis.github.io/tags/MongoDB/"}]},{"title":"建立docker镜像仓库","slug":"建立docker镜像仓库","date":"2017-10-02T12:11:27.000Z","updated":"2021-03-03T02:50:12.463Z","comments":true,"path":"2017/10/02/建立docker镜像仓库/","link":"","permalink":"http://sinlapis.github.io/2017/10/02/建立docker镜像仓库/","excerpt":"","text":"操作系统为CentOS 7。 Docker安装安装依赖yum install -y yum-utils device-mapper-persistent-data lvm2 添加阿里源yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 安装Dockeryum install docker-ce 启动Dockersystemctl enable docker systemctl start docker registry安装安装registry及运行docker-registry本身也是docker镜像，从官方仓库拉取对应镜像。在仓库服务器上执行： docker pull registry:2 运行该镜像： docker run -d -p 5000:5000 --restart=always --name registry -v /var/data:/var/lib/registry registry:2 镜像拉取在仓库服务器上上传本地镜像： docker load < centos:1 docker tag centos:1 localhost:5000/centos:1 docker push localhost:5000/centos:1 在客户端通过HTTP访问仓库，需要先修改/etc/docker/daemon.json： { \"insecure-registries\":[\"192.168.59.137:5000\"] } 之后输入命令： systemctl restart docker docker pull 192.168.59.137:5000/centos:1 使用registry API例如在不知道镜像名称以及版本号时，则需要向registry发起查询。此时可以使用registry提供的API。 import requests url = 'http://192.168.59.137:5000/v2/' r = requests.get(url + '_catalog') print(r.text) # {\"repositories\":[\"busybox\"]} r = requests.get(url + 'busybox/tags/list') # {\"name\":\"busybox\",\"tags\":[\"1.25.1-musl\"]}","categories":[{"name":"Docker","slug":"Docker","permalink":"http://sinlapis.github.io/categories/Docker/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://sinlapis.github.io/tags/Linux/"},{"name":"Docker","slug":"Docker","permalink":"http://sinlapis.github.io/tags/Docker/"}]},{"title":"FluentPython笔记0x07","slug":"FluentPython笔记0x07","date":"2017-09-15T11:28:22.000Z","updated":"2021-03-03T02:50:12.455Z","comments":true,"path":"2017/09/15/FluentPython笔记0x07/","link":"","permalink":"http://sinlapis.github.io/2017/09/15/FluentPython笔记0x07/","excerpt":"","text":"Mappings with Flexible Key Lookup（p70） defaultdict：类似与dict.default()，可创建一个带有默认值类型的dict，例如defaultdict(int)，则遇到不存在的Key时，其取值为0。这个过程中会调用default_factory，进而会调用special method __missing__。 __missing__：该special method没有在dict中定义，但如果在dict的子类中定义__missing__，则__getitem__在遇到缺失的key时不会抛出KeyError，而是会转而调用__missing__。__missing__在其他时候不会被调用，例如__contains__。 例3-7： class StrKeyDict0(dict): def __missing__(self, key): if isinstance(key, str): raise KeyError(key) return self[str(key)] def get(self, key, default=None): try: return self[key] except KeyError: return default def __contains__(self, key): return key in self.keys() or str(key) in self.keys() 有两处需要注意：1.在__missing__中，isinstance的检查不可少。__missing__被调用时，情况有三种：（1）是int型，但其str型在dict中；（2）是int型，且str型不在dict中；（3）是str型但不在dict中。如果没有isinstance的过滤，str型也不在dict中时self[str(key)]还会调用__missing__，陷入死循环。2.在__contains__中，没有使用key in dict而是用key in dict.keys()是因为前者依然会调用__missing__，而导致int型的2也会在dict的keys中。","categories":[{"name":"Python","slug":"Python","permalink":"http://sinlapis.github.io/categories/Python/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://sinlapis.github.io/tags/笔记/"},{"name":"Python","slug":"Python","permalink":"http://sinlapis.github.io/tags/Python/"}]},{"title":"PostgreSQL安装及初始化","slug":"PostgreSQL安装及初始化","date":"2017-08-28T03:11:31.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2017/08/28/PostgreSQL安装及初始化/","link":"","permalink":"http://sinlapis.github.io/2017/08/28/PostgreSQL安装及初始化/","excerpt":"参考：https://www.mtyun.com/library/28/how-to-install-postgresql9/本文安装环境为CentOS 6.4，安装PostgreSQL版本为9.3","text":"参考：https://www.mtyun.com/library/28/how-to-install-postgresql9/本文安装环境为CentOS 6.4，安装PostgreSQL版本为9.3 安装ca-certificates由于官网提供的yum仓库为https，需要安装ca-certificates： yum install ca-certificates 安装PostgreSQL 9.3 yum install http://yum.postgresql.org/9.3/redhat/rhel-6-x86_64/pgdg-centos93-9.3-2.noarch.rpm yum install postgresql93-server postgresql93-contrib 配置环境变量新建数据库物理文件的存放目录： mkdir -p /home/postgres/data 使用用户postgres管理PostgreSQL并配置环境变量： su - postgres cp /etc/skel/.bash* /var/lib/pgsql 修改/var/lib/pgsql/.bashrc： export PGDATA=/home/postgres/data export PATH=/usr/pgsql-9.3/bin:$PATH 其中PGDATA为数据库物理文件的存放目录。重新加载.bashrc： source .bashrc 初始化并启动数据库 initdb pg_ctl start 修改账户密码在终端输入psql进入PostgreSQL交互界面： alter user postgres with password 'password';","categories":[{"name":"Database","slug":"Database","permalink":"http://sinlapis.github.io/categories/Database/"}],"tags":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"http://sinlapis.github.io/tags/PostgreSQL/"},{"name":"CentOS","slug":"CentOS","permalink":"http://sinlapis.github.io/tags/CentOS/"}]},{"title":"FluentPython笔记0x06","slug":"FluentPython笔记0x06","date":"2017-08-17T00:57:21.000Z","updated":"2021-03-03T02:50:12.455Z","comments":true,"path":"2017/08/17/FluentPython笔记0x06/","link":"","permalink":"http://sinlapis.github.io/2017/08/17/FluentPython笔记0x06/","excerpt":"Chapter 3Generic Mapping Types（p64) 可哈希：如果一个对象在它的生命周期中有一个不会改变的哈希值（它需要有__hash__()函数），并且它能够和其他对象进行比较（需要有__eq__()函数）。可哈希的对象相等必须拥有相同的哈希值。str、bytes以及数类型都是可哈希的；frozenset也总是可哈希的，因为它的元素必须可哈希；tuple仅当它包含的所有元素可哈希是它才是可哈希的。例：","text":"Chapter 3Generic Mapping Types（p64) 可哈希：如果一个对象在它的生命周期中有一个不会改变的哈希值（它需要有__hash__()函数），并且它能够和其他对象进行比较（需要有__eq__()函数）。可哈希的对象相等必须拥有相同的哈希值。str、bytes以及数类型都是可哈希的；frozenset也总是可哈希的，因为它的元素必须可哈希；tuple仅当它包含的所有元素可哈希是它才是可哈希的。例： tt = (1, 2, (30, 40)) print(hash(tt)) # 8027212646858338501 tl = (1, 2, [30, 40]) print(hash(tl)) # TypeError: unhashable type: 'list' 建立dict： a = dict(one=1, two=2, three=3) b = {'one': 1, 'two': 2, 'three': 3} c = dict(zip(['one', 'two', 'three'], [1, 2, 3])) d = dict({'three': 3, 'one': 1, 'two': 2}) print(a == b == c == d) # True dict Comprehesions（p66） 类似与listcomp，dict也有dictcomp。 DIAL_CODES = [ (86, 'China'), (91, 'India'), (1, 'United States'), (62, 'Indonesia'), (55, 'Brazil'), (92, 'Pakistan'), (880, 'Bangladesh'), (234, 'Nigeria'), (7, 'Russia'), (81, 'Japan'), ] country_code = {country: code for code, country in DIAL_CODES} print(repr(country_code)) # {'China': 86, 'India': 91, 'United States': 1, 'Indonesia': 62, 'Brazil': 55, 'Pakistan': 92, 'Bangladesh': 880, 'Nigeria': 234, 'Russia': 7, 'Japan': 81} print(repr({code: country.upper() for country, code in country_code.items() if code &lt; 66})) # {1: 'UNITED STATES', 62: 'INDONESIA', 55: 'BRAZIL', 7: 'RUSSIA'} 鸭子类型（duck typing，参考维基百科）：“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”鸭子类型是动态类型的一种风格。在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由”当前方法和属性的集合”决定。 Handling Missing Keys with setdefault（p68） d.get和d.setdefault：d.get(k, default)是一种比较方便来处理KeyError的方法，在没有k值时会返回default。但是如果想更新字典中键值对使用setdefault会更加方便。 import sys import re WORD_RE = re.compile('\\w+') def dict_get(fp): index = {} for line_no, line in enumerate(fp, 1): for match in WORD_RE.finditer(line): word = match.group() column_no = match.start() + 1 location = (line_no, column_no) occurrences = index.get(word, []) occurrences.append(location) index[word] = occurrences for word in sorted(index, key=str.upper): print(word, index[word]) def dict_setdefault(fp): index = {} for line_no, line in enumerate(fp, 1): for match in WORD_RE.finditer(line): word = match.group() column_no = match.start() + 1 location = (line_no, column_no) index.setdefault(word, []).append(location) for word in sorted(index, key=str.upper): print(word, index[word]) if __name__ == '__main__': with open(sys.argv[1], encoding='utf-8') as fp: dict_get(fp) dict_setdefault(fp) 对比dict_get和dict_setdefault两种方法可发现setdefault更加方便。 有关于字典排序：对于字典d，如果希望对其进行按key排序，可以直接使用sorted(d)，如果希望对其进行值的排序，则可以： for key in sorted(d, key=d.get): print(key, d[key]) 关于正则表达式匹配的几个函数match、search、findall、finditer：match成功匹配会返回Match对象，失败会返回None；search类似match，但只返回第一个匹配字符串；findall返回为数组形式的结果；finditer返回迭代器形式的结果。","categories":[{"name":"Python","slug":"Python","permalink":"http://sinlapis.github.io/categories/Python/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://sinlapis.github.io/tags/笔记/"},{"name":"Python","slug":"Python","permalink":"http://sinlapis.github.io/tags/Python/"}]},{"title":"FluentPython笔记0x05","slug":"FluentPython笔记0x05","date":"2017-08-02T01:22:03.000Z","updated":"2021-03-03T02:50:12.455Z","comments":true,"path":"2017/08/02/FluentPython笔记0x05/","link":"","permalink":"http://sinlapis.github.io/2017/08/02/FluentPython笔记0x05/","excerpt":"NumPy and SciPy（p52） numpy.ndarray的基础操作：","text":"NumPy and SciPy（p52） numpy.ndarray的基础操作： import numpy a = numpy.arange(12) # array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) # type(a): numpy.ndarray # a.shape: (12,) a.shape = 3, 4 ''' array([[0, 1, 2, 3], [4, 5, 6, 7], [8, 9 ,10, 11]]) ''' print(a[2]) # 8, 9, 10, 11 print(a[2, 1]) # 9 print([:, 1]) # 1, 5, 9 a.transpose() ''' array([[0, 4, 8], [1, 5, 9], [2, 6, 10], [3, 7, 11]]) ''' Deques and Other Queues（p55） deque：如果把list当做栈使用性能上十分低下，此时应该使用deque代替。 from collections import deque dq = deque(range(10), maxlen=10) # deque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]， maxlen=10) dq.rotate(3) # deque([1, 2, 3, 4, 5, 6, 7, 8, 9, 0], maxlen=10) # rotate(n)当n>0时将n项从最右移到最左，n&lt;0反之。 dp.appendleft(-1) # deque([-1, 1, 2, 3, 4, 5, 6, 7, 8, 9], maxlen=10) # deque会保持长度，最右侧的0被移除 dq.extend([11, 22, 33]) # deque([3, 4, 5, 6, 7, 8, 9, 11, 22, 33], maxlen=10) dq.extendleft([10, 20, 30, 40]) # deque([40, 30, 20, 10, 3, 4, 5, 6, 7, 8], maxlen=10) # 从左加入列表中的数据时会反转 在deque的方法中，注意remove的实现是严格按照数据从序列两端进出的，故性能并不佳；append和popleft是原子操作，在LIFO和多线程操作的情况下不需要锁。","categories":[{"name":"Python","slug":"Python","permalink":"http://sinlapis.github.io/categories/Python/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://sinlapis.github.io/tags/笔记/"},{"name":"Python","slug":"Python","permalink":"http://sinlapis.github.io/tags/Python/"}]},{"title":"FluentPython笔记0x04","slug":"FluentPython笔记0x04","date":"2017-08-01T01:09:19.000Z","updated":"2021-03-03T02:50:12.455Z","comments":true,"path":"2017/08/01/FluentPython笔记0x04/","link":"","permalink":"http://sinlapis.github.io/2017/08/01/FluentPython笔记0x04/","excerpt":"p32 和列表相比，元组除了无法修改其中的值以外，只有一处和列表不同：元组无法使用__reversed__，但是可以使用以下方法代替：","text":"p32 和列表相比，元组除了无法修改其中的值以外，只有一处和列表不同：元组无法使用__reversed__，但是可以使用以下方法代替： t = (1, 2, 3, 4) print(tuple(reversed(t))) 元组和列表可以与int型整数相乘，含义为返回对应的元组或列表，里边包括重复整数次的原来的元组或列表的内容。 p33 像元组、列表等序列切片时为什么排除结束标号的项：1.可以简单的看出切片得到的长度，例range(3)以及my_list[:3]；2.可以简单地计算切片长度，只需结束序号减去开始序号；3.可以只使用一个序号就能把序列切成两部分，例如my_list[:x]和my_list[x:]。 切片的实现是一个切片类：slice(start, stop, step)。例： source = ''' 0.......8....12 0 AXL 5 1 August 6 2 key 10 ''' INDEX = slice(0, 2) NAME = slice(2, 8) POINT = slice(8, None) line_items = source.split('\\n')[2:] for item in line_items: print(item[POINT], item[NAME]) 切片赋值操作： l = list(range(10)) # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] l[2:5] = [20, 30] # [0, 1, 20, 30, 5, 6, 7, 8, 9] del l[5:7] # [0, 1, 20, 30, 5, 8, 9] l[3::2] = [11, 22] # [0, 1, 20, 11, 5, 22, 9] l[2:5] = 100 # 错误，左面是列表右面对应应该也是列表等可迭代对象 l[2:5] = [100] # [0, 1, 100, 22, 9] p40 有关修改元组中列表的问题：代码如下。 t = (1, 2, [30, 40]) t[2] += [50, 60] 终端报错如下 TypeError: &#39;tuple&#39; object does not support item assignment 但是此时打印t会显示 (1, 2, [30, 40, 50, 60]) 根据Python生成的字节码，元组+=这个操作的关键步骤为：1.将t[2]的值压栈（位于栈顶）；2.执行栈顶值 += [50, 60]，如果栈顶值不为可变变量的话会报错。但此处栈顶为list，故成功执行；3.执行t[2] = 栈顶值，如果t为不可变变量则会报错，此处t为元组故会出现报错。综上最终结果就是list的值改变了但是出现了报错。 总结：1.不建议在元组中填入可变项；2.自增不是原子操作，错误抛出可以在自增中的任何一个环节独立抛出，而不影响前面已执行的部分；3.如果遇到类似问题可以尝试阅读Python字节码，它并不难懂。 p42 list.sort和sorted：list.sort只能用于可变序列，会改变列表，返回值为None。sorted可以用于任何序列，它总是会返回一个新的序列而不改变原序列。 p44 使用bisect进行有序序列的查找和插入：bisect即二分查找。 import bisect import sys HAYSTACK = [1, 4, 5, 6, 8, 12, 15, 20, 21, 23, 23, 26, 29, 30] NEEDLES = [0, 1, 2, 5, 8, 10, 22, 23, 29, 30, 31] ROW_FMT = '{0:2d} @ {1:2d} {2}{0:2d}' def demo(bisect_fn): for needle in reversed(NEEDLES): position = bisect_fn(HAYSTACK, needle) offset = position * ' |' print(ROW_FMT.format(needle, position, offset)) if __name__ == '__main__': if sys.argv[-1] == 'left': bisect_fn = bisect.bisect_left else: bisect_fn = bisect.bisect print('DEMO:', bisect_fn.__name__) print('haystack ->', ' '.join('%2d' % n for n in HAYSTACK)) demo(bisect_fn) 其中bisect.bisect和bisect.bisect_right是等价的，它们和bisect.bisect_left的区别在于遇到相等的值是插入的位置不同。一般情况下看不出区别，但是像1与1.0这样的还是有所区别的。 bisect.bisect有个有趣的应用：给连续的数值分级。 def grade(score, breakpoints=[60, 70, 80, 90], grades='FDCBA'): i = bisect.bisect(breakpoints, score) return grades[i] print([grade(score) for score in [33, 99, 77, 70, 89, 90]]) # FACCBAA 此外，bisect.insort是向有序序列中插入值而不破坏有序，和bisect.bisect类似。 p48 如果对序列有特殊需求，list不一定是最好的选择。例如，如果你想保存10M个浮点数，array比list更加有效，因为array没有保存每一个float对象的全部。另外如果需要实现类似队列或者栈则可以使用deque。 array需要先指定类型，即array只能存储一种类型的数据，但是这换来的是极大的性能提升。array.fromfile和array.tofile分别可以读取文件创建序列和将序列写入文件，这两种操作要比读写文本文件加上解析转换要快很多。以下为array支持的初始化类型： table th, table td { text-align: center; padding: 5px; } 类型码 C类型 Python类型 最小占用字节 c char character 1 b signed char int 1 B unsigned char int 1 u Py_UNICODE Unicode character 2 h signed short int 2 H unsigned short int 2 i signed int int 2 I unsigned int long 2 l signed long int 4 L unsigned long long 4 f float float 4 d double float 8 p51 memorview：内存查看对象，能够使用支持缓冲区协议的数据类型进行包装，在不需要复制的情况下用Python代码访问以及等大小修改。","categories":[{"name":"Python","slug":"Python","permalink":"http://sinlapis.github.io/categories/Python/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://sinlapis.github.io/tags/笔记/"},{"name":"Python","slug":"Python","permalink":"http://sinlapis.github.io/tags/Python/"}]},{"title":"FluentPython笔记0x03","slug":"FluentPython笔记0x03","date":"2017-07-27T02:10:41.000Z","updated":"2021-03-03T02:50:12.455Z","comments":true,"path":"2017/07/27/FluentPython笔记0x03/","link":"","permalink":"http://sinlapis.github.io/2017/07/27/FluentPython笔记0x03/","excerpt":"唔，如果把这本书涉及到但是没提到的点拓展开，我什么时候能读完这本书呢？ p26 元组不仅仅是不可变的列表，还可以存储记录。","text":"唔，如果把这本书涉及到但是没提到的点拓展开，我什么时候能读完这本书呢？ p26 元组不仅仅是不可变的列表，还可以存储记录。 p27 lax_coordinates = (33.9425, -118.408056) # 洛杉矶国际机场的经纬度 city, year, pop, chg, area = ('Tokyo', 2003, 32450, 0.66, 8014) # 有关东京的数据：名称，年份，人口（百万），人口变化，面积（平方公里） traveler_ids = [('USA', '31195855'), ('BRA', 'CE342567'), ('ESP', 'XDA205856')] for passport in traveler_ids: print('%s/%s' % passport) # 上面对元组的操作称为元组解包 for country, _ in traveler_ids: print(country) # 使用 _ 作为占位符，可以只获取元组中需要的字段 b, a = a, b # 一个优雅的交换两个变量值的操作 print(divmod(20, 8)) t = (20, 8) print(divmod(*t)) # 使用 * 来解包元组传参 p29 *还可以获取多余的项。 a, b, *rest = range(5) print(repr((a, b, rest))) # 结果：(0, 1, [2, 3, 4]) a, b, *rest = range(3) print(repr((a, b, rest))) # 结果：(0, 1, [2]) a, b, *rest = range(2) print(repr((a, b, rest))) # 结果：(0, 1, []) a, *body, c, d = range(5) print(repr((a, body, c, d))) # 结果：(0, [1, 2], 3, 4) *head, b, c, d = range(5) print(repr((head, b, c, d))) # 结果：([0, 1], 2, 3, 4) 可见前缀*可以出现在任意位置。 嵌套元组解包： metro_areas = [ ('Tokyo', 'JP', 36.933, (35.689722, 139.691667)), ('Delhi NCR', 'IN', 21.935, (28.613889, 77.208889)), ('Mexico City', 'MX', 20.142, (19.433333, -99.133333)), ('New York-Newark', 'US', 20.104, (40.808611, -74.020386)), ('Sao Paulo', 'BR', 19.649, (-23.547778, -46.635833)), ] print('{:15} | {:^9} | {:^9}'.format('', 'lat.', 'long.')) fmt = '{:15} | {:9.4f} | {:9.4f}' for name, cc, pop, (latitude, longitude) in metro_areas: if longitude &lt;= 0: print(fmt.format(name, latitude, longitude)) '''结果： | lat. | long. Mexico City | 19.4333 | -99.1333 New York-Newark | 40.8086 | -74.0204 Sao Paulo | -23.5478 | -46.6358 ''' 格式字符串str.format（参考blog.xiayf.cn）: 其实%这种格式输出已经很老了，str.format可以更加方便的格式输出以及提供更多功能。下表为一些基础的数格式输出。 table th, table td { text-align: center; padding: 5px; } 数 格式 输出 描述 3.1415926 {:.2f} 3.14 保留小数点后两位 3.1415926 {:+.2f} +3.14 带符号保留小数后两位 -1 {:+.2f} -1.00 带符号保留小数后两位 2.71828 {:.0f} 3 不带小数 5 {:0&gt;2d} 05 数左补0，宽度到2 5 {:x&lt;4d} 5xxx 数右补x，宽度到4 10 {:x&lt;4d} 10xx 数右补x，宽度到4 1000000 {:,} 1,000,000 使用逗号分隔 0.25 {:.2%} 25.00% 百分比格式，两位小数 1000000000 {:.2e} 1.00e+09 科学计数法 13 {:10d} ······13 右对齐，默认，宽度为10 13 {:&lt;10d} 13······ 左对齐，宽度为10 13 {:^10d} ···13··· 居中，宽度为10 有关于str.format的用法： s1 = \"so much depends upon {}\".format(\"a red wheel barrow\") s2 = \"glazed with {} water beside the {} chickens\".format(\"rain\", \"white\") 这里{}即充当占位符，和%s的功能类似，会将format的参数依次填入。当然你也可以指定顺序填入，见下。 s1 = \" {0} is better than {1} \".format(\"emacs\", \"vim\") s2 = \" {1} is better than {0} \".format(\"emacs\", \"vim\") 此外，这样能够标记序号的好处还有防止漏掉变量，见下。 set = '(%s, %s, %s, %s, %s, %s, %s, %s)' % (a, b, c, d, e, f, g, h, i) # i是多余的 set = '({0}, {1}, {2}, {3}, {4}, {5}, {6}, {7})'.format(a, b, c, d, e, f, g) format可以为占位符命名，这样就不需要严格的顺序了。 madlib = \" I {verb} the {object} off the {place} \".format(verb=\"took\", object=\"cheese\", place=\"table\") 可以重复使用同一变量。 str = \"Oh {0}, {0}! wherefore art thou {0}?\".format(\"Romeo\") 可以转换进制。 print(\"{0:d} - {0:x} - {0:o} - {0:b} \".format(21)) 可以把format当做方法使用。 # 定义格式 email_f = \"Your email address was {email}\".format # 在另一个地方使用 print(email_f(email=\"bob@example.com\")) 如果你需要显示大括号，只要写两次就可以了。 print(\" The {} set is often represented as { {0} } \".format(\"empty\")) p30 含名称元组collections.namedtuple：在前文中提到过。注意使用namedtuple所需的内存是小于使用class的，因为namedtuple不会把参数存到完整实例__dict__中。 from collections import namedtuple City = namedtuple('City', 'name country population coordinates') tokyo = City('Tokyo', 'JP', 36.933, (35.689722, 139.691667)) 在创建一个namedtuple时，既可以像之前一样使用列表包含属性，也可以使用空格分隔的字符串。 p31 含名称元组的参数和方法： print(repr(City._fields)) # ('name', 'country', 'population', 'coordinates') LatLong = namedtuple('LatLong', 'lat long') delhi_data = ('Delhi NCR', 'IN', 21.935, LatLong(28.613889, 77.208889)) delhi = City._make(delhi_data) print(repr(delhi._asdict)) # OrderedDict([('name', 'Delhi NCR'), ('country', 'IN'), ('population', 21.935), ('coordinates', LatLong(lat=28.613889, long=77.208889))]) for key, value in delhi._asdict().items(): print(key + ':', value) ''' name: Delhi NCR country: IN population: 21.935 coordinates: LatLong(lat=28.613889, long=77.208889) ''' 其中City._make(delhi_data)与City(*delhi_data)等价。","categories":[{"name":"Python","slug":"Python","permalink":"http://sinlapis.github.io/categories/Python/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://sinlapis.github.io/tags/笔记/"},{"name":"Python","slug":"Python","permalink":"http://sinlapis.github.io/tags/Python/"}]},{"title":"FluentPython笔记0x02","slug":"FluentPython笔记0x02","date":"2017-07-26T00:57:06.000Z","updated":"2021-03-03T02:50:12.455Z","comments":true,"path":"2017/07/26/FluentPython笔记0x02/","link":"","permalink":"http://sinlapis.github.io/2017/07/26/FluentPython笔记0x02/","excerpt":"嗯，记点单词。 p14 augmented assignment: 增量赋值，例i += 1。","text":"嗯，记点单词。 p14 augmented assignment: 增量赋值，例i += 1。 aspect-oriented programming: 面向侧面编程（AOP），又称面向方面编程，是对面向对象编程的补充。侧面是一种新的模块化机制，用来描述分散在对象、类或函数中的横切关注点，即关键的逻辑部分。例如Python的装饰器，某装饰器可以包含执行某一过程前后的日志记录，那么这种编程方法即可称为面向侧面编程。 Chapter 2p21 list生成：比较两种方法的可读性。 symbols = 'abcdef' codes = [] for symbol in symbols: codes.append(ord(symbol)) print(codes) symbols = 'abcdef' codes = [ord(symbol) for symbol in symbols] print(codes) for循环的功能有很多，诸如扫描队列并取出元素、计算总和等等，但是listcomp(list comprehension, 列表推导式)的功能就只有生成一个新列表。从这个角度来看后者可读性更高。 在Python 2中，如果列表推导式、生成器表达式的作用域中的变量名和外面有重复的话是会产生冲突的。虽然Python 3解决了这一问题，但是在写代码时还是避免这种情况。 p23 Cartesian product: 笛卡尔积。下面的代码为推荐写法。 colors = ['black', 'white'] sizes = ['S', 'M', 'L'] tshirts = [(color, size) for color in colors for size in sizes] print(tshirts) p25 generator expression: 生成器表达式。 symbols = 'abcdef' print(tuple(ord(symbol) for symbol in symbols)) import array print(array.array('I', (ord(symbol) for symbol in symbols))) 当生成器表达式单独作为参数时不需要加括号。但像在array中接受两个参数时，生成器表达式需要加上圆括号。上述的T恤的代码用生成器表达式改写： colors = ['black', 'white'] sizes = ['S', 'M', 'L'] for tshirt in ('%s %s' % (c, s) for c in colors for s in sizes): print(tshirt) 注意生成器的结果不会全部保存在内存中，它一次只会给for循环一个结果。","categories":[{"name":"Python","slug":"Python","permalink":"http://sinlapis.github.io/categories/Python/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://sinlapis.github.io/tags/笔记/"},{"name":"Python","slug":"Python","permalink":"http://sinlapis.github.io/tags/Python/"}]},{"title":"Fluent Python笔记0x01","slug":"FluentPython笔记0x01","date":"2017-07-19T06:34:10.000Z","updated":"2021-03-03T02:50:12.455Z","comments":true,"path":"2017/07/19/FluentPython笔记0x01/","link":"","permalink":"http://sinlapis.github.io/2017/07/19/FluentPython笔记0x01/","excerpt":"划了两周水…… p8 special methods是由Python解释器调用，不需要你来调用（虽然也可以亲自调用）。 对于内置类型如list，str，bytearray等来说，调用len()则是由CPython直接返回PyVarObject（C的struct）中关于长度的变量，这比调用__len__要快很多。","text":"划了两周水…… p8 special methods是由Python解释器调用，不需要你来调用（虽然也可以亲自调用）。 对于内置类型如list，str，bytearray等来说，调用len()则是由CPython直接返回PyVarObject（C的struct）中关于长度的变量，这比调用__len__要快很多。 p10 例子1-2： from math import hypot class Vector: def __init__(self, x=0, y=0): self.x = x self.y = y def __repr__(self): return 'Vector(%r, %r)' % (self.x, self.y) def __abs__(self): return hypot(self.x, self.y) def __bool__(self): return bool(abs(self)) def __add__(self, other): x = self.x + other.x y = self.y + other.y return Vector(x, y) def __mul__(self, other): return Vector(self.x * other, self.y * other) p11 关于__str__和__repr__的区别（参考：StackOverflow） 简单来说__repr__是为了保证无歧义，而__str__是为了提供可读性。在Python提供的类中，使用__repr__返回的结果都是格式化的数据，是符合Python语法的；__str__则是面向一般用户，提供可读性，但不保证无歧义，例如int型的3和str的3满足： str(3) == str('3') p12 关于运算符：例1-2中声明的__add__和__mul__是针对+和*的重载。注意这里乘法参数顺序必须为向量在前数在后。 布尔值：在Python中，任何对象都有布尔值。如果对象未声明__bool__或__len__，则其布尔值恒为True。如果声明了__bool__则bool()会使用其返回值。如果没有声明__bool__而声明了__len__则会使用len()的返回值，为0则为False，否则为True。 有关例1-2中Vector.__bool__一个更加便捷的声明： def __bool__(self): return bool(self.x or self.y) 这样可以避免使用abs()。","categories":[{"name":"Python","slug":"Python","permalink":"http://sinlapis.github.io/categories/Python/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://sinlapis.github.io/tags/笔记/"},{"name":"Python","slug":"Python","permalink":"http://sinlapis.github.io/tags/Python/"}]},{"title":"VMWare共享文件夹设置","slug":"VMWare共享文件夹设置","date":"2017-07-19T02:15:45.000Z","updated":"2021-03-03T02:50:12.459Z","comments":true,"path":"2017/07/19/VMWare共享文件夹设置/","link":"","permalink":"http://sinlapis.github.io/2017/07/19/VMWare共享文件夹设置/","excerpt":"参考：http://www.itread01.com/articles/1476103217.html 讲道理还是在Windows下写代码舒服一些，那么就需要把代码同步到Linux虚拟机上。使用VMWare的共享文件夹是个好方法。虚拟机为CentOS7。","text":"参考：http://www.itread01.com/articles/1476103217.html 讲道理还是在Windows下写代码舒服一些，那么就需要把代码同步到Linux虚拟机上。使用VMWare的共享文件夹是个好方法。虚拟机为CentOS7。 首先给Windows和Linux虚拟机均安装VMWare Tools，下面为Linux下安装VMWare Tools： yum install open-vm-tools open-vm-tools-desktop 配置服务： vi /etc/systemd/system/mnt.hgfs.service 内容为： [Unit] Description=Load VMware shared folders Requires=vmware-vmblock-fuse.service After=vmware-vmblock-fuse.service ConditionPathExists=.host:/ ConditionVirtualization=vmware [Service] Type=oneshot RemainAfterExit=yes ExecStart= ExecStart=/usr/bin/vmhgfs-fuse -o allow_other -o auto_unmount .host:/ /mnt/hgfs [Install] WantedBy=multi-user.target 保存然后启动服务： systemctl enable mnt.hgfs.service 创建挂载文件夹： mkdir -p /mnt/hgfs 重启虚拟机应该就能看到共享的文件夹了。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://sinlapis.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://sinlapis.github.io/tags/Linux/"},{"name":"VMWare","slug":"VMWare","permalink":"http://sinlapis.github.io/tags/VMWare/"}]},{"title":"Fluent Python笔记0x00","slug":"FluentPython笔记0x00","date":"2017-07-05T07:28:36.000Z","updated":"2021-03-03T02:50:12.455Z","comments":true,"path":"2017/07/05/FluentPython笔记0x00/","link":"","permalink":"http://sinlapis.github.io/2017/07/05/FluentPython笔记0x00/","excerpt":"鬼使神差地买了一本英文的，想想还是写个笔记。版本为东南大学的影印版，原版***贵。 Chapter 1p4 Python中类似于__getitem__这种方法称为special method，作者称其为“dunder-getitem”。此外，类似__x是有其他含义的。","text":"鬼使神差地买了一本英文的，想想还是写个笔记。版本为东南大学的影印版，原版***贵。 Chapter 1p4 Python中类似于__getitem__这种方法称为special method，作者称其为“dunder-getitem”。此外，类似__x是有其他含义的。 p5 collections: 包含一些数据类型，例如namedtuple等。 参考: http://www.zlovezl.cn/articles/collections-in-python/ collections.namedtuple(): 构建一个可以用名称取值的tuple，例如： Point = collections.namedtuple('Point', ['x', 'y']) point = Point(1, 2) print(point.x) 参考: http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001411031239400f7181f65f33a4623bc42276a605debf6000 例子1-1： import collections Card = collections.namedtuple('Card', ['rank', 'suit']) class FrenchDeck: ranks = [str(n) for n in range(2, 11)] + list('JQKA') suits = 'spades diamonds clubs hearts'.split() def __init__(self): self._cards = [Card(rank, suit) for suit in self.suits for rank in self.ranks] def __len__(self): return len(self._cards) def __getitem__(self, position): return self._cards[position] 其中，使用collections.namedtuple建立了一张扑克牌的模型，FrenchDeck则建立了所有的扑克牌。此时在Python shell中输入： &gt;&gt;&gt; deck[3] 会得到如下结果： Card(rank=&#39;K&#39;, suit=&#39;hearts&#39;) 这是由__getitem__方法提供的。 对于Python数据模型来说，special method 的优点： 统一标准操作（例如，用户不需要记住每种数据模型对应的获取长度的方法是.size()还是.length()）。 通过提供统一的special method，可以丰富Python标准库（例如上述的random.rich），也可以支持Python中包含的运算符操作（例如FrenchDeck支持迭代，也支持[]操作符）。 使用in操作时，如果数据模型没有实现__contains__方法，Python会进行顺序扫描。 目前的_cards中扑克牌序列是不能被打乱的，在Chapter 11中会介绍__setitem__方法来实现。","categories":[{"name":"Python","slug":"Python","permalink":"http://sinlapis.github.io/categories/Python/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://sinlapis.github.io/tags/笔记/"},{"name":"Python","slug":"Python","permalink":"http://sinlapis.github.io/tags/Python/"}]}]}